# tcap.cnf
# $Id$
# tcap conformation file

#.OMIT_ASSIGNMENT
RLRQ-apdu
RLRE-apdu
Release-request-reason
Release-response-reason
#.END

#.MODULE_IMPORT

#.EXPORTS
DialoguePDU
UniDialoguePDU

#.REGISTER
DialoguePDU    B "0.0.17.773.1.1.1"  "dialogue-as-id"
UniDialoguePDU B "0.0.17.773.1.2.1"  "uniDialogue-as-id"

#.PDU


#.NO_EMIT

#.TYPE_RENAME
AARE-apdu/_untag/application-context-name AARE_application_context_name
AARQ-apdu/_untag/application-context-name AARQ_application_context_name
AUDT-apdu/_untag/application-context-name AUDT_application_context_name

AARQ-apdu/_untag/user-information AARQ_user_information
AARE-apdu/_untag/user-information AARE_user_information
ABRT-apdu/_untag/user-information ABRT_user_information
AUDT-apdu/_untag/user-information AUDT_user_information

#.FIELD_RENAME
AARQ-apdu/_untag/application-context-name aarq_application_context_name
AARE-apdu/_untag/application-context-name aare_application_context_name
AUDT-apdu/_untag/application-context-name audt_application_context_name

AARQ-apdu/_untag/user-information aarq_user_information
AARE-apdu/_untag/user-information aare_user_information
AUDT-apdu/_untag/user-information audt_user_information
ABRT-apdu/_untag/user-information abrt_user_information
#.END


#----------------------------------------------------------------------------------------
#.FN_BODY DialogueOC

return dissect_tcap_ExternalPDU(FALSE /*implicit_tag*/, tvb, offset, actx, tree, -1);

#----------------------------------------------------------------------------------------
#.FN_BODY ExternalPDU

%(DEFAULT_BODY)s

#----------------------------------------------------------------------------------------
#.FN_BODY Dialog1 

return dissect_tcap_DialoguePDU(TRUE, tvb, offset, actx, tree, -1);

#----------------------------------------------------------------------------------------
#.FN_BODY Parameter

return dissect_tcap_param(actx,tree,tvb,offset);

#----------------------------------------------------------------------------------------
#.FN_BODY User-information

return dissect_tcap_UserInformation(FALSE, tvb, offset, actx, tree, -1);

#----------------------------------------------------------------------------------------
#.FN_BODY Component
tvbuff_t	*next_tvb;
gint8 class;
gboolean pc;
gint tag;
guint32 len, comp_offset;
gint ind_field;

comp_offset = dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &class, &pc, &tag);
comp_offset = dissect_ber_length(actx->pinfo, tree, tvb, comp_offset, &len, &ind_field);
/* we can believe the length now */
next_tvb = tvb_new_subset(tvb, offset, len+comp_offset-offset, len+comp_offset-offset);

if (!next_tvb)
  return comp_offset;

%(DEFAULT_BODY)s

 dissect_tcap_ITU_ComponentPDU(implicit_tag, next_tvb, 0, actx, tcap_top_tree, hf_index);

/* return comp_offset+len; or return offset (will be automatically added */

#----------------------------------------------------------------------------------------
#.FN_BODY AUDT-apdu/_untag/application-context-name  FN_VARIANT = _str  VAL_PTR = &cur_oid
%(DEFAULT_BODY)s
	tcap_private.oid= (void*) cur_oid;
	tcap_private.acv=TRUE;
#----------------------------------------------------------------------------------------
#.FN_BODY AARQ-apdu/_untag/application-context-name  FN_VARIANT = _str  VAL_PTR = &cur_oid
%(DEFAULT_BODY)s
	tcap_private.oid= (void*) cur_oid;
	tcap_private.acv=TRUE;
#----------------------------------------------------------------------------------------
#.FN_BODY AARE-apdu/_untag/application-context-name  FN_VARIANT = _str  VAL_PTR = &cur_oid
%(DEFAULT_BODY)s
	tcap_private.oid= (void*) cur_oid;
	tcap_private.acv=TRUE;
#----------------------------------------------------------------------------------------
# Do not overwrite the ApplicationContext with the UserInfoOID !
#
#----------------------------------------------------------------------------------------
#.FN_BODY UserInfoOID  FN_VARIANT = _str  VAL_PTR = &tcapext_oid
%(DEFAULT_BODY)s

#----------------------------------------------------------------------------------------
#.FN_BODY ExternUserInfo
tvbuff_t	*next_tvb;
gint8 class;
gboolean pc;
gint tag;
guint32 len, comp_offset;
gint ind_field;

comp_offset = dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &class, &pc, &tag);
comp_offset = dissect_ber_length(actx->pinfo, tree, tvb, comp_offset, &len, &ind_field);
/* we can believe the length now */
next_tvb = tvb_new_subset(tvb, offset, len+comp_offset-offset, len+comp_offset-offset);

if (!next_tvb)
  return comp_offset;

%(DEFAULT_BODY)s

dissect_tcap_TheExternUserInfo(implicit_tag, next_tvb, 0, actx, tcap_top_tree, hf_index);

return comp_offset+len;

#----------------------------------------------------------------------------------------
#.FN_BODY ANSIParameters
/* we are doing the ParamSet here so need to look at the tags*/
	guint32 len;
len = tvb_length_remaining(tvb, offset);
if (len > 2)  /* arghhh I dont know whether this is constructed or not! */
		offset = dissect_tcap_param(actx,tree,tvb,offset);
else
offset = dissect_ber_octet_string(TRUE, actx, tree, tvb, 0, hf_index,
                                    NULL);

#----------------------------------------------------------------------------------------
#.FN_BODY ComponentPDU
tvbuff_t	*next_tvb;
gint8 class;
gboolean pc;
gint tag;
guint32 len, comp_offset;
gint ind_field;

comp_offset = dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &class, &pc, &tag);
comp_offset = dissect_ber_length(actx->pinfo, tree, tvb, comp_offset, &len, &ind_field);
/* we can believe the length now */
next_tvb = tvb_new_subset(tvb, offset, len+comp_offset-offset, len+comp_offset-offset);

if (!next_tvb)
  return offset;

%(DEFAULT_BODY)s

dissect_tcap_ANSI_ComponentPDU(implicit_tag, next_tvb, 0, actx, tcap_top_tree, hf_index);

#----------------------------------------------------------------------------------------
#.FN_BODY OrigTransactionID
tvbuff_t *parameter_tvb;
guint8 len, i;
proto_item *tid_item;
proto_tree *subtree;
tid_item = proto_tree_add_text(tree, tvb, offset, -1, "Source Transaction ID");
subtree = proto_item_add_subtree(tid_item, ett_otid);

offset = dissect_ber_octet_string(implicit_tag, actx, subtree, tvb, offset, hf_tcap_tid,
                                    &parameter_tvb);

if (parameter_tvb){
	len = tvb_length_remaining(parameter_tvb, 0);
	switch(len) {
	case 1:
		gp_tcapsrt_info->src_tid=tvb_get_guint8(parameter_tvb, 0);
		break;
	case 2:
		gp_tcapsrt_info->src_tid=tvb_get_ntohs(parameter_tvb, 0);
		break;
	case 4:
		gp_tcapsrt_info->src_tid=tvb_get_ntohl(parameter_tvb, 0);
		break;
	default:
		gp_tcapsrt_info->src_tid=0;
		break;
	}

	if ((len)&&(check_col(actx->pinfo->cinfo, COL_INFO))){
		col_append_str(actx->pinfo->cinfo, COL_INFO, "otid(");
	   	for(i=0;i<len;i++)
        		  col_append_fstr(actx->pinfo->cinfo, COL_INFO, "%%02x",tvb_get_guint8(parameter_tvb,i));
        	col_append_str(actx->pinfo->cinfo, COL_INFO, ") ");
	}

}


#----------------------------------------------------------------------------------------
#.FN_BODY DestTransactionID
tvbuff_t *parameter_tvb;
guint8 len , i;
proto_item *tid_item;
proto_tree *subtree;
tid_item = proto_tree_add_text(tree, tvb, offset, -1, "Destination Transaction ID");
subtree = proto_item_add_subtree(tid_item, ett_otid);

offset = dissect_ber_octet_string(implicit_tag, actx, subtree, tvb, offset, hf_tcap_tid,
                                    &parameter_tvb);

if (parameter_tvb){
	len = tvb_length_remaining(parameter_tvb, 0);
	switch(len) {
	case 1:
		gp_tcapsrt_info->dst_tid=tvb_get_guint8(parameter_tvb, 0);
		break;
	case 2:
		gp_tcapsrt_info->dst_tid=tvb_get_ntohs(parameter_tvb, 0);
		break;
	case 4:
		gp_tcapsrt_info->dst_tid=tvb_get_ntohl(parameter_tvb, 0);
		break;
	default:
		gp_tcapsrt_info->dst_tid=0;
		break;
	}

	if ((len)&&(check_col(actx->pinfo->cinfo, COL_INFO))){
		col_append_str(actx->pinfo->cinfo, COL_INFO, "dtid(");
		for(i=0;i<len;i++)
          		col_append_fstr(actx->pinfo->cinfo, COL_INFO, "%%02x",tvb_get_guint8(parameter_tvb,i));
        	col_append_str(actx->pinfo->cinfo, COL_INFO, ") ");
	   }
}
#.FN_HDR Begin
gp_tcapsrt_info->ope=TC_BEGIN;

/*  Do not change col_add_str() to col_append_str() here: we _want_ this call
 *  to overwrite whatever's currently in the INFO column (e.g., "UDT" from
 *  the SCCP dissector).
 *
 *  If there's something there that should not be overwritten, whoever
 *  put that info there should call col_set_fence() to protect it.
 */
if (check_col(actx->pinfo->cinfo, COL_INFO))
		col_set_str(actx->pinfo->cinfo, COL_INFO, "Begin ");
#.END


#.FN_HDR End
gp_tcapsrt_info->ope=TC_END;

if (check_col(actx->pinfo->cinfo, COL_INFO))
		col_set_str(actx->pinfo->cinfo, COL_INFO, "End ");
#.END


#.FN_HDR Continue
gp_tcapsrt_info->ope=TC_CONT;

if (check_col(actx->pinfo->cinfo, COL_INFO))
		col_set_str(actx->pinfo->cinfo, COL_INFO, "Continue ");
#.END


#.FN_HDR Abort
gp_tcapsrt_info->ope=TC_ABORT;

if (check_col(actx->pinfo->cinfo, COL_INFO))
		col_set_str(actx->pinfo->cinfo, COL_INFO, "Abort ");
#.END


#.FN_HDR AbortPDU
gp_tcapsrt_info->ope=TC_ANSI_ABORT;

if (check_col(actx->pinfo->cinfo, COL_INFO))
		col_set_str(actx->pinfo->cinfo, COL_INFO, "Abort ");
#.END


#.FN_HDR TCMessage/ansiqueryWithPerm
gp_tcapsrt_info->ope=TC_ANSI_ALL;
if (check_col(actx->pinfo->cinfo, COL_INFO))
				col_set_str(actx->pinfo->cinfo, COL_INFO, "QueryWithPerm ");
#.FN_HDR TCMessage/ansiqueryWithoutPerm
gp_tcapsrt_info->ope=TC_ANSI_ALL;
if (check_col(actx->pinfo->cinfo, COL_INFO))
				col_set_str(actx->pinfo->cinfo, COL_INFO, "QueryWithOutPerm ");
#.FN_HDR TCMessage/ansiresponse
gp_tcapsrt_info->ope=TC_ANSI_ALL;
if (check_col(actx->pinfo->cinfo, COL_INFO))
				col_set_str(actx->pinfo->cinfo, COL_INFO, "Response ");
#.FN_HDR TCMessage/ansiconversationWithPerm
gp_tcapsrt_info->ope=TC_ANSI_ALL;
if (check_col(actx->pinfo->cinfo, COL_INFO))
				col_set_str(actx->pinfo->cinfo, COL_INFO, "ConversationWithPerm ");
#.FN_HDR TCMessage/ansiconversationWithoutPerm
gp_tcapsrt_info->ope=TC_ANSI_ALL;
if (check_col(actx->pinfo->cinfo, COL_INFO))
				col_set_str(actx->pinfo->cinfo, COL_INFO, "ConversationWithoutPerm ");

#.END

#----------------------------------------------------------------------------------------
#.FN_BODY TransactionID/_untag VAL_PTR = &next_tvb

tvbuff_t *next_tvb;
guint8 len;

%(DEFAULT_BODY)s

if(next_tvb) {
	tcap_private.TransactionID_str = tvb_bytes_to_str(next_tvb, 0,tvb_length(next_tvb));
	len = tvb_length_remaining(next_tvb, 0);
	switch(len) {
	case 1:
		gp_tcapsrt_info->src_tid=tvb_get_guint8(next_tvb, 0);
		break;
	case 2:
		gp_tcapsrt_info->src_tid=tvb_get_ntohs(next_tvb, 0);
		break;
	case 4:
		gp_tcapsrt_info->src_tid=tvb_get_ntohl(next_tvb, 0);
		break;
	default:
		gp_tcapsrt_info->src_tid=0;
		break;
	}
}

#.END
