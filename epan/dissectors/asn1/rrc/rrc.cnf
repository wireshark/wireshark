# rrc.cnf
# rrc conformation file
# Copyright 2006 Anders Broman

#.OPT
PER
UNALIGNED
PROTO_ROOT_NAME    proto_rrc
#.END

#.USE_VALS_EXT
AverageRLC-BufferPayload
DL-DCCH-MessageType
DL-TS-ChannelisationCode-VHCR
EstablishmentCause
E-DCH-MAC-d-FlowRetransTimer
HARQMemorySize
CommonEDCHSystemInfo/modeSpecificInfo/tdd/tdd128/ccch-transmission-Info/harq-retransmission-timer
MBMS-AccessProbabilityFactor
PNBSCH-Allocation-r4/numberOfRepetitionsPerSFNPeriod
RadioFrequencyBandFDD3
E-PUCH-Info/modeSpecificInfo/tdd128/retransTimerForSchedInfo
E-PUCH-Info-TDD128/retransTimerForSchedInfo
ReceivedMessageType
RLC-BuffersPayload
SCCPCH-ChannelisationCode-VHCR
SFN-SFN-Drift
SIBSb-TypeAndTag
SIB-Type
SIB-TypeAndTag
SIB-TypeAndTag2
TDD768-PICH-CCode
TDD-PRACH-CCode-LCR-r4
TimerPoll
TimerPollProhibit
TimerStatusProhibit
TrafficVolumeThreshold
U-RNTI-Group
UL-DCCH-MessageType
UL-TS-ChannelisationCode
UL-TS-ChannelisationCode-VHCR
MinimumTEBS-threshold
UE-DTX-Cycle2-2ms-Secondary
SIB-Type2
WLANThreshBackhaulRate

#.EXPORTS
InterRATHandoverInfo
InterRATHandoverInfo_PDU
ToTargetRNC-Container_PDU
TargetRNC-ToSourceRNC-Container_PDU
HandoverToUTRANCommand_PDU
SysInfoType1_PDU
SysInfoType2_PDU
SysInfoType3_PDU
SysInfoType4_PDU
SysInfoType5_PDU
SysInfoType6_PDU
SysInfoType7_PDU
SysInfoType11_PDU
SysInfoType12_PDU
SysInfoType13_PDU
SysInfoType13-1_PDU
SysInfoType13-2_PDU
SysInfoType13-3_PDU
SysInfoType13-4_PDU
SysInfoType14_PDU
SysInfoType15_PDU
SysInfoType15-1_PDU
SysInfoType15-2_PDU
SysInfoType15-3_PDU
SysInfoType15-4_PDU
SysInfoType16_PDU
SysInfoType17_PDU
SysInfoType18_PDU
SysInfoType19_PDU
SysInfoTypeSB1_PDU
SysInfoTypeSB2_PDU
MasterInformationBlock_PDU
MeasurementReport_PDU

#.OMIT_ASSIGNMENT
# Omit System-Information-Container for now it messes up the
# MasterInformationBlock       @si.mib
# :
# for some reason
UE-RadioAccessCapability-v890ext
UE-RadioAccessCapability-va60ext
UL-PhysChCapabilityFDD-r6
GSMCellGroupingList
UE-Positioning-GANSS-Data
GANSSDecipheringKeys
GSM-CellID
RRCConnectionRelease-CCCH-va40ext-IEs
MeasuredResultsList-vd20ext
#.END

#.PDU

DL-DCCH-Message              @dl.dcch
UL-DCCH-Message              @ul.dcch
DL-CCCH-Message              @dl.ccch
UL-CCCH-Message              @ul.ccch
PCCH-Message                 @pcch
DL-SHCCH-Message             @dl.shcch
UL-SHCCH-Message             @ul.shcch
BCCH-FACH-Message            @bcch.fach
BCCH-BCH-Message             @bcch.bch
BCCH-BCH2-Message            @bcch.bch2
MCCH-Message                 @mcch
MSCH-Message                 @msch
SystemInformation-BCH        @sysinfo
SystemInformation2-BCH       @sysinfo2
System-Information-Container @sysinfo.cont
MasterInformationBlock       @si.mib
MeasurementReport
SysInfoType1                 @si.sib1
SysInfoType2                 @si.sib2
SysInfoType3                 @si.sib3
SysInfoType4                 @si.sib4
SysInfoType5                 @si.sib5
SysInfoType5bis              @si.sib5bis
SysInfoType6                 @si.sib6
SysInfoType7                 @si.sib7
SysInfoType8                 @si.sib8
SysInfoType9                 @si.sib9
SysInfoType10                @si.sib10
SysInfoType11                @si.sib11
SysInfoType11bis             @si.sib11bis
SysInfoType11ter             @si.sib11ter
SysInfoType12                @si.sib12
SysInfoType13                @si.sib13
SysInfoType13-1              @si.sib13-1
SysInfoType13-2              @si.sib13-2
SysInfoType13-3              @si.sib13-3
SysInfoType13-4              @si.sib13-4
SysInfoType14                @si.sib14
SysInfoType15                @si.sib15
SysInfoType15bis             @si.sib15bis
SysInfoType15-1              @si.sib15-1
SysInfoType15-1bis           @si.sib15-1bis
SysInfoType15-1ter           @si.sib15-1ter
SysInfoType15-2              @si.sib15-2
SysInfoType15-2bis           @si.sib15-2bis
SysInfoType15-2ter           @si.sib15-2ter
SysInfoType15-3              @si.sib15-3
SysInfoType15-3bis           @si.sib15-3bis
SysInfoType15-4              @si.sib15-4
SysInfoType15-5              @si.sib15-5
SysInfoType15-6              @si.sib15-6
SysInfoType15-7              @si.sib15-7
SysInfoType15-8              @si.sib15-8
SysInfoType16                @si.sib16
SysInfoType17                @si.sib17
SysInfoType18                @si.sib18
SysInfoType19                @si.sib19
SysInfoType20                @si.sib20
SysInfoType21                @si.sib21
SysInfoType22                @si.sib22
SysInfoType23                @si.sib23
SysInfoType24                @si.sib24
SysInfoType25                @si.sib25
SysInfoTypeSB1               @si.sb1
SysInfoTypeSB2               @si.sb2
SysInfoTypeSB3               @si.sb3
HandoverToUTRANCommand       @irat.ho_to_utran_cmd
InterRATHandoverInfo         @irat.irat_ho_info
UE-RadioAccessCapabilityInfo @ue_radio_access_cap_info
ToTargetRNC-Container        @s_to_trnc_cont
TargetRNC-ToSourceRNC-Container @t_to_srnc_cont

#.FIELD_RENAME
HandoverFromUTRANCommand-GSM-r3-IEs/gsm-message/gsm-MessageList gsm-MessageList-r3
HandoverFromUTRANCommand-GSM-r6-IEs/gsm-message/gsm-MessageList gsm-MessageList-r6
HandoverFromUTRANFailure/interRATMessage/gsm/gsm-MessageList gsm-MessageList-gsm

HandoverFromUTRANCommand-GSM-r3-IEs/gsm-message/single-GSM-Message single-GSM-Message-r3
HandoverFromUTRANCommand-GSM-r6-IEs/gsm-message/single-GSM-Message single-GSM-Message-r6

#.END

#.FN_BODY NAS-Message VAL_PTR = &nas_message_tvb
  tvbuff_t *nas_message_tvb=NULL;

%(DEFAULT_BODY)s

    if (nas_message_tvb && gsm_a_dtap_handle) {
      proto_tree *nas_tree = rrc_nas_in_root_tree ? proto_tree_get_root(tree) : tree;
      call_dissector(gsm_a_dtap_handle,nas_message_tvb,%(ACTX)s->pinfo, nas_tree);
    }

#.FN_BODY InterRATHandoverInfo/ue-CapabilityContainer/present VAL_PTR = &ue_radio_access_cap_info_tvb
  tvbuff_t *ue_radio_access_cap_info_tvb=NULL;

%(DEFAULT_BODY)s

  if (ue_radio_access_cap_info_tvb)
    call_dissector(rrc_ue_radio_access_cap_info_handle,ue_radio_access_cap_info_tvb,%(ACTX)s->pinfo, tree);

#.END

#.FN_BODY ActiveSetUpdate
  col_append_str(actx->pinfo->cinfo, COL_INFO, "ActiveSetUpdate");
%(DEFAULT_BODY)s

#.FN_BODY ActiveSetUpdateComplete
  col_append_str(actx->pinfo->cinfo, COL_INFO, "ActiveSetUpdateComplete");
%(DEFAULT_BODY)s

#.FN_BODY ActiveSetUpdateFailure
  col_append_str(actx->pinfo->cinfo, COL_INFO, "ActiveSetUpdateFailure");
%(DEFAULT_BODY)s

#.FN_BODY AssistanceDataDelivery
  col_append_str(actx->pinfo->cinfo, COL_INFO, "AssistanceDataDelivery");
%(DEFAULT_BODY)s

#.FN_BODY CellChangeOrderFromUTRAN
  col_append_str(actx->pinfo->cinfo, COL_INFO, "CellChangeOrderFromUTRAN");
%(DEFAULT_BODY)s

#.FN_BODY CellChangeOrderFromUTRANFailure
  col_append_str(actx->pinfo->cinfo, COL_INFO, "CellChangeOrderFromUTRANFailure");
%(DEFAULT_BODY)s

#.FN_BODY CellUpdate
  col_append_str(actx->pinfo->cinfo, COL_INFO, "CellUpdate");
%(DEFAULT_BODY)s

#.FN_BODY CellUpdateFDD-r11
  col_append_str(actx->pinfo->cinfo, COL_INFO, "CellUpdateFDD-r11");
%(DEFAULT_BODY)s

#.FN_BODY CellUpdateConfirm-CCCH
  fp_info  *fpinf = NULL;
  rlc_info *rlcinf = NULL;
  guint32 u_rnti;
  col_append_str(actx->pinfo->cinfo, COL_INFO, "CellUpdateConfirm-CCCH");
%(DEFAULT_BODY)s
  if(PINFO_FD_VISITED(actx->pinfo)) {
    return offset;
  }

  fpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_fp, 0);
  rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_umts_rlc, 0);

  /*If FP info or RLC info is missing , skip all this*/
  if(fpinf == NULL || rlcinf == NULL){
      return offset;
  }

  /* If UE is moving to CELL_DCH we need to map it's U-RNTI to the new CRNC context in NBAP */
  if (private_data_get_rrc_state_indicator(actx) == RRC_UE_STATE_CELL_DCH) {
    u_rnti = private_data_get_current_u_rnti(actx);
    rrc_try_map_urnti_to_crncc(u_rnti, actx);
  }

#.FN_BODY CellUpdateConfirm
  fp_info  *fpinf = NULL;
  rlc_info *rlcinf = NULL;
  guint32 u_rnti;
  col_append_str(actx->pinfo->cinfo, COL_INFO, "CellUpdateConfirm");
%(DEFAULT_BODY)s
  if(PINFO_FD_VISITED(actx->pinfo)) {
    return offset;
  }

  fpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_fp, 0);
  rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_umts_rlc, 0);

  /*If FP info or RLC info is missing , skip all this*/
  if(fpinf == NULL || rlcinf == NULL){
      return offset;
  }

  /* If UE is moving to CELL_DCH we need to map it's U-RNTI to the new CRNC context in NBAP */
  if (private_data_get_rrc_state_indicator(actx) == RRC_UE_STATE_CELL_DCH) {
    u_rnti = rlcinf->ueid[fpinf->cur_tb]; /* Hopefully a U-RNTI, might be C-RNTI */
    rrc_try_map_urnti_to_crncc(u_rnti, actx);
  }

#.FN_BODY CounterCheck
  col_append_str(actx->pinfo->cinfo, COL_INFO, "CounterCheck");
%(DEFAULT_BODY)s

#.FN_BODY CounterCheckResponse
  col_append_str(actx->pinfo->cinfo, COL_INFO, "CounterCheckResponse");
%(DEFAULT_BODY)s

#.FN_BODY DownlinkDirectTransfer
  col_append_str(actx->pinfo->cinfo, COL_INFO, "DownlinkDirectTransfer");
%(DEFAULT_BODY)s

#.FN_BODY ETWSPrimaryNotificationWithSecurity
  col_append_str(actx->pinfo->cinfo, COL_INFO, "ETWSPrimaryNotificationWithSecurity");
%(DEFAULT_BODY)s

#.FN_BODY HandoverToUTRANComplete
  col_append_str(actx->pinfo->cinfo, COL_INFO, "HandoverToUTRANComplete");
%(DEFAULT_BODY)s

#.FN_BODY InitialDirectTransfer
  col_append_str(actx->pinfo->cinfo, COL_INFO, "InitialDirectTransfer");
%(DEFAULT_BODY)s

#.FN_BODY HandoverFromUTRANCommand-EUTRA
  col_append_str(actx->pinfo->cinfo, COL_INFO, "HandoverFromUTRANCommand-EUTRA");
%(DEFAULT_BODY)s

#.FN_BODY HandoverFromUTRANCommand-GERANIu
  col_append_str(actx->pinfo->cinfo, COL_INFO, "HandoverFromUTRANCommand-GERANIu");
%(DEFAULT_BODY)s

#.FN_BODY HandoverFromUTRANCommand-GSM
  col_append_str(actx->pinfo->cinfo, COL_INFO, "HandoverFromUTRANCommand-GSM");
%(DEFAULT_BODY)s

#.FN_BODY HandoverFromUTRANCommand-CDMA2000
  col_append_str(actx->pinfo->cinfo, COL_INFO, "HandoverFromUTRANCommand-CDMA2000");
%(DEFAULT_BODY)s

#.FN_BODY HandoverFromUTRANFailure
  col_append_str(actx->pinfo->cinfo, COL_INFO, "HandoverFromUTRANFailure");
%(DEFAULT_BODY)s

#.FN_BODY LoggingMeasurementConfiguration
  col_append_str(actx->pinfo->cinfo, COL_INFO, "LoggingMeasurementConfiguration");
%(DEFAULT_BODY)s

#.FN_BODY MBMSAccessInformation
  col_append_str(actx->pinfo->cinfo, COL_INFO, "MBMSAccessInformation");
%(DEFAULT_BODY)s

#.FN_BODY MBMSCommonPTMRBInformation
  col_append_str(actx->pinfo->cinfo, COL_INFO, "MBMSCommonPTMRBInformation");
%(DEFAULT_BODY)s

#.FN_BODY MBMSCurrentCellPTMRBInformation
  col_append_str(actx->pinfo->cinfo, COL_INFO, "MBMSCurrentCellPTMRBInformation");
%(DEFAULT_BODY)s

#.FN_BODY MBMSGeneralInformation
  col_append_str(actx->pinfo->cinfo, COL_INFO, "MBMSGeneralInformation");
%(DEFAULT_BODY)s

#.FN_BODY MBMSModificationRequest
  col_append_str(actx->pinfo->cinfo, COL_INFO, "MBMSModificationRequest");
%(DEFAULT_BODY)s

#.FN_BODY MBMSModifiedServicesInformation
  col_append_str(actx->pinfo->cinfo, COL_INFO, "MBMSModifiedServicesInformation");
%(DEFAULT_BODY)s

#.FN_BODY MBMSNeighbouringCellPTMRBInformation
  col_append_str(actx->pinfo->cinfo, COL_INFO, "MBMSNeighbouringCellPTMRBInformation");
%(DEFAULT_BODY)s

#.FN_BODY MBMSSchedulingInformation
  col_append_str(actx->pinfo->cinfo, COL_INFO, "MBMSSchedulingInformation");
%(DEFAULT_BODY)s

#.FN_BODY MBMSUnmodifiedServicesInformation
  col_append_str(actx->pinfo->cinfo, COL_INFO, "MBMSUnmodifiedServicesInformation");
%(DEFAULT_BODY)s

#.FN_BODY MeasurementControl
  col_append_str(actx->pinfo->cinfo, COL_INFO, "MeasurementControl");
%(DEFAULT_BODY)s

#.FN_BODY MeasurementControlFailure
  col_append_str(actx->pinfo->cinfo, COL_INFO, "MeasurementControlFailure");
%(DEFAULT_BODY)s

#.FN_BODY MeasurementReport
  col_append_str(actx->pinfo->cinfo, COL_INFO, "MeasurementReport");
%(DEFAULT_BODY)s

#.FN_BODY PagingType1
  col_append_str(actx->pinfo->cinfo, COL_INFO, "PagingType1");
%(DEFAULT_BODY)s

#.FN_BODY PagingType2
  col_append_str(actx->pinfo->cinfo, COL_INFO, "PagingType2");
%(DEFAULT_BODY)s

#.FN_BODY PhysicalChannelReconfiguration
  fp_info  *fpinf = NULL;
  rlc_info *rlcinf = NULL;
  guint32 u_rnti;
  col_append_str(actx->pinfo->cinfo, COL_INFO, "PhysicalChannelReconfiguration");
%(DEFAULT_BODY)s
  if(PINFO_FD_VISITED(actx->pinfo)) {
    return offset;
  }

  fpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_fp, 0);
  rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_umts_rlc, 0);

  /*If FP info or RLC info is missing , skip all this*/
  if(fpinf == NULL || rlcinf == NULL){
      return offset;
  }

  /* If we receive this message on FACH and UE is moving to CELL_DCH */
  /* we need to map it's U-RNTI to the new CRNC context in NBAP */
  if (fpinf->channel == CHANNEL_FACH_FDD && private_data_get_rrc_state_indicator(actx) == RRC_UE_STATE_CELL_DCH) {
    u_rnti = rlcinf->ueid[fpinf->cur_tb]; /* Hopefully a U-RNTI, might be C-RNTI */
    rrc_try_map_urnti_to_crncc(u_rnti, actx);
  }

#.FN_BODY PhysicalChannelReconfigurationComplete
  col_append_str(actx->pinfo->cinfo, COL_INFO, "PhysicalChannelReconfigurationComplete");
%(DEFAULT_BODY)s

#.FN_BODY PhysicalChannelReconfigurationFailure
  col_append_str(actx->pinfo->cinfo, COL_INFO, "PhysicalChannelReconfigurationFailure");
%(DEFAULT_BODY)s

#.FN_BODY PhysicalSharedChannelAllocation
  col_append_str(actx->pinfo->cinfo, COL_INFO, "PhysicalSharedChannelAllocation");
%(DEFAULT_BODY)s

#.FN_BODY PUSCHCapacityRequest
  col_append_str(actx->pinfo->cinfo, COL_INFO, "PUSCHCapacityRequest");
%(DEFAULT_BODY)s

#.FN_BODY RadioBearerReconfiguration
  fp_info  *fpinf = NULL;
  rlc_info *rlcinf = NULL;
  guint32 u_rnti;
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RadioBearerReconfiguration");
%(DEFAULT_BODY)s
  if(PINFO_FD_VISITED(actx->pinfo)) {
    return offset;
  }

  fpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_fp, 0);
  rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_umts_rlc, 0);

  /*If FP info or RLC info is missing , skip all this*/
  if(fpinf == NULL || rlcinf == NULL){
      return offset;
  }

  /* If we receive this message on FACH and UE is moving to CELL_DCH */
  /* we need to map it's U-RNTI to the new CRNC context in NBAP */
  if (fpinf->channel == CHANNEL_FACH_FDD && private_data_get_rrc_state_indicator(actx) == RRC_UE_STATE_CELL_DCH) {
    u_rnti = rlcinf->ueid[fpinf->cur_tb]; /* Hopefully a U-RNTI, might be C-RNTI */
    rrc_try_map_urnti_to_crncc(u_rnti, actx);
  }

#.FN_BODY RadioBearerReconfigurationComplete
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RadioBearerReconfigurationComplete");
%(DEFAULT_BODY)s

#.FN_BODY RadioBearerReconfigurationFailure
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RadioBearerReconfigurationFailure");
%(DEFAULT_BODY)s

#.FN_BODY RadioBearerRelease
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RadioBearerRelease");
%(DEFAULT_BODY)s

#.FN_BODY RadioBearerReleaseComplete
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RadioBearerReleaseComplete");
%(DEFAULT_BODY)s

#.FN_BODY RadioBearerReleaseFailure
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RadioBearerReleaseFailure");
%(DEFAULT_BODY)s

#.FN_BODY RadioBearerSetup
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RadioBearerSetup");
%(DEFAULT_BODY)s

#.FN_BODY RadioBearerSetupComplete
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RadioBearerSetupComplete");
%(DEFAULT_BODY)s

#.FN_BODY RadioBearerSetupFailure
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RadioBearerSetupFailure");
%(DEFAULT_BODY)s

#.FN_BODY RRCConnectionReject
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RRCConnectionReject");
%(DEFAULT_BODY)s

#.FN_BODY RRCConnectionRelease
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RRCConnectionRelease");
%(DEFAULT_BODY)s

#.FN_BODY RRCConnectionRelease-CCCH
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RRCConnectionRelease-CCCH");
%(DEFAULT_BODY)s

#.FN_BODY RRCConnectionReleaseComplete
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RRCConnectionReleaseComplete");
%(DEFAULT_BODY)s

#.FN_BODY RRCConnectionRequest
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RRCConnectionRequest");
%(DEFAULT_BODY)s

#.FN_BODY RRCConnectionSetup
  guint32 new_u_rnti;
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RRCConnectionSetup");
%(DEFAULT_BODY)s
  if (PINFO_FD_VISITED(actx->pinfo)) {
    return offset;
  }

  /* Trying to map the U-RNTI assigned to the user to CRNC Context from NBAP*/
  new_u_rnti = private_data_get_new_u_rnti(actx);
  rrc_try_map_urnti_to_crncc(new_u_rnti, actx);

#.FN_BODY RRCConnectionSetupComplete
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RRCConnectionSetupComplete");
%(DEFAULT_BODY)s

#.FN_BODY RRCStatus
  col_append_str(actx->pinfo->cinfo, COL_INFO, "RRCStatus");
%(DEFAULT_BODY)s

#.FN_BODY SecurityModeCommand
  fp_info            *fpinf;
  rlc_info           *rlcinf;
  rrc_ciphering_info *ciphering_info = NULL;
  guint8              direction;
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SecurityModeCommand");

  fpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_fp, 0);
  rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_umts_rlc, 0);

  /*If FP info or RLC info is missing , skip all this*/
  if(fpinf != NULL && rlcinf != NULL){
    ciphering_info = get_or_create_cipher_info(fpinf, rlcinf);
    private_data_set_ciphering_info(actx, ciphering_info);
  }
%(DEFAULT_BODY)s
  if( ciphering_info != NULL ){
    direction = P2P_DIR_DL; /* Security Mode Command is from the RNC, direction is always downlink */
    ciphering_info->setup_frame[direction] = actx->pinfo->num;
  }

#.FN_BODY SecurityModeComplete
  fp_info            *fpinf;
  rlc_info           *rlcinf;
  rrc_ciphering_info *ciphering_info = NULL;
  guint8              direction;
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SecurityModeComplete");

  fpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_fp, 0);
  rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_umts_rlc, 0);

  /*If FP info or RLC info is missing , skip all this*/
  if(fpinf != NULL || rlcinf != NULL){
    ciphering_info = get_or_create_cipher_info(fpinf, rlcinf);
    private_data_set_ciphering_info(actx, ciphering_info);
  }

%(DEFAULT_BODY)s
  if( ciphering_info != NULL ){
    direction = P2P_DIR_UL; /* Security Mode Complete is from the UE, direction is always uplink */
    ciphering_info->setup_frame[direction] = actx->pinfo->num;
  }


#.FN_BODY SecurityModeFailure
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SecurityModeFailure");
%(DEFAULT_BODY)s

#.FN_BODY SignallingConnectionRelease
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SignallingConnectionRelease");
%(DEFAULT_BODY)s

#.FN_BODY SignallingConnectionReleaseIndication
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SignallingConnectionReleaseIndication");
%(DEFAULT_BODY)s

#.FN_BODY SystemInformation-BCH
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SystemInformation-BCH");
%(DEFAULT_BODY)s

#.FN_BODY SystemInformation-FACH
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SystemInformation-FACH");
%(DEFAULT_BODY)s

#.FN_BODY SystemInformationChangeIndication
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SystemInformationChangeIndication");
%(DEFAULT_BODY)s

#.FN_BODY TransportChannelReconfiguration
  fp_info  *fpinf = NULL;
  rlc_info *rlcinf = NULL;
  guint32 u_rnti;
  col_append_str(actx->pinfo->cinfo, COL_INFO, "TransportChannelReconfiguration");
%(DEFAULT_BODY)s
  if(PINFO_FD_VISITED(actx->pinfo)) {
    return offset;
  }

  fpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_fp, 0);
  rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_umts_rlc, 0);

  /*If FP info or RLC info is missing , skip all this*/
  if(fpinf == NULL || rlcinf == NULL){
      return offset;
  }

  /* If we receive this message on FACH and UE is moving to CELL_DCH */
  /* we need to map it's U-RNTI to the new CRNC context in NBAP */
  if (fpinf->channel == CHANNEL_FACH_FDD && private_data_get_rrc_state_indicator(actx) == RRC_UE_STATE_CELL_DCH) {
    u_rnti = rlcinf->ueid[fpinf->cur_tb]; /* Hopefully a U-RNTI, might be C-RNTI */
    rrc_try_map_urnti_to_crncc(u_rnti, actx);
  }

#.FN_BODY TransportChannelReconfigurationComplete
  col_append_str(actx->pinfo->cinfo, COL_INFO, "TransportChannelReconfigurationComplete");
%(DEFAULT_BODY)s

#.FN_BODY TransportChannelReconfigurationFailure
  col_append_str(actx->pinfo->cinfo, COL_INFO, "TransportChannelReconfigurationFailure");
%(DEFAULT_BODY)s

#.FN_BODY TransportFormatCombinationControl
  col_append_str(actx->pinfo->cinfo, COL_INFO, "TransportFormatCombinationControl");
%(DEFAULT_BODY)s

#.FN_BODY TransportFormatCombinationControlFailure
  col_append_str(actx->pinfo->cinfo, COL_INFO, "TransportFormatCombinationControlFailure");
%(DEFAULT_BODY)s

#.FN_BODY UECapabilityEnquiry
  col_append_str(actx->pinfo->cinfo, COL_INFO, "UECapabilityEnquiry");
%(DEFAULT_BODY)s

#.FN_BODY UECapabilityInformation
  col_append_str(actx->pinfo->cinfo, COL_INFO, "UECapabilityInformation");
%(DEFAULT_BODY)s

#.FN_BODY UECapabilityInformationConfirm
  col_append_str(actx->pinfo->cinfo, COL_INFO, "UECapabilityInformationConfirm");
%(DEFAULT_BODY)s

#.FN_BODY UEInformationRequest
  col_append_str(actx->pinfo->cinfo, COL_INFO, "UEInformationRequest");
%(DEFAULT_BODY)s

#.FN_BODY UEInformationResponse
  col_append_str(actx->pinfo->cinfo, COL_INFO, "UEInformationResponse");
%(DEFAULT_BODY)s

#.FN_BODY UplinkDirectTransfer
  col_append_str(actx->pinfo->cinfo, COL_INFO, "UplinkDirectTransfer");
%(DEFAULT_BODY)s

#.FN_BODY UplinkPhysicalChannelControl
  col_append_str(actx->pinfo->cinfo, COL_INFO, "UplinkPhysicalChannelControl");
%(DEFAULT_BODY)s

#.FN_BODY URAUpdate
  col_append_str(actx->pinfo->cinfo, COL_INFO, "URAUpdate");
%(DEFAULT_BODY)s

#.FN_BODY URAUpdateConfirm
  col_append_str(actx->pinfo->cinfo, COL_INFO, "URAUpdateConfirm");
%(DEFAULT_BODY)s

#.FN_BODY URAUpdateConfirm-CCCH
  col_append_str(actx->pinfo->cinfo, COL_INFO, "URAUpdateConfirm-CCCH");
%(DEFAULT_BODY)s

#.FN_BODY UTRANMobilityInformation
  col_append_str(actx->pinfo->cinfo, COL_INFO, "UTRANMobilityInformation");
%(DEFAULT_BODY)s

#.FN_BODY UTRANMobilityInformationConfirm
  col_append_str(actx->pinfo->cinfo, COL_INFO, "UTRANMobilityInformationConfirm");
%(DEFAULT_BODY)s

#.FN_BODY UTRANMobilityInformationFailure
  col_append_str(actx->pinfo->cinfo, COL_INFO, "UTRANMobilityInformationFailure");
%(DEFAULT_BODY)s

#.FN_BODY TargetRNC-ToSourceRNC-Container/dL-DCCHmessage VAL_PTR = &dl_dcch_message_tvb
  tvbuff_t *dl_dcch_message_tvb=NULL;

%(DEFAULT_BODY)s

  if (dl_dcch_message_tvb)
    call_dissector(rrc_dl_dcch_handle,dl_dcch_message_tvb,%(ACTX)s->pinfo, proto_tree_get_root(tree));

#.FN_BODY GSM-MessageList/_item VAL_PTR = &gsm_messagelist_tvb
  tvbuff_t *gsm_messagelist_tvb=NULL;

%(DEFAULT_BODY)s

  if (gsm_messagelist_tvb && gsm_a_dtap_handle)
    call_dissector(gsm_a_dtap_handle,gsm_messagelist_tvb,actx->pinfo, tree);

#.FN_BODY HandoverFromUTRANCommand-GSM-r3-IEs/gsm-message/single-GSM-Message single-GSM-Message-r3
  tvbuff_t *gsm_message_tvb=NULL;
  guint bits_remaining, whole_octets_remaining;

%(DEFAULT_BODY)s

  bits_remaining = 8*tvb_reported_length(tvb) - offset;
  whole_octets_remaining = bits_remaining / 8;

  gsm_message_tvb = tvb_new_octet_aligned(tvb, offset, 8*whole_octets_remaining);

  if (gsm_message_tvb) {
    add_new_data_source(actx->pinfo,gsm_message_tvb,"GSM Message(aligned)");
    call_dissector(gsm_a_dtap_handle,gsm_message_tvb,actx->pinfo, tree);
  }
#.FN_BODY HandoverFromUTRANCommand-GSM-r6-IEs/gsm-message/single-GSM-Message single-GSM-Message-r6
  tvbuff_t *gsm_message_tvb=NULL;
  guint bits_remaining, whole_octets_remaining;

%(DEFAULT_BODY)s

  bits_remaining = 8*tvb_reported_length(tvb) - offset;
  whole_octets_remaining = bits_remaining / 8;

  gsm_message_tvb = tvb_new_octet_aligned(tvb, offset, 8*whole_octets_remaining);

  if (gsm_message_tvb && gsm_a_dtap_handle) {
    add_new_data_source(actx->pinfo,gsm_message_tvb,"GSM Message(aligned)");
    call_dissector(gsm_a_dtap_handle,gsm_message_tvb,actx->pinfo, tree);
  }

#.FN_BODY GERAN-SystemInfoBlock VAL_PTR = &parameter_tvb
  tvbuff_t *parameter_tvb=NULL;

%(DEFAULT_BODY)s
  if (parameter_tvb){
    guint8 byte = tvb_get_guint8(parameter_tvb, 0);
    if (byte == 0x06) {
      if (gsm_a_dtap_handle) {
        call_dissector(gsm_a_dtap_handle, parameter_tvb, actx->pinfo, tree);
      }
    } else {
      if (gsm_rlcmac_dl_handle) {
        call_dissector(gsm_rlcmac_dl_handle, parameter_tvb, actx->pinfo, tree);
      }
    }
  }

#.FN_BODY GSM-Classmark2 VAL_PTR = &parameter_tvb
  tvbuff_t *parameter_tvb=NULL;

%(DEFAULT_BODY)s
  if (parameter_tvb){
    de_ms_cm_2(parameter_tvb, tree, actx->pinfo, 2, tvb_get_guint8(parameter_tvb,1), NULL, 0);
  }

#.FN_BODY GSM-Classmark3 VAL_PTR = &parameter_tvb
  tvbuff_t *parameter_tvb=NULL;

%(DEFAULT_BODY)s
  if (parameter_tvb){
    de_ms_cm_3(parameter_tvb, tree, actx->pinfo, 0, tvb_reported_length(parameter_tvb), NULL, 0);
  }

#.FN_BODY GSM-MS-RadioAccessCapability VAL_PTR = &parameter_tvb
  tvbuff_t *parameter_tvb=NULL;

%(DEFAULT_BODY)s
  if (parameter_tvb){
    de_gmm_ms_radio_acc_cap(parameter_tvb, tree, actx->pinfo, 0, tvb_reported_length(parameter_tvb), NULL, 0);
  }

#.FN_BODY InterRATHandoverInfoWithInterRATCapabilities-r3-IEs/interRATHandoverInfo VAL_PTR = &parameter_tvb
  tvbuff_t *parameter_tvb=NULL;

%(DEFAULT_BODY)s
  if (parameter_tvb){
    dissect_rrc_InterRATHandoverInfo_PDU(parameter_tvb, actx->pinfo, tree, NULL);
  }

#.FN_BODY EUTRA-RadioAccessCapability/ue-EUTRA-Capability VAL_PTR = &ue_eutra_cap_tvb
  tvbuff_t *ue_eutra_cap_tvb = NULL;
%(DEFAULT_BODY)s
  if (ue_eutra_cap_tvb && lte_rrc_ue_eutra_cap_handle)
    call_dissector(lte_rrc_ue_eutra_cap_handle, ue_eutra_cap_tvb, actx->pinfo, tree);

#.FN_BODY HandoverFromUTRANCommand-EUTRA-r8-IEs/eutra-Message VAL_PTR = &eutra_message_tvb
  tvbuff_t *eutra_message_tvb = NULL;
%(DEFAULT_BODY)s
  if (eutra_message_tvb && lte_rrc_dl_dcch_handle)
    call_dissector(lte_rrc_dl_dcch_handle, eutra_message_tvb, actx->pinfo, tree);

#.FN_BODY HandoverFromUTRANCommand-EUTRA-r11-IEs/eutra-Message VAL_PTR = &eutra_message_tvb
  tvbuff_t *eutra_message_tvb = NULL;
%(DEFAULT_BODY)s
  if (eutra_message_tvb && lte_rrc_dl_dcch_handle)
    call_dissector(lte_rrc_dl_dcch_handle, eutra_message_tvb, actx->pinfo, tree);

#.FN_BODY HandoverFromUtranFailure-v860ext-IEs/eutra-Message VAL_PTR = &eutra_message_tvb
  tvbuff_t *eutra_message_tvb = NULL;
%(DEFAULT_BODY)s
  if (eutra_message_tvb && lte_rrc_dl_dcch_handle)
    call_dissector(lte_rrc_dl_dcch_handle, eutra_message_tvb, actx->pinfo, tree);

#.FN_BODY MultiModeRAT-Capability-v860ext/eutraFeatureGroupIndicators VAL_PTR = &eutraFeatureGroupIndicators_tvb
  tvbuff_t *eutraFeatureGroupIndicators_tvb=NULL;
%(DEFAULT_BODY)s
  if(eutraFeatureGroupIndicators_tvb){
    /* Dissect eutraFeatureGroupIndicators */
    proto_tree *subtree;
    gint curr_bit_offset = 0;
    subtree = proto_item_add_subtree(actx->created_item, ett_rrc_eutraFeatureGroupIndicators);
    proto_tree_add_bits_item(subtree, hf_rrc_eutra_feat_group_ind_1, eutraFeatureGroupIndicators_tvb, curr_bit_offset, 1, ENC_BIG_ENDIAN);
    curr_bit_offset++;
    proto_tree_add_bits_item(subtree, hf_rrc_eutra_feat_group_ind_2, eutraFeatureGroupIndicators_tvb, curr_bit_offset, 1, ENC_BIG_ENDIAN);
    curr_bit_offset++;
    proto_tree_add_bits_item(subtree, hf_rrc_eutra_feat_group_ind_3, eutraFeatureGroupIndicators_tvb, curr_bit_offset, 1, ENC_BIG_ENDIAN);
    curr_bit_offset++;
    proto_tree_add_bits_item(subtree, hf_rrc_eutra_feat_group_ind_4, eutraFeatureGroupIndicators_tvb, curr_bit_offset, 1, ENC_BIG_ENDIAN);
}

#.FN_BODY PLMN-Identity
  wmem_strbuf_t* mcc_mnc_strbuf;
  wmem_strbuf_t* mcc_strbuf;
  guint32 string_len;
  gchar* mcc_mnc_string;
  tvbuff_t* mcc_mnc_tvb;

  /* Reset the digits string in the private data struct */
  /* Maximal length: 7 = 3 digits MCC + 3 digits MNC + trailing '\0' */
  mcc_mnc_strbuf = wmem_strbuf_sized_new(actx->pinfo->pool,7,7);
  private_data_set_digits_strbuf(actx, mcc_mnc_strbuf);
  /* Reset parsing failure flag*/
  private_data_set_digits_strbuf_parsing_failed_flag(actx, FALSE);
%(DEFAULT_BODY)s
  private_data_set_digits_strbuf(actx, NULL);
  /* Check for parsing errors */
  if(private_data_get_digits_strbuf_parsing_failed_flag(actx)) {
    return offset;
  }

  /* Extracting the string collected in the strbuf */
  string_len = (guint32)wmem_strbuf_get_len(mcc_mnc_strbuf);
  mcc_mnc_string = wmem_strbuf_finalize(mcc_mnc_strbuf);

  if(string_len >= 3)
  {
    /* 3 MCC digits were found, keep for later in case MCC is missing in other PLMN ids*/
    mcc_strbuf = wmem_strbuf_sized_new(actx->pinfo->pool,4,4);
    wmem_strbuf_append_c(mcc_strbuf,mcc_mnc_string[0]);
    wmem_strbuf_append_c(mcc_strbuf,mcc_mnc_string[1]);
    wmem_strbuf_append_c(mcc_strbuf,mcc_mnc_string[2]);
    wmem_strbuf_append_c(mcc_strbuf,'\0');
    private_data_set_last_mcc_strbuf(actx,mcc_strbuf);
  }

  /* Creating TVB from extracted string*/
  mcc_mnc_tvb = tvb_new_child_real_data(tvb, (guint8*)mcc_mnc_string, string_len, string_len);
  add_new_data_source(actx->pinfo, mcc_mnc_tvb, "MCC-MNC");

  /* Calling E.212 */
  dissect_e212_mcc_mnc_in_utf8_address(mcc_mnc_tvb, actx->pinfo, tree, 0);

#.FN_BODY PLMN-IdentityWithOptionalMCC-r6
  wmem_strbuf_t* mcc_mnc_strbuf;
  wmem_strbuf_t* temp_strbuf;
  wmem_strbuf_t* last_mcc_strbuf;
  guint32 string_len;
  gchar* mcc_mnc_string;
  tvbuff_t* mcc_mnc_tvb;

  /* Reset the digits string in the private data struct */
  /* Maximal length: 7 = 3 digits MCC + 3 digits MNC + trailing '\0' */
  mcc_mnc_strbuf = wmem_strbuf_sized_new(actx->pinfo->pool,7,7);
  private_data_set_digits_strbuf(actx, mcc_mnc_strbuf);
  /* Reset parsing failure flag*/
  private_data_set_digits_strbuf_parsing_failed_flag(actx, FALSE);
%(DEFAULT_BODY)s
  private_data_set_digits_strbuf(actx, NULL);
  /* Check for parsing errors */
  if(private_data_get_digits_strbuf_parsing_failed_flag(actx)) {
    return offset;
  }

  /* Extracting the string collected in the strbuf */
  string_len = (guint32)wmem_strbuf_get_len(mcc_mnc_strbuf);
  mcc_mnc_string = wmem_strbuf_finalize(mcc_mnc_strbuf);
  if (string_len > 3) {
      /* 3 MCC digits and at least 1 MNC digit were found, keep MCC for later
         in case it's missing in other PLMN ids*/
    temp_strbuf = wmem_strbuf_sized_new(actx->pinfo->pool,4,4);
    wmem_strbuf_append_c(temp_strbuf,mcc_mnc_string[0]);
    wmem_strbuf_append_c(temp_strbuf,mcc_mnc_string[1]);
    wmem_strbuf_append_c(temp_strbuf,mcc_mnc_string[2]);
    wmem_strbuf_append_c(temp_strbuf,'\0');
    private_data_set_last_mcc_strbuf(actx,temp_strbuf);
  }
  else {
      /* mcc_mnc_strbuf Probably only has 3/2 digits of MNC */
      /* Try to fill MCC form "last MCC" if we have it stored */
      last_mcc_strbuf = private_data_get_last_mcc_strbuf(actx);
      if(last_mcc_strbuf)
      {
        /* Concat MCC and MNC in temp buffer */
        temp_strbuf = wmem_strbuf_sized_new(actx->pinfo->pool,7,7);
        wmem_strbuf_append_printf(temp_strbuf,"%%s",wmem_strbuf_get_str(last_mcc_strbuf));
        wmem_strbuf_append_printf(temp_strbuf,"%%s",mcc_mnc_string);
        /* Update length of recovered MCC-MNC pair */
        string_len = (guint32)wmem_strbuf_get_len(temp_strbuf);
        mcc_mnc_string = wmem_strbuf_finalize(temp_strbuf);
      }
  }

  if (string_len >= 5) {
    /* optional MCC was present (or restored above), we can call E.212 dissector */

    /* Creating TVB from extracted string*/
    mcc_mnc_tvb = tvb_new_child_real_data(tvb, (guint8*)mcc_mnc_string, string_len, string_len);
    add_new_data_source(actx->pinfo, mcc_mnc_tvb, "MCC-MNC");

    /* Calling E.212 */
    dissect_e212_mcc_mnc_in_utf8_address(mcc_mnc_tvb, actx->pinfo, tree, 0);
  }

#.FN_BODY IMSI-GSM-MAP
  wmem_strbuf_t* imsi_strbuf;
  guint32 string_len;
  gchar* imsi_string;
  tvbuff_t* imsi_tvb;

  /* Reset the digits string in the private data struct */
  imsi_strbuf = wmem_strbuf_sized_new(actx->pinfo->pool,16,16);
  private_data_set_digits_strbuf(actx, imsi_strbuf);
  /* Reset parsing failure flag*/
  private_data_set_digits_strbuf_parsing_failed_flag(actx, FALSE);
%(DEFAULT_BODY)s
  private_data_set_digits_strbuf(actx, NULL);
  /* Check for parsing errors */
  if(private_data_get_digits_strbuf_parsing_failed_flag(actx)) {
    return offset;
  }

  /* Extracting the string collected in the strbuf */
  string_len = (guint32)wmem_strbuf_get_len(imsi_strbuf);
  imsi_string = wmem_strbuf_finalize(imsi_strbuf);

  /* Creating TVB from extracted string*/
  imsi_tvb = tvb_new_child_real_data(tvb, (guint8*)imsi_string, string_len, string_len);
  add_new_data_source(actx->pinfo, imsi_tvb, "IMSI");

  /* Calling E.212 */
  dissect_e212_utf8_imsi(imsi_tvb,actx->pinfo,tree,0,string_len);

#.FN_BODY Digit VAL_PTR = &digit
  guint32 digit;
  wmem_strbuf_t* digits_strbuf; /* The string of either an IMSI or a MCC-MNC pair */
%(DEFAULT_BODY)s

  if(private_data_get_digits_strbuf_parsing_failed_flag(actx)) {
    return offset;
  }

  digits_strbuf = private_data_get_digits_strbuf(actx);
  if (digits_strbuf) {
    gchar digit_char;

    if(digit > 9) {
      private_data_set_digits_strbuf_parsing_failed_flag(actx, TRUE);
      return offset;
    }

    /* Converting to the matching gchar */
    digit_char = (gchar)(digit + '0');

    /* Appending to the digits string */
    wmem_strbuf_append_c(digits_strbuf, digit_char);
  }

#.FN_BODY CompleteSIBshort
  private_data_set_curr_sib_segment_type(actx,RRC_SIB_SEG_COMP);
%(DEFAULT_BODY)s
  private_data_set_curr_sib_segment_type(actx,RRC_SIB_SEG_NO_SEGMENT); /* Resetting value */

#.FN_BODY SIB-Type VAL_PTR = &sib_type
  guint32 sib_type;
%(DEFAULT_BODY)s
  private_data_set_curr_sib_type(actx,sib_type);

#.FN_BODY SIB-Data-variable VAL_PTR = &sib_data_tvb
  tvbuff_t *sib_data_tvb;
  guint32 sib_type;
  proto_tree *subtree;
  guint32 seg_type;

%(DEFAULT_BODY)s

  seg_type = (guint32)private_data_get_curr_sib_segment_type(actx);
  if(seg_type != RRC_SIB_SEG_COMP) {
      /* TODO: The Dissector only handles 'complete SIBs' right now.
       * Reassembly logic should be implemented, taking into acocunt that
       * different fragments might arrive in different frames.
       */
      return offset;
  }

  /* This is a complete SIB - Call handler according to previous SIB-Type field*/
  subtree = proto_item_add_subtree(actx->created_item, ett_rrc_sib_data_var);
  sib_type = private_data_get_curr_sib_type(actx);
  col_set_fence(actx->pinfo->cinfo, COL_INFO);
  col_append_str(actx->pinfo->cinfo, COL_INFO," (");
  switch(sib_type){
    case 0:
      /* mIB */
      dissect_rrc_MasterInformationBlock_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 1:
      dissect_rrc_SysInfoType1_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 2:
      dissect_rrc_SysInfoType2_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 3:
      dissect_rrc_SysInfoType3_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 4:
      dissect_rrc_SysInfoType4_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 5:
      dissect_rrc_SysInfoType5_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 6:
      dissect_rrc_SysInfoType6_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 7:
      dissect_rrc_SysInfoType7_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 11:
      dissect_rrc_SysInfoType11_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 12:
      dissect_rrc_SysInfoType12_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 13:
      dissect_rrc_SysInfoType13_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 14:
      /* SIB-Type: systemInformationBlockType13-1 */
      dissect_rrc_SysInfoType13_1_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 15:
      /* SIB-Type: systemInformationBlockType13-2 */
      dissect_rrc_SysInfoType13_2_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 16:
      /* SIB-Type: systemInformationBlockType13-3 */
      dissect_rrc_SysInfoType13_3_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 17:
      /* SIB-Type: systemInformationBlockType13-4 */
      dissect_rrc_SysInfoType13_4_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 18:
      /* SIB-Type: systemInformationBlockType14 */
      dissect_rrc_SysInfoType14_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 19:
      /* SIB-Type: systemInformationBlockType15 */
      dissect_rrc_SysInfoType15_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 20:
      /* SIB-Type: systemInformationBlockType15-1 */
      dissect_rrc_SysInfoType15_1_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 21:
      /* SIB-Type: systemInformationBlockType15-2 */
      dissect_rrc_SysInfoType15_2_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 22:
      /* SIB-Type: systemInformationBlockType15-3 */
      dissect_rrc_SysInfoType15_3_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 23:
      /* SIB-Type: systemInformationBlockType16 */
      dissect_rrc_SysInfoType16_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 24:
      /* SIB-Type: systemInformationBlockType17 */
      dissect_rrc_SysInfoType17_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 25:
      /* SIB-Type: systemInformationBlockType15-4 */
      dissect_rrc_SysInfoType15_4_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 26:
      /* SIB-Type: systemInformationBlockType18 */
      dissect_rrc_SysInfoType18_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 27:
      /* SIB-Type: schedulingBlock1 */
      dissect_rrc_SysInfoTypeSB1_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    case 28:
      /* SIB-Type: schedulingBlock2 */
      dissect_rrc_SysInfoTypeSB2_PDU(sib_data_tvb, actx->pinfo, subtree, NULL);
      break;
    default:
      break;
    }

  col_append_str(actx->pinfo->cinfo, COL_INFO,")");
  col_set_fence(actx->pinfo->cinfo, COL_INFO);

#.FN_BODY RSR-VCC-Info/ims-Information VAL_PTR = &imsInformation_tvb
  tvbuff_t *imsInformation_tvb=NULL;
%(DEFAULT_BODY)s
  if(imsInformation_tvb){
    /* Dissect ims-Information
       Decoding specified in TS 124 237 V11.4.0 Annex D.5.3.3 ATGW transfer details
     */
    proto_tree *subtree;
    gint curr_offset = 0;
    guint32 atgw_trans_det_cont;
    subtree = proto_item_add_subtree(actx->created_item, ett_rrc_ims_info);
    proto_tree_add_item_ret_uint(subtree, hf_rrc_ims_info_atgw_trans_det_cont_type, imsInformation_tvb, curr_offset, 1, ENC_BIG_ENDIAN, &atgw_trans_det_cont);
    curr_offset++;
    switch (atgw_trans_det_cont) {
      case 0:
        proto_tree_add_item(subtree, hf_rrc_ims_info_atgw_udp_port, imsInformation_tvb, curr_offset, 2, ENC_BIG_ENDIAN);
        curr_offset+=2;
        proto_tree_add_item(subtree, hf_rrc_ims_info_atgw_ipv4, imsInformation_tvb, curr_offset, 4, ENC_BIG_ENDIAN);
        break;
      case 1:
        proto_tree_add_item(subtree, hf_rrc_ims_info_atgw_udp_port, imsInformation_tvb, curr_offset, 2, ENC_BIG_ENDIAN);
        curr_offset+=2;
        proto_tree_add_item(subtree, hf_rrc_ims_info_atgw_ipv6, imsInformation_tvb, curr_offset, 16, ENC_NA);
        break;
      default:
      break;
    }
}

#.TYPE_ATTR
HNBName TYPE=FT_STRING DISPLAY=BASE_NONE

#.FN_BODY HNBName VAL_PTR = &hnbname_tvb HF_INDEX = -1
  tvbuff_t *hnbname_tvb = NULL;

%(DEFAULT_BODY)s
  actx->created_item = proto_tree_add_item(tree, hf_index, hnbname_tvb, 0, -1, ENC_UTF_8|ENC_NA);

#.FN_BODY CN-DomainIdentity VAL_PTR = &nas_sys_info
  guint32 nas_sys_info;
%(DEFAULT_BODY)s
  col_append_fstr(actx->pinfo->cinfo, COL_INFO, "(%%s)", val_to_str_const(nas_sys_info,rrc_CN_DomainIdentity_vals,"Unknown"));
  nas_sys_info++; /* CS = 0, PS = 1 but the enum defines 0 as Unknown and CS = 1, PS = 2 */
  private_data_set_cn_domain(actx, (enum nas_sys_info_gsm_map) nas_sys_info);

#.FN_BODY CN-InformationInfo/cn-CommonGSM-MAP-NAS-SysInfo
  private_data_set_cn_domain(actx, RRC_NAS_SYS_INFO_CN_COMMON);
%(DEFAULT_BODY)s

#.FN_BODY CN-InformationInfo-r6/cn-CommonGSM-MAP-NAS-SysInfo
  private_data_set_cn_domain(actx, RRC_NAS_SYS_INFO_CN_COMMON);
%(DEFAULT_BODY)s

#.FN_BODY CN-InformationInfoFull/cn-CommonGSM-MAP-NAS-SysInfo
  private_data_set_cn_domain(actx, RRC_NAS_SYS_INFO_CN_COMMON);
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType1/cn-CommonGSM-MAP-NAS-SysInfo
  private_data_set_cn_domain(actx, RRC_NAS_SYS_INFO_CN_COMMON);
%(DEFAULT_BODY)s

#.FN_BODY NAS-SystemInformationGSM-MAP VAL_PTR = &nas_sys_info_gsm_map_tvb
  tvbuff_t *nas_sys_info_gsm_map_tvb = NULL;
  guint32 length;
  enum nas_sys_info_gsm_map cn_domain;
  proto_tree *subtree;

%(DEFAULT_BODY)s
  length = tvb_reported_length(nas_sys_info_gsm_map_tvb);
  if (length) {
    cn_domain = private_data_get_cn_domain(actx);
    switch (cn_domain) {
      case RRC_NAS_SYS_INFO_CN_COMMON:
        subtree = proto_tree_add_subtree(tree, nas_sys_info_gsm_map_tvb, 0, length,
                  ett_rrc_cn_CommonGSM_MAP_NAS_SysInfo, NULL, "CN Common GSM-MAP NAS system information");
        de_cn_common_gsm_map_nas_sys_info(nas_sys_info_gsm_map_tvb, subtree, actx->pinfo, 0, length, NULL, 0);
        break;
      case RRC_NAS_SYS_INFO_CS:
        subtree = proto_tree_add_subtree(tree, nas_sys_info_gsm_map_tvb, 0, length,
                  ett_rrc_cn_CommonGSM_MAP_NAS_SysInfo, NULL, "CS domain specific system information");
        de_cs_domain_spec_sys_info(nas_sys_info_gsm_map_tvb, subtree, actx->pinfo, 0, length, NULL, 0);
        break;
      case RRC_NAS_SYS_INFO_PS:
        subtree = proto_tree_add_subtree(tree, nas_sys_info_gsm_map_tvb, 0, length,
                  ett_rrc_cn_CommonGSM_MAP_NAS_SysInfo, NULL, "PS domain specific system information");
        de_ps_domain_spec_sys_info(nas_sys_info_gsm_map_tvb, subtree, actx->pinfo, 0, length, NULL, 0);
        break;
      default:
        break;
    }
    private_data_set_cn_domain(actx, RRC_NAS_SYS_UNKNOWN);
  }

#.FN_BODY SRNC-Identity VAL_PTR = &s_rnc_id_tvb
  tvbuff_t * s_rnc_id_tvb = NULL;
%(DEFAULT_BODY)s
  if (s_rnc_id_tvb) {
      private_data_set_s_rnc_id(actx, tvb_get_ntohs(s_rnc_id_tvb, 0) >> 4);
  }

#.FN_BODY S-RNTI VAL_PTR = &s_rnti_tvb
  tvbuff_t * s_rnti_tvb  = NULL;
%(DEFAULT_BODY)s
  if (s_rnti_tvb) {
      private_data_set_s_rnti(actx, tvb_get_ntoh24(s_rnti_tvb, 0) >> 4);
  }

#.FN_BODY U-RNTI
  private_data_set_s_rnc_id(actx, 0);
  private_data_set_s_rnti(actx, 0);
  guint32 s_rnc_id;
  guint32 s_rnti;
  guint32 u_rnti_value;
  guint32 original_offset;
  proto_item *ti;
  guint32 item_len;
  proto_tree *sub_tree;
  gboolean is_new_urnti;
  int generated_field_hf;
  original_offset = offset;
%(DEFAULT_BODY)s

  /* Reconstructing the U-RNTI from the parsed components */
  s_rnc_id = private_data_get_s_rnc_id(actx);
  s_rnti = private_data_get_s_rnti(actx);
  u_rnti_value = (s_rnc_id << 20) | s_rnti;

  /* Distinguishing between new allocated U-RNTIs and previously used ones */
  /* hf_rrc_u_RNTI is for current U-RNTI, any other hf is for new U-RNTI */
  is_new_urnti = hf_index != hf_rrc_u_RNTI;
  if (is_new_urnti) {
    private_data_set_new_u_rnti(actx, u_rnti_value);
    generated_field_hf = hf_urnti_new;
  }
  else {
    private_data_set_current_u_rnti(actx, u_rnti_value);
    generated_field_hf = hf_urnti_current;
  }

  /* Adding a "Current U-RNTI" or "New U-RNTI" as generated field */
  sub_tree = proto_item_get_subtree(actx->created_item);
  item_len = proto_item_get_len(actx->created_item);
  ti = proto_tree_add_uint(sub_tree, generated_field_hf, tvb, original_offset/8, item_len, u_rnti_value);
  proto_item_set_generated(ti);
  ti = proto_tree_add_uint(sub_tree, hf_urnti, tvb, original_offset/8, item_len, u_rnti_value);
  proto_item_set_hidden(ti);

  private_data_set_s_rnc_id(actx, 0);
  private_data_set_s_rnti(actx, 0);

#.FN_BODY C-RNTI VAL_PTR = &c_rnti_tvb
  fp_info *fpinf = NULL;
  umts_mac_info *macinf = NULL;
  rlc_info *rlcinf = NULL;
  conversation_t   *p_conv;
  umts_fp_conversation_info_t *umts_fp_conversation_info = NULL;
  fp_fach_channel_info_t *fp_fach_channel_info = NULL;
  tvbuff_t * c_rnti_tvb = NULL;
  guint16 c_rnti = 0;
  guint32 u_rnti = 0;
  fp_crnti_allocation_info_t *fp_crnti_allocation_info = NULL;
%(DEFAULT_BODY)s
  if (!c_rnti_tvb)
    return offset;

  if(tvb_reported_length(c_rnti_tvb)>=2){
    c_rnti = tvb_get_ntohs(c_rnti_tvb,0);
  }

  if(PINFO_FD_VISITED(actx->pinfo)) /* Frame was already checked*/
    return offset;

  /* Trying to figure where to get the U-RNTI from Either from an ASN.1 field (if this is CCCH) or RLC's attached info (if this is DCCH) */
  fpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_fp, 0);
  macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_umts_mac, 0);
  rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_umts_rlc, 0);
  if (fpinf && macinf && rlcinf) {
    switch(macinf->content[fpinf->cur_tb]){
      case MAC_CONTENT_DCCH:
        u_rnti = rlcinf->ueid[fpinf->cur_tb];
        break;
      case MAC_CONTENT_CCCH:
      default:
        u_rnti = private_data_get_current_u_rnti(actx);
        break;
    }
  }
  else {
    /* Either FP, MAC or RLC info is missing - looking for ASN.1 field as last resort*/
    u_rnti = private_data_get_current_u_rnti(actx);
  }

  if(u_rnti == 0 || c_rnti == 0) /* U-RNTI missing or failed to parse C-RNTI */
    return offset;

  /* Both U-RNTI and C-RNTI present - storing the match*/
  fp_crnti_allocation_info = wmem_new(wmem_file_scope(), fp_crnti_allocation_info_t);
  fp_crnti_allocation_info->urnti = u_rnti;
  fp_crnti_allocation_info->alloc_frame_number = actx->pinfo->num;
  fp_crnti_allocation_info->global_retrieval_count = 0;

  /* Finding FP conversation info */
  p_conv = (conversation_t *)find_conversation(actx->pinfo->num, &actx->pinfo->net_dst, &actx->pinfo->net_src,
      conversation_pt_to_conversation_type(actx->pinfo->ptype),
      actx->pinfo->destport, actx->pinfo->srcport, NO_ADDR_B);

  /* If the current FP channel is FACH, Adding the C-RNTI / U-RNTI match to the FACH's RNTIs map*/
  if (p_conv != NULL) {
      umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);
      if (umts_fp_conversation_info && umts_fp_conversation_info->channel == CHANNEL_FACH_FDD) {
          fp_fach_channel_info = (fp_fach_channel_info_t *)umts_fp_conversation_info->channel_specific_info;
          if(fp_fach_channel_info) {
              wmem_tree_insert32(fp_fach_channel_info->crnti_to_urnti_map, c_rnti, (void *)fp_crnti_allocation_info);
          }
      }
  }

  /* Also adding the C-RNTI / U-RNTI match to the global RNTIs map for the RACH channel */
  wmem_tree_insert32(rrc_global_urnti_crnti_map, c_rnti, (void *)fp_crnti_allocation_info);

#.FN_BODY UL-ScramblingCode VAL_PTR = &scrambling_code
guint32 scrambling_code;
%(DEFAULT_BODY)s
private_data_set_scrambling_code(actx,scrambling_code);

#.FN_BODY RRC-StateIndicator VAL_PTR = &state_dec
gint32 state_dec = -1;
%(DEFAULT_BODY)s
if(state_dec >= 0 && state_dec <= 3) {
  state_dec++; /* Encoded values are 0-based, Values in the enum are 1-based*/
  private_data_set_rrc_state_indicator(actx,(enum rrc_ue_state)state_dec);
}

#.FN_BODY CellIdentity VAL_PTR = &cell_id_tvb
  tvbuff_t * cell_id_tvb = NULL;
  proto_item *temp_ti;
  proto_tree *cell_identity_tree;

%(DEFAULT_BODY)s
  if(cell_id_tvb != NULL) {
      cell_identity_tree = proto_item_add_subtree(actx->created_item, ett_rrc_cellIdentity);
      temp_ti = proto_tree_add_bits_item(cell_identity_tree, hf_rrc_cellIdentity_rnc_id,cell_id_tvb, 0, 12, ENC_BIG_ENDIAN);
      proto_item_set_generated(temp_ti);
      temp_ti = proto_tree_add_bits_item(cell_identity_tree, hf_rrc_cellIdentity_c_id, cell_id_tvb, 12, 16, ENC_BIG_ENDIAN);
      proto_item_set_generated(temp_ti);
  }

#.FN_BODY DL-TransportChannelType-r5 VAL_PTR = &type
/*Here we try to figure out which HS-DSCH channels are multiplexed*/
    guint *flowd_p;
    guint *cur_val=NULL;
    struct rrc_info *rrcinf;

    %(DEFAULT_BODY)s

    /*TODO: This should probably be done better*/
    if(type == 4){    /*If this is type HS-DSCH*/
        num_chans_per_flow[flowd]++;

        if(num_chans_per_flow[flowd] > 1 ){
            rrcinf = (rrc_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_rrc, 0);
            if((rrcinf == NULL) || (rrcinf->hrnti[actx->pinfo->fd->subnum] == 0)){
                expert_add_info(actx->pinfo, actx->created_item, &ei_rrc_no_hrnti);
            }
            else{
                /*If it doesn't exists, insert it*/
                if( (cur_val=(gint *)g_tree_lookup(hsdsch_muxed_flows, GUINT_TO_POINTER((guint)rrcinf->hrnti[actx->pinfo->fd->subnum]))) == NULL ){

                    flowd_p = g_new0(guint, 1);
                    *flowd_p = (1U<<flowd);    /*Set the bit to mark it as true*/
                    g_tree_insert(hsdsch_muxed_flows, GUINT_TO_POINTER((guint)rrcinf->hrnti[actx->pinfo->fd->subnum]), flowd_p);

                }else{
                    *cur_val = (1U<<flowd) | *cur_val;

                }
            }

        }

    }

#.FN_BODY DL-TransportChannelType-r7 VAL_PTR = &type
/*Here we try to figure out which HS-DSCH channels are multiplexed*/
    guint *flowd_p;
    guint *cur_val=NULL;
    struct rrc_info *rrcinf;

    %(DEFAULT_BODY)s

    /*TODO: This should probably be done better*/
    if(type == 4){    /*If this is type HS-DSCH*/
        num_chans_per_flow[flowd]++;


        if(num_chans_per_flow[flowd] > 1 ){
            rrcinf = (rrc_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_rrc, 0);
            if((rrcinf == NULL) || (rrcinf->hrnti[actx->pinfo->fd->subnum] == 0)){
                expert_add_info(actx->pinfo, actx->created_item, &ei_rrc_no_hrnti);
            }
            else{
                /*If it doesn't exists, insert it*/
                if( (cur_val=(gint *)g_tree_lookup(hsdsch_muxed_flows, GUINT_TO_POINTER((guint)rrcinf->hrnti[actx->pinfo->fd->subnum]))) == NULL ){

                    flowd_p = g_new0(guint, 1);
                    *flowd_p = (1U<<flowd);    /* Set the bit to mark it as true*/
                    g_tree_insert(hsdsch_muxed_flows, GUINT_TO_POINTER((guint)rrcinf->hrnti[actx->pinfo->fd->subnum]), flowd_p);

                }else{
                    *cur_val = (1U<<flowd) | *cur_val;

                }
            }

        }

    }

#.FN_BODY MAC-d-FlowIdentity VAL_PTR = &flowd
%(DEFAULT_BODY)s

#.FN_BODY H-RNTI VAL_PTR = &hrnti_tvb
  tvbuff_t *hrnti_tvb;
  struct rrc_info *rrcinf;
%(DEFAULT_BODY)s

#.FN_FTR H-RNTI
  rrcinf = (struct rrc_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_rrc, 0);
  if (!rrcinf) {
    rrcinf = wmem_new0(wmem_file_scope(), struct rrc_info);
    p_add_proto_data(wmem_file_scope(), actx->pinfo, proto_rrc, 0, rrcinf);
  }
  rrcinf->hrnti[actx->pinfo->fd->subnum] = tvb_get_ntohs(hrnti_tvb, 0);

#.FN_BODY START-Value VAL_PTR = &start_val
  tvbuff_t * start_val;
  fp_info       *fpinf;
  rlc_info      *rlcinf;
  rrc_ciphering_info * ciphering_info;
  guint32 * start;
  enum nas_sys_info_gsm_map cn_domain;

%(DEFAULT_BODY)s

  /*We base this map on User Identity from RLC*/
  fpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_fp, 0);
  rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_umts_rlc, 0);

  /*If FP info or RLC info is missing , skip all this*/
  if(fpinf == NULL || rlcinf == NULL){
      return offset;
  }
  /*Retrieve the start value for the two ciphering domains*/
  cn_domain = private_data_get_cn_domain(actx);
  switch(cn_domain){
    case RRC_NAS_SYS_INFO_CS:
      /*
      ws_warning("Not implemented");
      */
      break;
    case RRC_NAS_SYS_INFO_PS:

      /*Find the entry for the UE ID(taken from RLC)*/
      ciphering_info = get_or_create_cipher_info(fpinf, rlcinf);
      private_data_set_ciphering_info(actx, ciphering_info);

      /*Retrieve and store the value*/
      if(ciphering_info && ciphering_info->start_ps) {
        start = g_new(guint32,1);
        *start = tvb_get_bits32(start_val,0,20,ENC_BIG_ENDIAN);
        /*Insert the value based on current frame num since this might vary over time*/
        g_tree_insert(ciphering_info->start_ps, GUINT_TO_POINTER(actx->pinfo->num), start);
      }
      break;
    default:
      break;
  }
  private_data_set_cn_domain(actx, RRC_NAS_SYS_UNKNOWN);

#.FN_BODY RB-ActivationTimeInfo
  fp_info            *fpinf;
  rlc_info           *rlcinf;
  rrc_ciphering_info *ciphering_info;
  guint32 rbid;
  guint32 rlc_ciphering_sqn;
  guint32 direction;

  fpinf = (fp_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_fp, 0);
  rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), actx->pinfo, proto_umts_rlc, 0);

%(DEFAULT_BODY)s

  /*If FP info or RLC info is missing , skip all this*/
  if(fpinf == NULL || rlcinf == NULL){
    return offset;
  }

  ciphering_info = private_data_get_ciphering_info(actx);
  if( ciphering_info == NULL ){
    return offset;
  }

  rbid = private_data_get_rbid(actx);
  rlc_ciphering_sqn = private_data_get_rlc_ciphering_sqn(actx);
  direction = fpinf->is_uplink ? P2P_DIR_UL : P2P_DIR_DL;
  /*Set the ciphering activation frame information*/
  ciphering_info->seq_no[rbid][direction] = rlc_ciphering_sqn;


#.FN_BODY RB-Identity VAL_PTR = &rbid
guint32 rbid;
%(DEFAULT_BODY)s
private_data_set_rbid(actx, rbid);


#.FN_BODY RLC-SequenceNumber VAL_PTR = &rlc_ciphering_sqn
guint32 rlc_ciphering_sqn;
%(DEFAULT_BODY)s
private_data_set_rlc_ciphering_sqn(actx, rlc_ciphering_sqn);

#.FN_BODY CipheringAlgorithm VAL_PTR = &ciphering_algo
  rrc_ciphering_info *ciphering_info;
  gint32 ciphering_algo;

%(DEFAULT_BODY)s

  ciphering_info = private_data_get_ciphering_info(actx);
  if (ciphering_info == NULL) {
    return offset;
  }
  ciphering_info->ciphering_algorithm = ciphering_algo;

#.FN_BODY CipheringAlgorithm-r7 VAL_PTR = &ciphering_algo
  rrc_ciphering_info *ciphering_info;
  gint32 ciphering_algo;

%(DEFAULT_BODY)s

  ciphering_info = private_data_get_ciphering_info(actx);
  if (ciphering_info == NULL) {
    return offset;
  }
  ciphering_info->ciphering_algorithm = ciphering_algo;

#.FN_BODY IntegrityProtectionAlgorithm VAL_PTR = &integrity_algo
  rrc_ciphering_info *ciphering_info;
  gint32 integrity_algo;

%(DEFAULT_BODY)s

  ciphering_info = private_data_get_ciphering_info(actx);
  if (ciphering_info == NULL) {
    return offset;
  }
  ciphering_info->integrity_algorithm = integrity_algo;

#.FN_BODY IntegrityProtectionAlgorithm-r7 VAL_PTR = &integrity_algo
  rrc_ciphering_info *ciphering_info;
  gint32 integrity_algo;

%(DEFAULT_BODY)s

  ciphering_info = private_data_get_ciphering_info(actx);
  if (ciphering_info == NULL) {
    return offset;
  }
  ciphering_info->integrity_algorithm = integrity_algo;

#.FN_BODY DL-DCCH-MessageType VAL_PTR = &msg_type
%(DEFAULT_BODY)s

#.FN_BODY DL-DCCH-Message
%(DEFAULT_BODY)s

#.FN_BODY HandoverToUTRANCommand
%(DEFAULT_BODY)s

#.FN_BODY UE-SecurityInformation
  private_data_set_cn_domain(actx, RRC_NAS_SYS_INFO_CS);
%(DEFAULT_BODY)s

#.FN_BODY UE-SecurityInformation2
  private_data_set_cn_domain(actx, RRC_NAS_SYS_INFO_PS);
%(DEFAULT_BODY)s

#.FN_BODY ReleaseCause VAL_PTR=&value
  guint32 value;
%(DEFAULT_BODY)s
  col_append_fstr(actx->pinfo->cinfo, COL_INFO, " [cause=%%s]",
                  val_to_str(value, rrc_ReleaseCause_vals, "Unknown"));

#.FN_BODY MasterInformationBlock
  col_append_str(actx->pinfo->cinfo, COL_INFO, "MasterInformationBlock");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType1
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 1");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType2
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 2");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType3
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 3");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType4
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 4");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType5
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 5");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType5bis
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 5bis");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType6
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 6");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType7
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 7");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType11
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 11");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType11bis
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 11bis");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType11ter
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 11ter");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType12
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 12");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType13
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 13");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType13-1
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 13.1");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType13-2
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 13.2");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType13-3
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 13.3");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType13-4
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 13.4");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType14
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 14");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15bis
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15bis");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15-1
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15.1");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15-1bis
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15.1bis");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15-1ter
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15.1ter");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15-2
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15.2");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15-2bis
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15.2bis");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15-2ter
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15.2ter");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15-3
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15.3");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15-3bis
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15.3bis");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15-4
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15.4");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15-5
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15.5");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15-6
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15.6");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15-7
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15.7");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType15-8
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 15.8");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType16
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 16");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType17
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 17");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType18
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 18");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType19
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 19");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType20
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 20");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType21
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 21");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType22
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 22");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType23
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 23");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType24
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 24");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoType25
  col_append_str(actx->pinfo->cinfo, COL_INFO, "SysInfoType 25");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoTypeSB1
  col_append_str(actx->pinfo->cinfo, COL_INFO, "Scheduling Block 1");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoTypeSB2
  col_append_str(actx->pinfo->cinfo, COL_INFO, "Scheduling Block 2");
%(DEFAULT_BODY)s

#.FN_BODY SysInfoTypeSB3
  col_append_str(actx->pinfo->cinfo, COL_INFO, "Scheduling Block 3");
%(DEFAULT_BODY)s

#.END
