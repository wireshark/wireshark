/* packet-parlay.c
 * Routines for IDL dissection
 *
 * Autogenerated from idl2eth
 * Copyright 2001 Frank Singleton <frank.singleton@ericsson.com>
 */


/*
 * Ethereal - Network traffic analyzer
 * By Gerald Combs
 * Copyright 1999 Gerald Combs
 */


/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */


#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <gmodule.h>

#include <string.h>
#include <glib.h>
#include <epan/packet.h>
#include <epan/proto.h>
#include <epan/dissectors/packet-giop.h>

#ifndef ENABLE_STATIC
G_MODULE_EXPORT const gchar version[] = "0.0.1";
#endif



static proto_tree *start_dissecting(tvbuff_t *tvb, packet_info *pinfo, proto_tree *ptree, int *offset);



/* Struct prototype declaration Start */


/* Struct = IDL:org/csapi/TpAddress:1.0 */

static void decode_org_csapi_TpAddress_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/TpAddressRange:1.0 */

static void decode_org_csapi_TpAddressRange_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/TpCAIElements:1.0 */

static void decode_org_csapi_TpCAIElements_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/TpChargeAdviceInfo:1.0 */

static void decode_org_csapi_TpChargeAdviceInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/TpChargePerTime:1.0 */

static void decode_org_csapi_TpChargePerTime_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/TpAoCInfo:1.0 */

static void decode_org_csapi_TpAoCInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/TpTimeInterval:1.0 */

static void decode_org_csapi_TpTimeInterval_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/TpStructuredAttributeValue:1.0 */

static void decode_org_csapi_TpStructuredAttributeValue_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/TpAttribute:1.0 */

static void decode_org_csapi_TpAttribute_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpFaultStats:1.0 */

static void decode_org_csapi_fw_TpFaultStats_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpFaultStatsRecord:1.0 */

static void decode_org_csapi_fw_TpFaultStatsRecord_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpLoadPolicy:1.0 */

static void decode_org_csapi_fw_TpLoadPolicy_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpLoadStatisticData:1.0 */

static void decode_org_csapi_fw_TpLoadStatisticData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpLoadThreshold:1.0 */

static void decode_org_csapi_fw_TpLoadThreshold_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpLoadInitVal:1.0 */

static void decode_org_csapi_fw_TpLoadInitVal_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpProperty:1.0 */

static void decode_org_csapi_fw_TpProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpClientAppDescription:1.0 */

static void decode_org_csapi_fw_TpClientAppDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpEntOp:1.0 */

static void decode_org_csapi_fw_TpEntOp_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpSag:1.0 */

static void decode_org_csapi_fw_TpSag_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpServiceProperty:1.0 */

static void decode_org_csapi_fw_TpServiceProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpServiceDescription:1.0 */

static void decode_org_csapi_fw_TpServiceDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpService:1.0 */

static void decode_org_csapi_fw_TpService_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpServiceProfileDescription:1.0 */

static void decode_org_csapi_fw_TpServiceProfileDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpServiceTypeProperty:1.0 */

static void decode_org_csapi_fw_TpServiceTypeProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpServiceTypeDescription:1.0 */

static void decode_org_csapi_fw_TpServiceTypeDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpSignatureAndServiceMgr:1.0 */

static void decode_org_csapi_fw_TpSignatureAndServiceMgr_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpPerson:1.0 */

static void decode_org_csapi_fw_TpPerson_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpServiceContractDescription:1.0 */

static void decode_org_csapi_fw_TpServiceContractDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpLoadStatistic:1.0 */

static void decode_org_csapi_fw_TpLoadStatistic_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpServiceContract:1.0 */

static void decode_org_csapi_fw_TpServiceContract_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpServiceProfile:1.0 */

static void decode_org_csapi_fw_TpServiceProfile_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpAuthDomain:1.0 */

static void decode_org_csapi_fw_TpAuthDomain_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpSagProfilePair:1.0 */

static void decode_org_csapi_fw_TpSagProfilePair_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpAddSagMembersConflict:1.0 */

static void decode_org_csapi_fw_TpAddSagMembersConflict_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpAssignSagToServiceProfileConflict:1.0 */

static void decode_org_csapi_fw_TpAssignSagToServiceProfileConflict_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpServiceTypePropertyValue:1.0 */

static void decode_org_csapi_fw_TpServiceTypePropertyValue_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpFwMigrationServiceAvailableInfo:1.0 */

static void decode_org_csapi_fw_TpFwMigrationServiceAvailableInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/fw/TpFwAgreementInfo:1.0 */

static void decode_org_csapi_fw_TpFwAgreementInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/ui/TpUIMessageCriteria:1.0 */

static void decode_org_csapi_ui_TpUIMessageCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/ui/TpUIEventCriteria:1.0 */

static void decode_org_csapi_ui_TpUIEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/ui/TpUIEventCriteriaResult:1.0 */

static void decode_org_csapi_ui_TpUIEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/ui/TpUIEventNotificationInfo:1.0 */

static void decode_org_csapi_ui_TpUIEventNotificationInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/ui/TpUIRecognitionProperty:1.0 */

static void decode_org_csapi_ui_TpUIRecognitionProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/ui/TpUIRecognitionCriteria:1.0 */

static void decode_org_csapi_ui_TpUIRecognitionCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/ui/TpUICollectCriteria:1.0 */

static void decode_org_csapi_ui_TpUICollectCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/ui/TpUIWordOverride:1.0 */

static void decode_org_csapi_ui_TpUIWordOverride_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/ui/TpUISynthesisInfoData:1.0 */

static void decode_org_csapi_ui_TpUISynthesisInfoData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallError:1.0 */

static void decode_org_csapi_cc_TpCallError_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallEndedReport:1.0 */

static void decode_org_csapi_cc_TpCallEndedReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallInfoReport:1.0 */

static void decode_org_csapi_cc_TpCallInfoReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallServiceCode:1.0 */

static void decode_org_csapi_cc_TpCallServiceCode_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallTreatment:1.0 */

static void decode_org_csapi_cc_TpCallTreatment_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallChargePlan:1.0 */

static void decode_org_csapi_cc_TpCallChargePlan_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallEventCriteria:1.0 */

static void decode_org_csapi_cc_gccs_TpCallEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallEventCriteriaResult:1.0 */

static void decode_org_csapi_cc_gccs_TpCallEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallReleaseCause:1.0 */

static void decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallReport:1.0 */

static void decode_org_csapi_cc_gccs_TpCallReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallReportRequest:1.0 */

static void decode_org_csapi_cc_gccs_TpCallReportRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallEventInfo:1.0 */

static void decode_org_csapi_cc_gccs_TpCallEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallEndedReport:1.0 */

static void decode_org_csapi_cc_gccs_TpCallEndedReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallInfoReport:1.0 */

static void decode_org_csapi_cc_gccs_TpCallInfoReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallTreatment:1.0 */

static void decode_org_csapi_cc_gccs_TpCallTreatment_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallIdentifier:1.0 */

static void decode_org_csapi_cc_gccs_TpCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallNotificationScope:1.0 */

static void decode_org_csapi_cc_TpCallNotificationScope_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallNotificationReportScope:1.0 */

static void decode_org_csapi_cc_TpCallNotificationReportScope_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallEventRequest:1.0 */

static void decode_org_csapi_cc_TpCallEventRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallNotificationRequest:1.0 */

static void decode_org_csapi_cc_TpCallNotificationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpNotificationRequested:1.0 */

static void decode_org_csapi_cc_TpNotificationRequested_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallLegConnectionProperties:1.0 */

static void decode_org_csapi_cc_TpCallLegConnectionProperties_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallEventInfo:1.0 */

static void decode_org_csapi_cc_TpCallEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpNotificationRequestedSetEntry:1.0 */

static void decode_org_csapi_cc_TpNotificationRequestedSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCarrier:1.0 */

static void decode_org_csapi_cc_TpCarrier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallNotificationInfo:1.0 */

static void decode_org_csapi_cc_TpCallNotificationInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallLegInfoReport:1.0 */

static void decode_org_csapi_cc_TpCallLegInfoReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/TpCallLegProperty:1.0 */

static void decode_org_csapi_cc_TpCallLegProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/mpccs/TpMultiPartyCallIdentifier:1.0 */

static void decode_org_csapi_cc_mpccs_TpMultiPartyCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/mpccs/TpCallLegIdentifier:1.0 */

static void decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/mpccs/TpAppCallLegCallBack:1.0 */

static void decode_org_csapi_cc_mpccs_TpAppCallLegCallBack_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpCallSuperviseVolume:1.0 */

static void decode_org_csapi_cc_mmccs_TpCallSuperviseVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpMediaStreamRequest:1.0 */

static void decode_org_csapi_cc_mmccs_TpMediaStreamRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpMediaStream:1.0 */

static void decode_org_csapi_cc_mmccs_TpMediaStream_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpNotificationMediaRequest:1.0 */

static void decode_org_csapi_cc_mmccs_TpNotificationMediaRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpMediaNotificationRequested:1.0 */

static void decode_org_csapi_cc_mmccs_TpMediaNotificationRequested_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpMultiMediaCallIdentifier:1.0 */

static void decode_org_csapi_cc_mmccs_TpMultiMediaCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpMultiMediaCallLegIdentifier:1.0 */

static void decode_org_csapi_cc_mmccs_TpMultiMediaCallLegIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpAppMultiMediaCallLegCallBack:1.0 */

static void decode_org_csapi_cc_mmccs_TpAppMultiMediaCallLegCallBack_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpMonoMediaConfPolicy:1.0 */

static void decode_org_csapi_cc_cccs_TpMonoMediaConfPolicy_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpJoinEventInfo:1.0 */

static void decode_org_csapi_cc_cccs_TpJoinEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpConfSearchCriteria:1.0 */

static void decode_org_csapi_cc_cccs_TpConfSearchCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpConfSearchResult:1.0 */

static void decode_org_csapi_cc_cccs_TpConfSearchResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpMultiMediaConfPolicy:1.0 */

static void decode_org_csapi_cc_cccs_TpMultiMediaConfPolicy_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpResourceReservation:1.0 */

static void decode_org_csapi_cc_cccs_TpResourceReservation_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpConfCallIdentifier:1.0 */

static void decode_org_csapi_cc_cccs_TpConfCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpSubConfCallIdentifier:1.0 */

static void decode_org_csapi_cc_cccs_TpSubConfCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/ui/TpUIIdentifier:1.0 */

static void decode_org_csapi_ui_TpUIIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/ui/TpUICallIdentifier:1.0 */

static void decode_org_csapi_ui_TpUICallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpLocationResponseTime:1.0 */

static void decode_org_csapi_mm_TpLocationResponseTime_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpLocationTrigger:1.0 */

static void decode_org_csapi_mm_TpLocationTrigger_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpLocationRequest:1.0 */

static void decode_org_csapi_mm_TpLocationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpGeographicalPosition:1.0 */

static void decode_org_csapi_mm_TpGeographicalPosition_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpMobilityStopAssignmentData:1.0 */

static void decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpUlExtendedData:1.0 */

static void decode_org_csapi_mm_TpUlExtendedData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpUserLocation:1.0 */

static void decode_org_csapi_mm_TpUserLocation_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpUserLocationExtended:1.0 */

static void decode_org_csapi_mm_TpUserLocationExtended_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpLocationTriggerCamel:1.0 */

static void decode_org_csapi_mm_TpLocationTriggerCamel_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpUserLocationCamel:1.0 */

static void decode_org_csapi_mm_TpUserLocationCamel_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpUserLocationEmergencyRequest:1.0 */

static void decode_org_csapi_mm_TpUserLocationEmergencyRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpUserLocationEmergency:1.0 */

static void decode_org_csapi_mm_TpUserLocationEmergency_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpUserStatus:1.0 */

static void decode_org_csapi_mm_TpUserStatus_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpTriggeredStatusRequest:1.0 */

static void decode_org_csapi_mm_TpTriggeredStatusRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpTriggeredStatusRequestSetEntry:1.0 */

static void decode_org_csapi_mm_TpTriggeredStatusRequestSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpPeriodicLocationRequest:1.0 */

static void decode_org_csapi_mm_TpPeriodicLocationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpPeriodicLocationRequestSetEntry:1.0 */

static void decode_org_csapi_mm_TpPeriodicLocationRequestSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpTriggeredLocationRequest:1.0 */

static void decode_org_csapi_mm_TpTriggeredLocationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpTriggeredLocationRequestSetEntry:1.0 */

static void decode_org_csapi_mm_TpTriggeredLocationRequestSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpUserStatusIndicatorExtended:1.0 */

static void decode_org_csapi_mm_TpUserStatusIndicatorExtended_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpUserInfo:1.0 */

static void decode_org_csapi_mm_TpUserInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpNetworkStatusIndicator:1.0 */

static void decode_org_csapi_mm_TpNetworkStatusIndicator_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpUserStatusExtended:1.0 */

static void decode_org_csapi_mm_TpUserStatusExtended_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mm/TpBindingNotificationCriteria:1.0 */

static void decode_org_csapi_mm_TpBindingNotificationCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/termcap/TpTerminalCapabilities:1.0 */

static void decode_org_csapi_termcap_TpTerminalCapabilities_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/termcap/TpTerminalCapabilityScope:1.0 */

static void decode_org_csapi_termcap_TpTerminalCapabilityScope_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/dsc/TpChargePerVolume:1.0 */

static void decode_org_csapi_dsc_TpChargePerVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionChargePlan:1.0 */

static void decode_org_csapi_dsc_TpDataSessionChargePlan_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionError:1.0 */

static void decode_org_csapi_dsc_TpDataSessionError_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionEventCriteria:1.0 */

static void decode_org_csapi_dsc_TpDataSessionEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionEventInfo:1.0 */

static void decode_org_csapi_dsc_TpDataSessionEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionReleaseCause:1.0 */

static void decode_org_csapi_dsc_TpDataSessionReleaseCause_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionReport:1.0 */

static void decode_org_csapi_dsc_TpDataSessionReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionReportRequest:1.0 */

static void decode_org_csapi_dsc_TpDataSessionReportRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionSuperviseVolume:1.0 */

static void decode_org_csapi_dsc_TpDataSessionSuperviseVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionEventCriteriaResult:1.0 */

static void decode_org_csapi_dsc_TpDataSessionEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionIdentifier:1.0 */

static void decode_org_csapi_dsc_TpDataSessionIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/gms/TpGMSNewMessageArrivedInfo:1.0 */

static void decode_org_csapi_gms_TpGMSNewMessageArrivedInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/gms/TpGMSNewMessageArrivedCriteria:1.0 */

static void decode_org_csapi_gms_TpGMSNewMessageArrivedCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/gms/TpMailboxIdentifier:1.0 */

static void decode_org_csapi_gms_TpMailboxIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/gms/TpMailboxFolderIdentifier:1.0 */

static void decode_org_csapi_gms_TpMailboxFolderIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagTimePeriod:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagTimePeriod_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagTimeOfDay:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagTimeOfDay_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagString:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagString_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagMonth:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagMonth_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagInt:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagInt_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagDir:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagDir_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagDayOfWeek:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagDayOfWeek_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagDateTime:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagDateTime_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpLossDescriptor:1.0 */

static void decode_org_csapi_cm_TpLossDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpLoadDescriptor:1.0 */

static void decode_org_csapi_cm_TpLoadDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpJitterDescriptor:1.0 */

static void decode_org_csapi_cm_TpJitterDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpEndpoint:1.0 */

static void decode_org_csapi_cm_TpEndpoint_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpDelayDescriptor:1.0 */

static void decode_org_csapi_cm_TpDelayDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagExcessLoadAction:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagExcessLoadAction_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpValidityInfo:1.0 */

static void decode_org_csapi_cm_TpValidityInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpProvisionedQoSInfo:1.0 */

static void decode_org_csapi_cm_TpProvisionedQoSInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpPipeQoSInfo:1.0 */

static void decode_org_csapi_cm_TpPipeQoSInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpDsCodepoint:1.0 */

static void decode_org_csapi_cm_TpDsCodepoint_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cm/TpIPSubnet:1.0 */

static void decode_org_csapi_cm_TpIPSubnet_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/am/TpBalanceInfo:1.0 */

static void decode_org_csapi_am_TpBalanceInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/am/TpChargingEventInfo:1.0 */

static void decode_org_csapi_am_TpChargingEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/am/TpBalance:1.0 */

static void decode_org_csapi_am_TpBalance_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/am/TpTransactionHistory:1.0 */

static void decode_org_csapi_am_TpTransactionHistory_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/am/TpChargingEventCriteria:1.0 */

static void decode_org_csapi_am_TpChargingEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/am/TpChargingEventCriteriaResult:1.0 */

static void decode_org_csapi_am_TpChargingEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/am/TpBalanceExpiryDate:1.0 */

static void decode_org_csapi_am_TpBalanceExpiryDate_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/am/TpVoucher:1.0 */

static void decode_org_csapi_am_TpVoucher_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cs/TpMerchantAccountID:1.0 */

static void decode_org_csapi_cs_TpMerchantAccountID_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cs/TpCorrelationID:1.0 */

static void decode_org_csapi_cs_TpCorrelationID_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cs/TpAmount:1.0 */

static void decode_org_csapi_cs_TpAmount_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cs/TpChargingPrice:1.0 */

static void decode_org_csapi_cs_TpChargingPrice_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cs/TpVolume:1.0 */

static void decode_org_csapi_cs_TpVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cs/TpChargingSessionID:1.0 */

static void decode_org_csapi_cs_TpChargingSessionID_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cs/TpPriceVolume:1.0 */

static void decode_org_csapi_cs_TpPriceVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cs/TpApplicationDescription:1.0 */

static void decode_org_csapi_cs_TpApplicationDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/cs/TpChargingParameter:1.0 */

static void decode_org_csapi_cs_TpChargingParameter_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/policy/TpPolicyEvent:1.0 */

static void decode_org_csapi_policy_TpPolicyEvent_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/policy/TpPolicyNameValue:1.0 */

static void decode_org_csapi_policy_TpPolicyNameValue_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/policy/TpPolicyType/TpPolicyRecordType:1.0 */

static void decode_org_csapi_policy_TpPolicyType_TpPolicyRecordType_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/policy/TpPolicyType/TpPolicyListType:1.0 */

static void decode_org_csapi_policy_TpPolicyType_TpPolicyListType_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/policy/TpPolicyVar:1.0 */

static void decode_org_csapi_policy_TpPolicyVar_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/policy/TpPolicyConditionListElement:1.0 */

static void decode_org_csapi_policy_TpPolicyConditionListElement_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/policy/TpPolicyActionListElement:1.0 */

static void decode_org_csapi_policy_TpPolicyActionListElement_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAttributeDef:1.0 */

static void decode_org_csapi_pam_TpPAMAttributeDef_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAttribute:1.0 */

static void decode_org_csapi_pam_TpPAMAttribute_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMPresenceData:1.0 */

static void decode_org_csapi_pam_TpPAMPresenceData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAvailabilityProfile:1.0 */

static void decode_org_csapi_pam_TpPAMAvailabilityProfile_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMCommunicationContext:1.0 */

static void decode_org_csapi_pam_TpPAMCommunicationContext_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMContext:1.0 */

static void decode_org_csapi_pam_TpPAMContext_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAccessControlData:1.0 */

static void decode_org_csapi_pam_TpPAMAccessControlData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMICEventData:1.0 */

static void decode_org_csapi_pam_TpPAMICEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMICNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMICNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMIDEventData:1.0 */

static void decode_org_csapi_pam_TpPAMIDEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMIDNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMIDNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMGMCEventData:1.0 */

static void decode_org_csapi_pam_TpPAMGMCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMGMCNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMGMCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMACEventData:1.0 */

static void decode_org_csapi_pam_TpPAMACEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMACNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMACNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMADEventData:1.0 */

static void decode_org_csapi_pam_TpPAMADEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMADNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMADNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAAEventData:1.0 */

static void decode_org_csapi_pam_TpPAMAAEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAANotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMAANotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAUEventData:1.0 */

static void decode_org_csapi_pam_TpPAMAUEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAUNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMAUNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMCCEventData:1.0 */

static void decode_org_csapi_pam_TpPAMCCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMCCNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMCCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMACPSEventData:1.0 */

static void decode_org_csapi_pam_TpPAMACPSEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMACPSNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMACPSNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAPSEventData:1.0 */

static void decode_org_csapi_pam_TpPAMAPSEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAPSNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMAPSNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMIPSEventData:1.0 */

static void decode_org_csapi_pam_TpPAMIPSEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMIPSNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMIPSNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAVCEventData:1.0 */

static void decode_org_csapi_pam_TpPAMAVCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAVCNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMAVCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMWCEventData:1.0 */

static void decode_org_csapi_pam_TpPAMWCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMWCNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMWCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/pam/TpPAMErrorInfo:1.0 */

static void decode_org_csapi_pam_TpPAMErrorInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpMailboxIdentifier:1.0 */

static void decode_org_csapi_mmm_TpMailboxIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpMultiMediaMessagingIdentifier:1.0 */

static void decode_org_csapi_mmm_TpMultiMediaMessagingIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpListMessagesCriteria:1.0 */

static void decode_org_csapi_mmm_TpListMessagesCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpMailboxFolderStatusInformation:1.0 */

static void decode_org_csapi_mmm_TpMailboxFolderStatusInformation_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpMessageDescription:1.0 */

static void decode_org_csapi_mmm_TpMessageDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpBodyPartDescription:1.0 */

static void decode_org_csapi_mmm_TpBodyPartDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpBodyPart:1.0 */

static void decode_org_csapi_mmm_TpBodyPart_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpGenericHeaderField:1.0 */

static void decode_org_csapi_mmm_TpGenericHeaderField_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpMessageInfoPropertyError:1.0 */

static void decode_org_csapi_mmm_TpMessageInfoPropertyError_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpNewMailboxMessageArrivedCriteria:1.0 */

static void decode_org_csapi_mmm_TpNewMailboxMessageArrivedCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpNewMailboxMessageArrivedInfo:1.0 */

static void decode_org_csapi_mmm_TpNewMailboxMessageArrivedInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpQueryStatusReport:1.0 */

static void decode_org_csapi_mmm_TpQueryStatusReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpTerminatingAddressList:1.0 */

static void decode_org_csapi_mmm_TpTerminatingAddressList_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpNewMessageArrivedCriteria:1.0 */

static void decode_org_csapi_mmm_TpNewMessageArrivedCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpMessagingNotificationRequested:1.0 */

static void decode_org_csapi_mmm_TpMessagingNotificationRequested_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpMessagingNotificationRequestedSetEntry:1.0 */

static void decode_org_csapi_mmm_TpMessagingNotificationRequestedSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct = IDL:org/csapi/mmm/TpNewMessageArrivedInfo:1.0 */

static void decode_org_csapi_mmm_TpNewMessageArrivedInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);


/* Struct prototype declaration End */


/* Union prototype declaration Start */



/* Union = IDL:org/csapi/TpAoCOrder:1.0 */

static void decode_org_csapi_TpAoCOrder_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/TpSimpleAttributeValue:1.0 */

static void decode_org_csapi_TpSimpleAttributeValue_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/TpAttributeValue:1.0 */

static void decode_org_csapi_TpAttributeValue_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/fw/TpFwEventCriteria:1.0 */

static void decode_org_csapi_fw_TpFwEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/fw/TpLoadStatisticEntityID:1.0 */

static void decode_org_csapi_fw_TpLoadStatisticEntityID_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/fw/TpLoadStatisticInfo:1.0 */

static void decode_org_csapi_fw_TpLoadStatisticInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/fw/TpDomainID:1.0 */

static void decode_org_csapi_fw_TpDomainID_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/fw/TpMigrationAdditionalInfo:1.0 */

static void decode_org_csapi_fw_TpMigrationAdditionalInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/fw/TpFwEventInfo:1.0 */

static void decode_org_csapi_fw_TpFwEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/ui/TpUIVariableInfo:1.0 */

static void decode_org_csapi_ui_TpUIVariableInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/ui/TpUIInfo:1.0 */

static void decode_org_csapi_ui_TpUIInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cc/TpCallAdditionalErrorInfo:1.0 */

static void decode_org_csapi_cc_TpCallAdditionalErrorInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cc/TpCallLoadControlMechanism:1.0 */

static void decode_org_csapi_cc_TpCallLoadControlMechanism_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cc/TpCallAdditionalTreatmentInfo:1.0 */

static void decode_org_csapi_cc_TpCallAdditionalTreatmentInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cc/TpCallPartyToChargeAdditionalInfo:1.0 */

static void decode_org_csapi_cc_TpCallPartyToChargeAdditionalInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cc/gccs/TpCallAppInfo:1.0 */

static void decode_org_csapi_cc_gccs_TpCallAppInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cc/gccs/TpCallAdditionalReportInfo:1.0 */

static void decode_org_csapi_cc_gccs_TpCallAdditionalReportInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cc/gccs/TpCallAdditionalReportCriteria:1.0 */

static void decode_org_csapi_cc_gccs_TpCallAdditionalReportCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cc/TpCallAdditionalEventInfo:1.0 */

static void decode_org_csapi_cc_TpCallAdditionalEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cc/TpAdditionalCallEventCriteria:1.0 */

static void decode_org_csapi_cc_TpAdditionalCallEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cc/TpCallAppInfo:1.0 */

static void decode_org_csapi_cc_TpCallAppInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cc/mpccs/TpAppMultiPartyCallBack:1.0 */

static void decode_org_csapi_cc_mpccs_TpAppMultiPartyCallBack_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cc/mmccs/TpMediaStreamDataTypeRequest:1.0 */

static void decode_org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cc/mmccs/TpAppMultiMediaCallBack:1.0 */

static void decode_org_csapi_cc_mmccs_TpAppMultiMediaCallBack_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cc/cccs/TpConfPolicy:1.0 */

static void decode_org_csapi_cc_cccs_TpConfPolicy_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/ui/TpUITargetObject:1.0 */

static void decode_org_csapi_ui_TpUITargetObject_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/mm/TpBindingEntry:1.0 */

static void decode_org_csapi_mm_TpBindingEntry_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/dsc/TpDataSessionChargeOrder:1.0 */

static void decode_org_csapi_dsc_TpDataSessionChargeOrder_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/dsc/TpDataSessionAdditionalErrorInfo:1.0 */

static void decode_org_csapi_dsc_TpDataSessionAdditionalErrorInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/dsc/TpDataSessionAdditionalReportInfo:1.0 */

static void decode_org_csapi_dsc_TpDataSessionAdditionalReportInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/gms/TpMessageInfoProperty:1.0 */

static void decode_org_csapi_gms_TpMessageInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/gms/TpMailboxInfoProperty:1.0 */

static void decode_org_csapi_gms_TpMailboxInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/gms/TpMessagingEventInfo:1.0 */

static void decode_org_csapi_gms_TpMessagingEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/gms/TpMessagingEventCriteria:1.0 */

static void decode_org_csapi_gms_TpMessagingEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/gms/TpFolderInfoProperty:1.0 */

static void decode_org_csapi_gms_TpFolderInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cs/TpChargingParameterValue:1.0 */

static void decode_org_csapi_cs_TpChargingParameterValue_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/cs/TpAppInformation:1.0 */

static void decode_org_csapi_cs_TpAppInformation_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/policy/TpPolicyType:1.0 */

static void decode_org_csapi_policy_TpPolicyType_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/pam/TpPAMContextData:1.0 */

static void decode_org_csapi_pam_TpPAMContextData_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/pam/TpPAMEventInfo:1.0 */

static void decode_org_csapi_pam_TpPAMEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/pam/TpPAMNotificationInfo:1.0 */

static void decode_org_csapi_pam_TpPAMNotificationInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/pam/TpPAMPreferenceData:1.0 */

static void decode_org_csapi_pam_TpPAMPreferenceData_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/mmm/TpFolderInfoProperty:1.0 */

static void decode_org_csapi_mmm_TpFolderInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/mmm/TpMailboxInfoProperty:1.0 */

static void decode_org_csapi_mmm_TpMailboxInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/mmm/TpMessageInfoProperty:1.0 */

static void decode_org_csapi_mmm_TpMessageInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/mmm/TpMessageHeaderField:1.0 */

static void decode_org_csapi_mmm_TpMessageHeaderField_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/mmm/TpDeliveryTime:1.0 */

static void decode_org_csapi_mmm_TpDeliveryTime_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/mmm/TpMessageTreatment:1.0 */

static void decode_org_csapi_mmm_TpMessageTreatment_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/mmm/TpMessagingEventCriteria:1.0 */

static void decode_org_csapi_mmm_TpMessagingEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);




/* Union = IDL:org/csapi/mmm/TpMessagingEventInfo:1.0 */

static void decode_org_csapi_mmm_TpMessagingEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_);



/* Union prototype declaration End */



/* Initialise the protocol and subtree pointers */

static int proto_parlay = -1;

static gint ett_parlay = -1;


/* Initialise the initial Alignment */

static guint32  boundary = GIOP_HEADER_SIZE;  /* initial value */



/* Initialise the Registered fields */

/* TODO - Use registered fields */

/*
 * IDL Operations Start
 */
 
static const char org_csapi_IpService_setCallback_op[] = "setCallback" ;
static const char org_csapi_IpService_setCallbackWithSessionID_op[] = "setCallbackWithSessionID" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpInitial_initiateAuthentication_op[] = "initiateAuthentication" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpInitial_initiateAuthenticationWithVersion_op[] = "initiateAuthenticationWithVersion" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAuthentication_requestAccess_op[] = "requestAccess" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpClientAccess_terminateAccess_op[] = "terminateAccess" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAccess_obtainInterface_op[] = "obtainInterface" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAccess_obtainInterfaceWithCallback_op[] = "obtainInterfaceWithCallback" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAccess_endAccess_op[] = "endAccess" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAccess_listInterfaces_op[] = "listInterfaces" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAccess_releaseInterface_op[] = "releaseInterface" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAccess_selectSigningAlgorithm_op[] = "selectSigningAlgorithm" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAccess_terminateAccess_op[] = "terminateAccess" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAccess_relinquishInterface_op[] = "relinquishInterface" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_authenticate_op[] = "authenticate" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_abortAuthentication_op[] = "abortAuthentication" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_authenticationSucceeded_op[] = "authenticationSucceeded" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_challenge_op[] = "challenge" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_selectEncryptionMethod_op[] = "selectEncryptionMethod" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_authenticate_op[] = "authenticate" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_abortAuthentication_op[] = "abortAuthentication" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_authenticationSucceeded_op[] = "authenticationSucceeded" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_selectAuthenticationMechanism_op[] = "selectAuthenticationMechanism" ;
static const char org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_challenge_op[] = "challenge" ;
static const char org_csapi_fw_fw_application_notification_IpAppEventNotification_reportNotification_op[] = "reportNotification" ;
static const char org_csapi_fw_fw_application_notification_IpAppEventNotification_notificationTerminated_op[] = "notificationTerminated" ;
static const char org_csapi_fw_fw_application_notification_IpEventNotification_createNotification_op[] = "createNotification" ;
static const char org_csapi_fw_fw_application_notification_IpEventNotification_destroyNotification_op[] = "destroyNotification" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_activityTestRes_op[] = "activityTestRes" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_appActivityTestReq_op[] = "appActivityTestReq" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwFaultReportInd_op[] = "fwFaultReportInd" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwFaultRecoveryInd_op[] = "fwFaultRecoveryInd" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_svcUnavailableInd_op[] = "svcUnavailableInd" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordRes_op[] = "genFaultStatsRecordRes" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwUnavailableInd_op[] = "fwUnavailableInd" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_activityTestErr_op[] = "activityTestErr" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordErr_op[] = "genFaultStatsRecordErr" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_appUnavailableInd_op[] = "appUnavailableInd" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordReq_op[] = "genFaultStatsRecordReq" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_svcAvailStatusInd_op[] = "svcAvailStatusInd" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordRes_op[] = "generateFaultStatisticsRecordRes" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordErr_op[] = "generateFaultStatisticsRecordErr" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordReq_op[] = "generateFaultStatisticsRecordReq" ;
static const char org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwAvailStatusInd_op[] = "fwAvailStatusInd" ;
static const char org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryAppLoadReq_op[] = "queryAppLoadReq" ;
static const char org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadRes_op[] = "queryLoadRes" ;
static const char org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadErr_op[] = "queryLoadErr" ;
static const char org_csapi_fw_fw_application_integrity_IpAppLoadManager_loadLevelNotification_op[] = "loadLevelNotification" ;
static const char org_csapi_fw_fw_application_integrity_IpAppLoadManager_resumeNotification_op[] = "resumeNotification" ;
static const char org_csapi_fw_fw_application_integrity_IpAppLoadManager_suspendNotification_op[] = "suspendNotification" ;
static const char org_csapi_fw_fw_application_integrity_IpAppLoadManager_createLoadLevelNotification_op[] = "createLoadLevelNotification" ;
static const char org_csapi_fw_fw_application_integrity_IpAppLoadManager_destroyLoadLevelNotification_op[] = "destroyLoadLevelNotification" ;
static const char org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryAppLoadStatsReq_op[] = "queryAppLoadStatsReq" ;
static const char org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadStatsRes_op[] = "queryLoadStatsRes" ;
static const char org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadStatsErr_op[] = "queryLoadStatsErr" ;
static const char org_csapi_fw_fw_application_integrity_IpLoadManager_reportLoad_op[] = "reportLoad" ;
static const char org_csapi_fw_fw_application_integrity_IpLoadManager_queryLoadReq_op[] = "queryLoadReq" ;
static const char org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadRes_op[] = "queryAppLoadRes" ;
static const char org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadErr_op[] = "queryAppLoadErr" ;
static const char org_csapi_fw_fw_application_integrity_IpLoadManager_createLoadLevelNotification_op[] = "createLoadLevelNotification" ;
static const char org_csapi_fw_fw_application_integrity_IpLoadManager_destroyLoadLevelNotification_op[] = "destroyLoadLevelNotification" ;
static const char org_csapi_fw_fw_application_integrity_IpLoadManager_resumeNotification_op[] = "resumeNotification" ;
static const char org_csapi_fw_fw_application_integrity_IpLoadManager_suspendNotification_op[] = "suspendNotification" ;
static const char org_csapi_fw_fw_application_integrity_IpLoadManager_queryLoadStatsReq_op[] = "queryLoadStatsReq" ;
static const char org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadStatsRes_op[] = "queryAppLoadStatsRes" ;
static const char org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadStatsErr_op[] = "queryAppLoadStatsErr" ;
static const char org_csapi_fw_fw_application_integrity_IpAppOAM_systemDateTimeQuery_op[] = "systemDateTimeQuery" ;
static const char org_csapi_fw_fw_application_integrity_IpOAM_systemDateTimeQuery_op[] = "systemDateTimeQuery" ;
static const char org_csapi_fw_fw_application_integrity_IpFaultManager_activityTestReq_op[] = "activityTestReq" ;
static const char org_csapi_fw_fw_application_integrity_IpFaultManager_appActivityTestRes_op[] = "appActivityTestRes" ;
static const char org_csapi_fw_fw_application_integrity_IpFaultManager_svcUnavailableInd_op[] = "svcUnavailableInd" ;
static const char org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordReq_op[] = "genFaultStatsRecordReq" ;
static const char org_csapi_fw_fw_application_integrity_IpFaultManager_appActivityTestErr_op[] = "appActivityTestErr" ;
static const char org_csapi_fw_fw_application_integrity_IpFaultManager_appUnavailableInd_op[] = "appUnavailableInd" ;
static const char org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordRes_op[] = "genFaultStatsRecordRes" ;
static const char org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordErr_op[] = "genFaultStatsRecordErr" ;
static const char org_csapi_fw_fw_application_integrity_IpFaultManager_appAvailStatusInd_op[] = "appAvailStatusInd" ;
static const char org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordReq_op[] = "generateFaultStatisticsRecordReq" ;
static const char org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordRes_op[] = "generateFaultStatisticsRecordRes" ;
static const char org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordErr_op[] = "generateFaultStatisticsRecordErr" ;
static const char org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_enableHeartBeat_op[] = "enableHeartBeat" ;
static const char org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_disableHeartBeat_op[] = "disableHeartBeat" ;
static const char org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_changeInterval_op[] = "changeInterval" ;
static const char org_csapi_fw_fw_application_integrity_IpAppHeartBeat_pulse_op[] = "pulse" ;
static const char org_csapi_fw_fw_application_integrity_IpHeartBeat_pulse_op[] = "pulse" ;
static const char org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_enableAppHeartBeat_op[] = "enableAppHeartBeat" ;
static const char org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_disableAppHeartBeat_op[] = "disableAppHeartBeat" ;
static const char org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_changeInterval_op[] = "changeInterval" ;
static const char org_csapi_fw_fw_application_discovery_IpServiceDiscovery_listServiceTypes_op[] = "listServiceTypes" ;
static const char org_csapi_fw_fw_application_discovery_IpServiceDiscovery_describeServiceType_op[] = "describeServiceType" ;
static const char org_csapi_fw_fw_application_discovery_IpServiceDiscovery_discoverService_op[] = "discoverService" ;
static const char org_csapi_fw_fw_application_discovery_IpServiceDiscovery_listSubscribedServices_op[] = "listSubscribedServices" ;
static const char org_csapi_fw_fw_application_service_agreement_IpAppServiceAgreementManagement_signServiceAgreement_op[] = "signServiceAgreement" ;
static const char org_csapi_fw_fw_application_service_agreement_IpAppServiceAgreementManagement_terminateServiceAgreement_op[] = "terminateServiceAgreement" ;
static const char org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_signServiceAgreement_op[] = "signServiceAgreement" ;
static const char org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_terminateServiceAgreement_op[] = "terminateServiceAgreement" ;
static const char org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_selectService_op[] = "selectService" ;
static const char org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_initiateSignServiceAgreement_op[] = "initiateSignServiceAgreement" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_createServiceProfile_op[] = "createServiceProfile" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_modifyServiceProfile_op[] = "modifyServiceProfile" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_deleteServiceProfile_op[] = "deleteServiceProfile" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_assign_op[] = "assign" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_deassign_op[] = "deassign" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_requestConflictInfo_op[] = "requestConflictInfo" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_listServiceProfiles_op[] = "listServiceProfiles" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_describeServiceProfile_op[] = "describeServiceProfile" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_listAssignedMembers_op[] = "listAssignedMembers" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_createServiceContract_op[] = "createServiceContract" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_modifyServiceContract_op[] = "modifyServiceContract" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_deleteServiceContract_op[] = "deleteServiceContract" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_describeServiceContract_op[] = "describeServiceContract" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_listServiceContracts_op[] = "listServiceContracts" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_listServiceProfiles_op[] = "listServiceProfiles" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountManagement_modifyEntOpAccount_op[] = "modifyEntOpAccount" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountManagement_deleteEntOpAccount_op[] = "deleteEntOpAccount" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountInfoQuery_describeEntOpAccount_op[] = "describeEntOpAccount" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_createClientApp_op[] = "createClientApp" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_modifyClientApp_op[] = "modifyClientApp" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_deleteClientApp_op[] = "deleteClientApp" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_createSAG_op[] = "createSAG" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_modifySAG_op[] = "modifySAG" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_deleteSAG_op[] = "deleteSAG" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_addSAGMembers_op[] = "addSAGMembers" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_removeSAGMembers_op[] = "removeSAGMembers" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_requestConflictInfo_op[] = "requestConflictInfo" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_describeClientApp_op[] = "describeClientApp" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listClientApps_op[] = "listClientApps" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_describeSAG_op[] = "describeSAG" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listSAGs_op[] = "listSAGs" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listSAGMembers_op[] = "listSAGMembers" ;
static const char org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listClientAppMembership_op[] = "listClientAppMembership" ;
static const char org_csapi_fw_fw_enterprise_operator_notification_IpClientEventNotification_reportNotification_op[] = "reportNotification" ;
static const char org_csapi_fw_fw_enterprise_operator_notification_IpClientEventNotification_notificationTerminated_op[] = "notificationTerminated" ;
static const char org_csapi_fw_fw_enterprise_operator_notification_IpEventNotification_createNotification_op[] = "createNotification" ;
static const char org_csapi_fw_fw_enterprise_operator_notification_IpEventNotification_destroyNotification_op[] = "destroyNotification" ;
static const char org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_listServiceTypes_op[] = "listServiceTypes" ;
static const char org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_describeServiceType_op[] = "describeServiceType" ;
static const char org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_discoverService_op[] = "discoverService" ;
static const char org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_listRegisteredServices_op[] = "listRegisteredServices" ;
static const char org_csapi_fw_fw_service_service_lifecycle_IpServiceInstanceLifecycleManager_createServiceManager_op[] = "createServiceManager" ;
static const char org_csapi_fw_fw_service_service_lifecycle_IpServiceInstanceLifecycleManager_destroyServiceManager_op[] = "destroyServiceManager" ;
static const char org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_registerService_op[] = "registerService" ;
static const char org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_announceServiceAvailability_op[] = "announceServiceAvailability" ;
static const char org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_unregisterService_op[] = "unregisterService" ;
static const char org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_describeService_op[] = "describeService" ;
static const char org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_unannounceService_op[] = "unannounceService" ;
static const char org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_registerServiceSubType_op[] = "registerServiceSubType" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcLoadManager_querySvcLoadReq_op[] = "querySvcLoadReq" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadRes_op[] = "queryLoadRes" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadErr_op[] = "queryLoadErr" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcLoadManager_loadLevelNotification_op[] = "loadLevelNotification" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcLoadManager_suspendNotification_op[] = "suspendNotification" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcLoadManager_resumeNotification_op[] = "resumeNotification" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcLoadManager_createLoadLevelNotification_op[] = "createLoadLevelNotification" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcLoadManager_destroyLoadLevelNotification_op[] = "destroyLoadLevelNotification" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcLoadManager_querySvcLoadStatsReq_op[] = "querySvcLoadStatsReq" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadStatsRes_op[] = "queryLoadStatsRes" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadStatsErr_op[] = "queryLoadStatsErr" ;
static const char org_csapi_fw_fw_service_integrity_IpFwLoadManager_reportLoad_op[] = "reportLoad" ;
static const char org_csapi_fw_fw_service_integrity_IpFwLoadManager_queryLoadReq_op[] = "queryLoadReq" ;
static const char org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadRes_op[] = "querySvcLoadRes" ;
static const char org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadErr_op[] = "querySvcLoadErr" ;
static const char org_csapi_fw_fw_service_integrity_IpFwLoadManager_createLoadLevelNotification_op[] = "createLoadLevelNotification" ;
static const char org_csapi_fw_fw_service_integrity_IpFwLoadManager_destroyLoadLevelNotification_op[] = "destroyLoadLevelNotification" ;
static const char org_csapi_fw_fw_service_integrity_IpFwLoadManager_suspendNotification_op[] = "suspendNotification" ;
static const char org_csapi_fw_fw_service_integrity_IpFwLoadManager_resumeNotification_op[] = "resumeNotification" ;
static const char org_csapi_fw_fw_service_integrity_IpFwLoadManager_queryLoadStatsReq_op[] = "queryLoadStatsReq" ;
static const char org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadStatsRes_op[] = "querySvcLoadStatsRes" ;
static const char org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadStatsErr_op[] = "querySvcLoadStatsErr" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_activityTestRes_op[] = "activityTestRes" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_svcActivityTestReq_op[] = "svcActivityTestReq" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwFaultReportInd_op[] = "fwFaultReportInd" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwFaultRecoveryInd_op[] = "fwFaultRecoveryInd" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwUnavailableInd_op[] = "fwUnavailableInd" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_svcUnavailableInd_op[] = "svcUnavailableInd" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_appUnavailableInd_op[] = "appUnavailableInd" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordRes_op[] = "genFaultStatsRecordRes" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_activityTestErr_op[] = "activityTestErr" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordErr_op[] = "genFaultStatsRecordErr" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordReq_op[] = "genFaultStatsRecordReq" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatsRecordReq_op[] = "generateFaultStatsRecordReq" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_appAvailStatusInd_op[] = "appAvailStatusInd" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordRes_op[] = "generateFaultStatisticsRecordRes" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordErr_op[] = "generateFaultStatisticsRecordErr" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordReq_op[] = "generateFaultStatisticsRecordReq" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwAvailStatusInd_op[] = "fwAvailStatusInd" ;
static const char org_csapi_fw_fw_service_integrity_IpFwFaultManager_activityTestReq_op[] = "activityTestReq" ;
static const char org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcActivityTestRes_op[] = "svcActivityTestRes" ;
static const char org_csapi_fw_fw_service_integrity_IpFwFaultManager_appUnavailableInd_op[] = "appUnavailableInd" ;
static const char org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordReq_op[] = "genFaultStatsRecordReq" ;
static const char org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcUnavailableInd_op[] = "svcUnavailableInd" ;
static const char org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcActivityTestErr_op[] = "svcActivityTestErr" ;
static const char org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordRes_op[] = "genFaultStatsRecordRes" ;
static const char org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordErr_op[] = "genFaultStatsRecordErr" ;
static const char org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatsRecordRes_op[] = "generateFaultStatsRecordRes" ;
static const char org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatsRecordErr_op[] = "generateFaultStatsRecordErr" ;
static const char org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcAvailStatusInd_op[] = "svcAvailStatusInd" ;
static const char org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordReq_op[] = "generateFaultStatisticsRecordReq" ;
static const char org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordRes_op[] = "generateFaultStatisticsRecordRes" ;
static const char org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordErr_op[] = "generateFaultStatisticsRecordErr" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcOAM_systemDateTimeQuery_op[] = "systemDateTimeQuery" ;
static const char org_csapi_fw_fw_service_integrity_IpFwOAM_systemDateTimeQuery_op[] = "systemDateTimeQuery" ;
static const char org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_enableHeartBeat_op[] = "enableHeartBeat" ;
static const char org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_disableHeartBeat_op[] = "disableHeartBeat" ;
static const char org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_changeInterval_op[] = "changeInterval" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcHeartBeat_pulse_op[] = "pulse" ;
static const char org_csapi_fw_fw_service_integrity_IpFwHeartBeat_pulse_op[] = "pulse" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_enableSvcHeartBeat_op[] = "enableSvcHeartBeat" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_disableSvcHeartBeat_op[] = "disableSvcHeartBeat" ;
static const char org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_changeInterval_op[] = "changeInterval" ;
static const char org_csapi_fw_fw_service_notification_IpFwEventNotification_createNotification_op[] = "createNotification" ;
static const char org_csapi_fw_fw_service_notification_IpFwEventNotification_destroyNotification_op[] = "destroyNotification" ;
static const char org_csapi_fw_fw_service_notification_IpSvcEventNotification_reportNotification_op[] = "reportNotification" ;
static const char org_csapi_fw_fw_service_notification_IpSvcEventNotification_notificationTerminated_op[] = "notificationTerminated" ;
static const char org_csapi_cc_gccs_IpAppCall_routeRes_op[] = "routeRes" ;
static const char org_csapi_cc_gccs_IpAppCall_routeErr_op[] = "routeErr" ;
static const char org_csapi_cc_gccs_IpAppCall_getCallInfoRes_op[] = "getCallInfoRes" ;
static const char org_csapi_cc_gccs_IpAppCall_getCallInfoErr_op[] = "getCallInfoErr" ;
static const char org_csapi_cc_gccs_IpAppCall_superviseCallRes_op[] = "superviseCallRes" ;
static const char org_csapi_cc_gccs_IpAppCall_superviseCallErr_op[] = "superviseCallErr" ;
static const char org_csapi_cc_gccs_IpAppCall_callFaultDetected_op[] = "callFaultDetected" ;
static const char org_csapi_cc_gccs_IpAppCall_getMoreDialledDigitsRes_op[] = "getMoreDialledDigitsRes" ;
static const char org_csapi_cc_gccs_IpAppCall_getMoreDialledDigitsErr_op[] = "getMoreDialledDigitsErr" ;
static const char org_csapi_cc_gccs_IpAppCall_callEnded_op[] = "callEnded" ;
static const char org_csapi_cc_gccs_IpCall_routeReq_op[] = "routeReq" ;
static const char org_csapi_cc_gccs_IpCall_release_op[] = "release" ;
static const char org_csapi_cc_gccs_IpCall_deassignCall_op[] = "deassignCall" ;
static const char org_csapi_cc_gccs_IpCall_getCallInfoReq_op[] = "getCallInfoReq" ;
static const char org_csapi_cc_gccs_IpCall_setCallChargePlan_op[] = "setCallChargePlan" ;
static const char org_csapi_cc_gccs_IpCall_setAdviceOfCharge_op[] = "setAdviceOfCharge" ;
static const char org_csapi_cc_gccs_IpCall_getMoreDialledDigitsReq_op[] = "getMoreDialledDigitsReq" ;
static const char org_csapi_cc_gccs_IpCall_superviseCallReq_op[] = "superviseCallReq" ;
static const char org_csapi_cc_gccs_IpCall_continueProcessing_op[] = "continueProcessing" ;
static const char org_csapi_cc_gccs_IpAppCallControlManager_callAborted_op[] = "callAborted" ;
static const char org_csapi_cc_gccs_IpAppCallControlManager_callEventNotify_op[] = "callEventNotify" ;
static const char org_csapi_cc_gccs_IpAppCallControlManager_callNotificationInterrupted_op[] = "callNotificationInterrupted" ;
static const char org_csapi_cc_gccs_IpAppCallControlManager_callNotificationContinued_op[] = "callNotificationContinued" ;
static const char org_csapi_cc_gccs_IpAppCallControlManager_callOverloadEncountered_op[] = "callOverloadEncountered" ;
static const char org_csapi_cc_gccs_IpAppCallControlManager_callOverloadCeased_op[] = "callOverloadCeased" ;
static const char org_csapi_cc_gccs_IpAppCallControlManager_abortMultipleCalls_op[] = "abortMultipleCalls" ;
static const char org_csapi_cc_gccs_IpCallControlManager_createCall_op[] = "createCall" ;
static const char org_csapi_cc_gccs_IpCallControlManager_enableCallNotification_op[] = "enableCallNotification" ;
static const char org_csapi_cc_gccs_IpCallControlManager_disableCallNotification_op[] = "disableCallNotification" ;
static const char org_csapi_cc_gccs_IpCallControlManager_setCallLoadControl_op[] = "setCallLoadControl" ;
static const char org_csapi_cc_gccs_IpCallControlManager_changeCallNotification_op[] = "changeCallNotification" ;
static const char org_csapi_cc_gccs_IpCallControlManager_getCriteria_op[] = "getCriteria" ;
static const char org_csapi_cc_mpccs_IpAppCallLeg_eventReportRes_op[] = "eventReportRes" ;
static const char org_csapi_cc_mpccs_IpAppCallLeg_eventReportErr_op[] = "eventReportErr" ;
static const char org_csapi_cc_mpccs_IpAppCallLeg_attachMediaRes_op[] = "attachMediaRes" ;
static const char org_csapi_cc_mpccs_IpAppCallLeg_attachMediaErr_op[] = "attachMediaErr" ;
static const char org_csapi_cc_mpccs_IpAppCallLeg_detachMediaRes_op[] = "detachMediaRes" ;
static const char org_csapi_cc_mpccs_IpAppCallLeg_detachMediaErr_op[] = "detachMediaErr" ;
static const char org_csapi_cc_mpccs_IpAppCallLeg_getInfoRes_op[] = "getInfoRes" ;
static const char org_csapi_cc_mpccs_IpAppCallLeg_getInfoErr_op[] = "getInfoErr" ;
static const char org_csapi_cc_mpccs_IpAppCallLeg_routeErr_op[] = "routeErr" ;
static const char org_csapi_cc_mpccs_IpAppCallLeg_superviseRes_op[] = "superviseRes" ;
static const char org_csapi_cc_mpccs_IpAppCallLeg_superviseErr_op[] = "superviseErr" ;
static const char org_csapi_cc_mpccs_IpAppCallLeg_callLegEnded_op[] = "callLegEnded" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCallControlManager_createCall_op[] = "createCall" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCallControlManager_createNotification_op[] = "createNotification" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCallControlManager_destroyNotification_op[] = "destroyNotification" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCallControlManager_changeNotification_op[] = "changeNotification" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCallControlManager_getNotification_op[] = "getNotification" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCallControlManager_setCallLoadControl_op[] = "setCallLoadControl" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCallControlManager_enableNotifications_op[] = "enableNotifications" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCallControlManager_disableNotifications_op[] = "disableNotifications" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCallControlManager_getNextNotification_op[] = "getNextNotification" ;
static const char org_csapi_cc_mpccs_IpCallLeg_routeReq_op[] = "routeReq" ;
static const char org_csapi_cc_mpccs_IpCallLeg_eventReportReq_op[] = "eventReportReq" ;
static const char org_csapi_cc_mpccs_IpCallLeg_release_op[] = "release" ;
static const char org_csapi_cc_mpccs_IpCallLeg_getInfoReq_op[] = "getInfoReq" ;
static const char org_csapi_cc_mpccs_IpCallLeg_getCall_op[] = "getCall" ;
static const char org_csapi_cc_mpccs_IpCallLeg_attachMediaReq_op[] = "attachMediaReq" ;
static const char org_csapi_cc_mpccs_IpCallLeg_detachMediaReq_op[] = "detachMediaReq" ;
static const char org_csapi_cc_mpccs_IpCallLeg_getCurrentDestinationAddress_op[] = "getCurrentDestinationAddress" ;
static const char org_csapi_cc_mpccs_IpCallLeg_continueProcessing_op[] = "continueProcessing" ;
static const char org_csapi_cc_mpccs_IpCallLeg_setChargePlan_op[] = "setChargePlan" ;
static const char org_csapi_cc_mpccs_IpCallLeg_setAdviceOfCharge_op[] = "setAdviceOfCharge" ;
static const char org_csapi_cc_mpccs_IpCallLeg_superviseReq_op[] = "superviseReq" ;
static const char org_csapi_cc_mpccs_IpCallLeg_deassign_op[] = "deassign" ;
static const char org_csapi_cc_mpccs_IpCallLeg_getProperties_op[] = "getProperties" ;
static const char org_csapi_cc_mpccs_IpCallLeg_setProperties_op[] = "setProperties" ;
static const char org_csapi_cc_mpccs_IpAppMultiPartyCall_getInfoRes_op[] = "getInfoRes" ;
static const char org_csapi_cc_mpccs_IpAppMultiPartyCall_getInfoErr_op[] = "getInfoErr" ;
static const char org_csapi_cc_mpccs_IpAppMultiPartyCall_superviseRes_op[] = "superviseRes" ;
static const char org_csapi_cc_mpccs_IpAppMultiPartyCall_superviseErr_op[] = "superviseErr" ;
static const char org_csapi_cc_mpccs_IpAppMultiPartyCall_callEnded_op[] = "callEnded" ;
static const char org_csapi_cc_mpccs_IpAppMultiPartyCall_createAndRouteCallLegErr_op[] = "createAndRouteCallLegErr" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCall_getCallLegs_op[] = "getCallLegs" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCall_createCallLeg_op[] = "createCallLeg" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCall_createAndRouteCallLegReq_op[] = "createAndRouteCallLegReq" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCall_release_op[] = "release" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCall_deassignCall_op[] = "deassignCall" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCall_getInfoReq_op[] = "getInfoReq" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCall_setChargePlan_op[] = "setChargePlan" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCall_setAdviceOfCharge_op[] = "setAdviceOfCharge" ;
static const char org_csapi_cc_mpccs_IpMultiPartyCall_superviseReq_op[] = "superviseReq" ;
static const char org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_reportNotification_op[] = "reportNotification" ;
static const char org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callAborted_op[] = "callAborted" ;
static const char org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_managerInterrupted_op[] = "managerInterrupted" ;
static const char org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_managerResumed_op[] = "managerResumed" ;
static const char org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callOverloadEncountered_op[] = "callOverloadEncountered" ;
static const char org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callOverloadCeased_op[] = "callOverloadCeased" ;
static const char org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_abortMultipleCalls_op[] = "abortMultipleCalls" ;
static const char org_csapi_cc_mmccs_IpAppMultiMediaCall_superviseVolumeRes_op[] = "superviseVolumeRes" ;
static const char org_csapi_cc_mmccs_IpAppMultiMediaCall_superviseVolumeErr_op[] = "superviseVolumeErr" ;
static const char org_csapi_cc_mmccs_IpAppMultiMediaCallLeg_mediaStreamMonitorRes_op[] = "mediaStreamMonitorRes" ;
static const char org_csapi_cc_mmccs_IpMultiMediaStream_subtract_op[] = "subtract" ;
static const char org_csapi_cc_mmccs_IpMultiMediaCallLeg_mediaStreamAllow_op[] = "mediaStreamAllow" ;
static const char org_csapi_cc_mmccs_IpMultiMediaCallLeg_mediaStreamMonitorReq_op[] = "mediaStreamMonitorReq" ;
static const char org_csapi_cc_mmccs_IpMultiMediaCallLeg_getMediaStreams_op[] = "getMediaStreams" ;
static const char org_csapi_cc_mmccs_IpMultiMediaCall_superviseVolumeReq_op[] = "superviseVolumeReq" ;
static const char org_csapi_cc_mmccs_IpAppMultiMediaCallControlManager_reportMediaNotification_op[] = "reportMediaNotification" ;
static const char org_csapi_cc_mmccs_IpMultiMediaCallControlManager_createMediaNotification_op[] = "createMediaNotification" ;
static const char org_csapi_cc_mmccs_IpMultiMediaCallControlManager_destroyMediaNotification_op[] = "destroyMediaNotification" ;
static const char org_csapi_cc_mmccs_IpMultiMediaCallControlManager_changeMediaNotification_op[] = "changeMediaNotification" ;
static const char org_csapi_cc_mmccs_IpMultiMediaCallControlManager_getMediaNotification_op[] = "getMediaNotification" ;
static const char org_csapi_cc_cccs_IpAppSubConfCall_chairSelection_op[] = "chairSelection" ;
static const char org_csapi_cc_cccs_IpAppSubConfCall_floorRequest_op[] = "floorRequest" ;
static const char org_csapi_cc_cccs_IpAppConfCall_partyJoined_op[] = "partyJoined" ;
static const char org_csapi_cc_cccs_IpAppConfCall_leaveMonitorRes_op[] = "leaveMonitorRes" ;
static const char org_csapi_cc_cccs_IpConfCallControlManager_createConference_op[] = "createConference" ;
static const char org_csapi_cc_cccs_IpConfCallControlManager_checkResources_op[] = "checkResources" ;
static const char org_csapi_cc_cccs_IpConfCallControlManager_reserveResources_op[] = "reserveResources" ;
static const char org_csapi_cc_cccs_IpConfCallControlManager_freeResources_op[] = "freeResources" ;
static const char org_csapi_cc_cccs_IpAppConfCallControlManager_conferenceCreated_op[] = "conferenceCreated" ;
static const char org_csapi_cc_cccs_IpSubConfCall_splitSubConference_op[] = "splitSubConference" ;
static const char org_csapi_cc_cccs_IpSubConfCall_mergeSubConference_op[] = "mergeSubConference" ;
static const char org_csapi_cc_cccs_IpSubConfCall_moveCallLeg_op[] = "moveCallLeg" ;
static const char org_csapi_cc_cccs_IpSubConfCall_inspectVideo_op[] = "inspectVideo" ;
static const char org_csapi_cc_cccs_IpSubConfCall_inspectVideoCancel_op[] = "inspectVideoCancel" ;
static const char org_csapi_cc_cccs_IpSubConfCall_appointSpeaker_op[] = "appointSpeaker" ;
static const char org_csapi_cc_cccs_IpSubConfCall_chairSelection_op[] = "chairSelection" ;
static const char org_csapi_cc_cccs_IpSubConfCall_changeConferencePolicy_op[] = "changeConferencePolicy" ;
static const char org_csapi_cc_cccs_IpConfCall_getSubConferences_op[] = "getSubConferences" ;
static const char org_csapi_cc_cccs_IpConfCall_createSubConference_op[] = "createSubConference" ;
static const char org_csapi_cc_cccs_IpConfCall_leaveMonitorReq_op[] = "leaveMonitorReq" ;
static const char org_csapi_cc_cccs_IpConfCall_getConferenceAddress_op[] = "getConferenceAddress" ;
static const char org_csapi_ui_IpAppUI_sendInfoRes_op[] = "sendInfoRes" ;
static const char org_csapi_ui_IpAppUI_sendInfoErr_op[] = "sendInfoErr" ;
static const char org_csapi_ui_IpAppUI_sendInfoAndCollectRes_op[] = "sendInfoAndCollectRes" ;
static const char org_csapi_ui_IpAppUI_sendInfoAndCollectErr_op[] = "sendInfoAndCollectErr" ;
static const char org_csapi_ui_IpAppUI_userInteractionFaultDetected_op[] = "userInteractionFaultDetected" ;
static const char org_csapi_ui_IpAppUICall_recordMessageRes_op[] = "recordMessageRes" ;
static const char org_csapi_ui_IpAppUICall_recordMessageErr_op[] = "recordMessageErr" ;
static const char org_csapi_ui_IpAppUICall_deleteMessageRes_op[] = "deleteMessageRes" ;
static const char org_csapi_ui_IpAppUICall_deleteMessageErr_op[] = "deleteMessageErr" ;
static const char org_csapi_ui_IpAppUICall_abortActionRes_op[] = "abortActionRes" ;
static const char org_csapi_ui_IpAppUICall_abortActionErr_op[] = "abortActionErr" ;
static const char org_csapi_ui_IpAppUICall_getMessageRes_op[] = "getMessageRes" ;
static const char org_csapi_ui_IpAppUICall_getMessageErr_op[] = "getMessageErr" ;
static const char org_csapi_ui_IpAppUIManager_userInteractionAborted_op[] = "userInteractionAborted" ;
static const char org_csapi_ui_IpAppUIManager_userInteractionNotificationInterrupted_op[] = "userInteractionNotificationInterrupted" ;
static const char org_csapi_ui_IpAppUIManager_userInteractionNotificationContinued_op[] = "userInteractionNotificationContinued" ;
static const char org_csapi_ui_IpAppUIManager_reportEventNotification_op[] = "reportEventNotification" ;
static const char org_csapi_ui_IpAppUIManager_abortMultipleUserInteractions_op[] = "abortMultipleUserInteractions" ;
static const char org_csapi_ui_IpUI_sendInfoReq_op[] = "sendInfoReq" ;
static const char org_csapi_ui_IpUI_sendInfoAndCollectReq_op[] = "sendInfoAndCollectReq" ;
static const char org_csapi_ui_IpUI_release_op[] = "release" ;
static const char org_csapi_ui_IpUI_setOriginatingAddress_op[] = "setOriginatingAddress" ;
static const char org_csapi_ui_IpUI_getOriginatingAddress_op[] = "getOriginatingAddress" ;
static const char org_csapi_ui_IpUICall_recordMessageReq_op[] = "recordMessageReq" ;
static const char org_csapi_ui_IpUICall_deleteMessageReq_op[] = "deleteMessageReq" ;
static const char org_csapi_ui_IpUICall_abortActionReq_op[] = "abortActionReq" ;
static const char org_csapi_ui_IpUICall_getMessageReq_op[] = "getMessageReq" ;
static const char org_csapi_ui_IpUIManager_createUI_op[] = "createUI" ;
static const char org_csapi_ui_IpUIManager_createUICall_op[] = "createUICall" ;
static const char org_csapi_ui_IpUIManager_createNotification_op[] = "createNotification" ;
static const char org_csapi_ui_IpUIManager_destroyNotification_op[] = "destroyNotification" ;
static const char org_csapi_ui_IpUIManager_changeNotification_op[] = "changeNotification" ;
static const char org_csapi_ui_IpUIManager_getNotification_op[] = "getNotification" ;
static const char org_csapi_ui_IpUIManager_enableNotifications_op[] = "enableNotifications" ;
static const char org_csapi_ui_IpUIManager_disableNotifications_op[] = "disableNotifications" ;
static const char org_csapi_ui_IpAppUIAdminManager_getMessageRes_op[] = "getMessageRes" ;
static const char org_csapi_ui_IpAppUIAdminManager_getMessageErr_op[] = "getMessageErr" ;
static const char org_csapi_ui_IpAppUIAdminManager_deleteMessageRes_op[] = "deleteMessageRes" ;
static const char org_csapi_ui_IpAppUIAdminManager_deleteMessageErr_op[] = "deleteMessageErr" ;
static const char org_csapi_ui_IpAppUIAdminManager_putMessageRes_op[] = "putMessageRes" ;
static const char org_csapi_ui_IpAppUIAdminManager_putMessageErr_op[] = "putMessageErr" ;
static const char org_csapi_ui_IpAppUIAdminManager_getMessageListRes_op[] = "getMessageListRes" ;
static const char org_csapi_ui_IpAppUIAdminManager_getMessageListErr_op[] = "getMessageListErr" ;
static const char org_csapi_ui_IpUIAdminManager_getMessageReq_op[] = "getMessageReq" ;
static const char org_csapi_ui_IpUIAdminManager_putMessageReq_op[] = "putMessageReq" ;
static const char org_csapi_ui_IpUIAdminManager_deleteMessageReq_op[] = "deleteMessageReq" ;
static const char org_csapi_ui_IpUIAdminManager_getMessageListReq_op[] = "getMessageListReq" ;
static const char org_csapi_mm_ul_IpAppUserLocation_locationReportRes_op[] = "locationReportRes" ;
static const char org_csapi_mm_ul_IpAppUserLocation_locationReportErr_op[] = "locationReportErr" ;
static const char org_csapi_mm_ul_IpAppUserLocation_extendedLocationReportRes_op[] = "extendedLocationReportRes" ;
static const char org_csapi_mm_ul_IpAppUserLocation_extendedLocationReportErr_op[] = "extendedLocationReportErr" ;
static const char org_csapi_mm_ul_IpAppUserLocation_periodicLocationReport_op[] = "periodicLocationReport" ;
static const char org_csapi_mm_ul_IpAppUserLocation_periodicLocationReportErr_op[] = "periodicLocationReportErr" ;
static const char org_csapi_mm_ul_IpUserLocation_locationReportReq_op[] = "locationReportReq" ;
static const char org_csapi_mm_ul_IpUserLocation_extendedLocationReportReq_op[] = "extendedLocationReportReq" ;
static const char org_csapi_mm_ul_IpUserLocation_periodicLocationReportingStartReq_op[] = "periodicLocationReportingStartReq" ;
static const char org_csapi_mm_ul_IpUserLocation_periodicLocationReportingStop_op[] = "periodicLocationReportingStop" ;
static const char org_csapi_mm_ul_IpUserLocation_getNextPeriodicLocationRequest_op[] = "getNextPeriodicLocationRequest" ;
static const char org_csapi_mm_ul_IpAppTriggeredUserLocation_triggeredLocationReport_op[] = "triggeredLocationReport" ;
static const char org_csapi_mm_ul_IpAppTriggeredUserLocation_triggeredLocationReportErr_op[] = "triggeredLocationReportErr" ;
static const char org_csapi_mm_ul_IpTriggeredUserLocation_triggeredLocationReportingStartReq_op[] = "triggeredLocationReportingStartReq" ;
static const char org_csapi_mm_ul_IpTriggeredUserLocation_triggeredLocationReportingStop_op[] = "triggeredLocationReportingStop" ;
static const char org_csapi_mm_ul_IpTriggeredUserLocation_getNextTriggeredLocationRequest_op[] = "getNextTriggeredLocationRequest" ;
static const char org_csapi_mm_ulc_IpAppUserLocationCamel_locationReportRes_op[] = "locationReportRes" ;
static const char org_csapi_mm_ulc_IpAppUserLocationCamel_locationReportErr_op[] = "locationReportErr" ;
static const char org_csapi_mm_ulc_IpAppUserLocationCamel_periodicLocationReport_op[] = "periodicLocationReport" ;
static const char org_csapi_mm_ulc_IpAppUserLocationCamel_periodicLocationReportErr_op[] = "periodicLocationReportErr" ;
static const char org_csapi_mm_ulc_IpAppUserLocationCamel_triggeredLocationReport_op[] = "triggeredLocationReport" ;
static const char org_csapi_mm_ulc_IpAppUserLocationCamel_triggeredLocationReportErr_op[] = "triggeredLocationReportErr" ;
static const char org_csapi_mm_ulc_IpUserLocationCamel_locationReportReq_op[] = "locationReportReq" ;
static const char org_csapi_mm_ulc_IpUserLocationCamel_periodicLocationReportingStartReq_op[] = "periodicLocationReportingStartReq" ;
static const char org_csapi_mm_ulc_IpUserLocationCamel_periodicLocationReportingStop_op[] = "periodicLocationReportingStop" ;
static const char org_csapi_mm_ulc_IpUserLocationCamel_triggeredLocationReportingStartReq_op[] = "triggeredLocationReportingStartReq" ;
static const char org_csapi_mm_ulc_IpUserLocationCamel_triggeredLocationReportingStop_op[] = "triggeredLocationReportingStop" ;
static const char org_csapi_mm_ulc_IpUserLocationCamel_getNextPeriodicLocationRequest_op[] = "getNextPeriodicLocationRequest" ;
static const char org_csapi_mm_ulc_IpUserLocationCamel_getNextTriggeredLocationRequest_op[] = "getNextTriggeredLocationRequest" ;
static const char org_csapi_mm_ule_IpAppUserLocationEmergency_emergencyLocationReport_op[] = "emergencyLocationReport" ;
static const char org_csapi_mm_ule_IpAppUserLocationEmergency_emergencyLocationReportErr_op[] = "emergencyLocationReportErr" ;
static const char org_csapi_mm_ule_IpUserLocationEmergency_emergencyLocationReportReq_op[] = "emergencyLocationReportReq" ;
static const char org_csapi_mm_ule_IpUserLocationEmergency_subscribeEmergencyLocationReports_op[] = "subscribeEmergencyLocationReports" ;
static const char org_csapi_mm_ule_IpUserLocationEmergency_unSubscribeEmergencyLocationReports_op[] = "unSubscribeEmergencyLocationReports" ;
static const char org_csapi_mm_us_IpAppUserStatus_statusReportRes_op[] = "statusReportRes" ;
static const char org_csapi_mm_us_IpAppUserStatus_statusReportErr_op[] = "statusReportErr" ;
static const char org_csapi_mm_us_IpAppUserStatus_triggeredStatusReport_op[] = "triggeredStatusReport" ;
static const char org_csapi_mm_us_IpAppUserStatus_triggeredStatusReportErr_op[] = "triggeredStatusReportErr" ;
static const char org_csapi_mm_us_IpAppUserStatus_extendedStatusReportRes_op[] = "extendedStatusReportRes" ;
static const char org_csapi_mm_us_IpAppUserStatus_extendedStatusReportErr_op[] = "extendedStatusReportErr" ;
static const char org_csapi_mm_us_IpAppUserStatus_extTriggeredStatusReport_op[] = "extTriggeredStatusReport" ;
static const char org_csapi_mm_us_IpAppUserStatus_extTriggeredStatusReportErr_op[] = "extTriggeredStatusReportErr" ;
static const char org_csapi_mm_us_IpUserStatus_statusReportReq_op[] = "statusReportReq" ;
static const char org_csapi_mm_us_IpUserStatus_triggeredStatusReportingStartReq_op[] = "triggeredStatusReportingStartReq" ;
static const char org_csapi_mm_us_IpUserStatus_triggeredStatusReportingStop_op[] = "triggeredStatusReportingStop" ;
static const char org_csapi_mm_us_IpUserStatus_getNextTriggeredStatusRequest_op[] = "getNextTriggeredStatusRequest" ;
static const char org_csapi_mm_us_IpUserStatus_extendedStatusReportReq_op[] = "extendedStatusReportReq" ;
static const char org_csapi_mm_us_IpUserStatus_extTriggeredStatusReportingStartReq_op[] = "extTriggeredStatusReportingStartReq" ;
static const char org_csapi_mm_us_IpUserStatus_extTriggeredStatusReportingStop_op[] = "extTriggeredStatusReportingStop" ;
static const char org_csapi_mm_ub_IpAppUserBinding_triggeredBindingRequestNotification_op[] = "triggeredBindingRequestNotification" ;
static const char org_csapi_mm_ub_IpAppUserBinding_triggeredBindingRequestNotificationStartErr_op[] = "triggeredBindingRequestNotificationStartErr" ;
static const char org_csapi_mm_ub_IpUserBinding_triggeredBindingRequestNotificationStartReq_op[] = "triggeredBindingRequestNotificationStartReq" ;
static const char org_csapi_mm_ub_IpUserBinding_triggeredBindingRequestNotificationStop_op[] = "triggeredBindingRequestNotificationStop" ;
static const char org_csapi_termcap_IpTerminalCapabilities_getTerminalCapabilities_op[] = "getTerminalCapabilities" ;
static const char org_csapi_termcap_IpAppExtendedTerminalCapabilities_triggeredTerminalCapabilityReport_op[] = "triggeredTerminalCapabilityReport" ;
static const char org_csapi_termcap_IpAppExtendedTerminalCapabilities_triggeredTerminalCapabilityReportErr_op[] = "triggeredTerminalCapabilityReportErr" ;
static const char org_csapi_termcap_IpExtendedTerminalCapabilities_triggeredTerminalCapabilityStartReq_op[] = "triggeredTerminalCapabilityStartReq" ;
static const char org_csapi_termcap_IpExtendedTerminalCapabilities_triggeredTerminalCapabilityStop_op[] = "triggeredTerminalCapabilityStop" ;
static const char org_csapi_dsc_IpAppDataSession_connectRes_op[] = "connectRes" ;
static const char org_csapi_dsc_IpAppDataSession_connectErr_op[] = "connectErr" ;
static const char org_csapi_dsc_IpAppDataSession_superviseDataSessionRes_op[] = "superviseDataSessionRes" ;
static const char org_csapi_dsc_IpAppDataSession_superviseDataSessionErr_op[] = "superviseDataSessionErr" ;
static const char org_csapi_dsc_IpAppDataSession_dataSessionFaultDetected_op[] = "dataSessionFaultDetected" ;
static const char org_csapi_dsc_IpAppDataSessionControlManager_dataSessionAborted_op[] = "dataSessionAborted" ;
static const char org_csapi_dsc_IpAppDataSessionControlManager_reportNotification_op[] = "reportNotification" ;
static const char org_csapi_dsc_IpAppDataSessionControlManager_dataSessionNotificationContinued_op[] = "dataSessionNotificationContinued" ;
static const char org_csapi_dsc_IpAppDataSessionControlManager_dataSessionNotificationInterrupted_op[] = "dataSessionNotificationInterrupted" ;
static const char org_csapi_dsc_IpAppDataSessionControlManager_abortMultipleDataSessions_op[] = "abortMultipleDataSessions" ;
static const char org_csapi_dsc_IpDataSession_connectReq_op[] = "connectReq" ;
static const char org_csapi_dsc_IpDataSession_release_op[] = "release" ;
static const char org_csapi_dsc_IpDataSession_superviseDataSessionReq_op[] = "superviseDataSessionReq" ;
static const char org_csapi_dsc_IpDataSession_setDataSessionChargePlan_op[] = "setDataSessionChargePlan" ;
static const char org_csapi_dsc_IpDataSession_setAdviceOfCharge_op[] = "setAdviceOfCharge" ;
static const char org_csapi_dsc_IpDataSession_deassignDataSession_op[] = "deassignDataSession" ;
static const char org_csapi_dsc_IpDataSession_continueProcessing_op[] = "continueProcessing" ;
static const char org_csapi_dsc_IpDataSessionControlManager_createNotification_op[] = "createNotification" ;
static const char org_csapi_dsc_IpDataSessionControlManager_destroyNotification_op[] = "destroyNotification" ;
static const char org_csapi_dsc_IpDataSessionControlManager_changeNotification_op[] = "changeNotification" ;
static const char org_csapi_dsc_IpDataSessionControlManager_enableNotifications_op[] = "enableNotifications" ;
static const char org_csapi_dsc_IpDataSessionControlManager_disableNotifications_op[] = "disableNotifications" ;
static const char org_csapi_dsc_IpDataSessionControlManager_getNotifications_op[] = "getNotifications" ;
static const char org_csapi_dsc_IpDataSessionControlManager_createNotifications_op[] = "createNotifications" ;
static const char org_csapi_gms_IpMessagingManager_openMailbox_op[] = "openMailbox" ;
static const char org_csapi_gms_IpMessagingManager_enableMessagingNotification_op[] = "enableMessagingNotification" ;
static const char org_csapi_gms_IpMessagingManager_disableMessagingNotification_op[] = "disableMessagingNotification" ;
static const char org_csapi_gms_IpAppMessagingManager_mailboxTerminated_op[] = "mailboxTerminated" ;
static const char org_csapi_gms_IpAppMessagingManager_mailboxFaultDetected_op[] = "mailboxFaultDetected" ;
static const char org_csapi_gms_IpAppMessagingManager_messagingEventNotify_op[] = "messagingEventNotify" ;
static const char org_csapi_gms_IpAppMessagingManager_messagingNotificationTerminated_op[] = "messagingNotificationTerminated" ;
static const char org_csapi_gms_IpMailbox_close_op[] = "close" ;
static const char org_csapi_gms_IpMailbox_lock_op[] = "lock" ;
static const char org_csapi_gms_IpMailbox_unlock_op[] = "unlock" ;
static const char org_csapi_gms_IpMailbox_getInfoAmount_op[] = "getInfoAmount" ;
static const char org_csapi_gms_IpMailbox_getInfoProperties_op[] = "getInfoProperties" ;
static const char org_csapi_gms_IpMailbox_setInfoProperties_op[] = "setInfoProperties" ;
static const char org_csapi_gms_IpMailbox_openFolder_op[] = "openFolder" ;
static const char org_csapi_gms_IpMailbox_createFolder_op[] = "createFolder" ;
static const char org_csapi_gms_IpMailbox_remove_op[] = "remove" ;
static const char org_csapi_gms_IpMessage_getInfoAmount_op[] = "getInfoAmount" ;
static const char org_csapi_gms_IpMessage_getInfoProperties_op[] = "getInfoProperties" ;
static const char org_csapi_gms_IpMessage_setInfoProperties_op[] = "setInfoProperties" ;
static const char org_csapi_gms_IpMessage_remove_op[] = "remove" ;
static const char org_csapi_gms_IpMessage_getContent_op[] = "getContent" ;
static const char org_csapi_gms_IpMailboxFolder_getInfoAmount_op[] = "getInfoAmount" ;
static const char org_csapi_gms_IpMailboxFolder_getInfoProperties_op[] = "getInfoProperties" ;
static const char org_csapi_gms_IpMailboxFolder_setInfoProperties_op[] = "setInfoProperties" ;
static const char org_csapi_gms_IpMailboxFolder_putMessage_op[] = "putMessage" ;
static const char org_csapi_gms_IpMailboxFolder_getMessage_op[] = "getMessage" ;
static const char org_csapi_gms_IpMailboxFolder_close_op[] = "close" ;
static const char org_csapi_gms_IpMailboxFolder_remove_op[] = "remove" ;
static const char org_csapi_cm_IpVPrP_getVPrPID_op[] = "getVPrPID" ;
static const char org_csapi_cm_IpVPrP_getSlaID_op[] = "getSlaID" ;
static const char org_csapi_cm_IpVPrP_getStatus_op[] = "getStatus" ;
static const char org_csapi_cm_IpVPrP_getProvisionedQoSInfo_op[] = "getProvisionedQoSInfo" ;
static const char org_csapi_cm_IpVPrP_getValidityInfo_op[] = "getValidityInfo" ;
static const char org_csapi_cm_IpVPrP_getPipeQoSInfo_op[] = "getPipeQoSInfo" ;
static const char org_csapi_cm_IpVPrP_getDsCodepoint_op[] = "getDsCodepoint" ;
static const char org_csapi_cm_IpVPrN_getVPrPList_op[] = "getVPrPList" ;
static const char org_csapi_cm_IpVPrN_getVPrP_op[] = "getVPrP" ;
static const char org_csapi_cm_IpVPrN_createVPrP_op[] = "createVPrP" ;
static const char org_csapi_cm_IpVPrN_deleteVPrP_op[] = "deleteVPrP" ;
static const char org_csapi_cm_IpQoSMenu_getTemplate_op[] = "getTemplate" ;
static const char org_csapi_cm_IpQoSMenu_getTemplateList_op[] = "getTemplateList" ;
static const char org_csapi_cm_IpConnectivityManager_getQoSMenu_op[] = "getQoSMenu" ;
static const char org_csapi_cm_IpConnectivityManager_getEnterpriseNetwork_op[] = "getEnterpriseNetwork" ;
static const char org_csapi_cm_IpQoSTemplate_getTemplateType_op[] = "getTemplateType" ;
static const char org_csapi_cm_IpQoSTemplate_getDescription_op[] = "getDescription" ;
static const char org_csapi_cm_IpQoSTemplate_setSlaID_op[] = "setSlaID" ;
static const char org_csapi_cm_IpQoSTemplate_getPipeQoSInfo_op[] = "getPipeQoSInfo" ;
static const char org_csapi_cm_IpQoSTemplate_setPipeQoSInfo_op[] = "setPipeQoSInfo" ;
static const char org_csapi_cm_IpQoSTemplate_getValidityInfo_op[] = "getValidityInfo" ;
static const char org_csapi_cm_IpQoSTemplate_setValidityInfo_op[] = "setValidityInfo" ;
static const char org_csapi_cm_IpQoSTemplate_setProvisionedQoSInfo_op[] = "setProvisionedQoSInfo" ;
static const char org_csapi_cm_IpQoSTemplate_getProvisionedQoSInfo_op[] = "getProvisionedQoSInfo" ;
static const char org_csapi_cm_IpQoSTemplate_getDsCodepoint_op[] = "getDsCodepoint" ;
static const char org_csapi_cm_IpEnterpriseNetwork_getSiteList_op[] = "getSiteList" ;
static const char org_csapi_cm_IpEnterpriseNetwork_getVPrN_op[] = "getVPrN" ;
static const char org_csapi_cm_IpEnterpriseNetwork_getSite_op[] = "getSite" ;
static const char org_csapi_cm_IpEnterpriseNetworkSite_getSAPList_op[] = "getSAPList" ;
static const char org_csapi_cm_IpEnterpriseNetworkSite_getSiteID_op[] = "getSiteID" ;
static const char org_csapi_cm_IpEnterpriseNetworkSite_getSiteLocation_op[] = "getSiteLocation" ;
static const char org_csapi_cm_IpEnterpriseNetworkSite_getSiteDescription_op[] = "getSiteDescription" ;
static const char org_csapi_cm_IpEnterpriseNetworkSite_getIPSubnet_op[] = "getIPSubnet" ;
static const char org_csapi_cm_IpEnterpriseNetworkSite_getSAPIPSubnet_op[] = "getSAPIPSubnet" ;
static const char org_csapi_am_IpAppAccountManager_reportNotification_op[] = "reportNotification" ;
static const char org_csapi_am_IpAppAccountManager_queryBalanceRes_op[] = "queryBalanceRes" ;
static const char org_csapi_am_IpAppAccountManager_queryBalanceErr_op[] = "queryBalanceErr" ;
static const char org_csapi_am_IpAppAccountManager_retrieveTransactionHistoryRes_op[] = "retrieveTransactionHistoryRes" ;
static const char org_csapi_am_IpAppAccountManager_retrieveTransactionHistoryErr_op[] = "retrieveTransactionHistoryErr" ;
static const char org_csapi_am_IpAppAccountManager_queryBalanceExpiryDateRes_op[] = "queryBalanceExpiryDateRes" ;
static const char org_csapi_am_IpAppAccountManager_queryBalanceExpiryDateErr_op[] = "queryBalanceExpiryDateErr" ;
static const char org_csapi_am_IpAppAccountManager_updateBalanceRes_op[] = "updateBalanceRes" ;
static const char org_csapi_am_IpAppAccountManager_updateBalanceErr_op[] = "updateBalanceErr" ;
static const char org_csapi_am_IpAppAccountManager_createVoucherRes_op[] = "createVoucherRes" ;
static const char org_csapi_am_IpAppAccountManager_createVoucherErr_op[] = "createVoucherErr" ;
static const char org_csapi_am_IpAppAccountManager_destroyVoucherRes_op[] = "destroyVoucherRes" ;
static const char org_csapi_am_IpAppAccountManager_destroyVoucherErr_op[] = "destroyVoucherErr" ;
static const char org_csapi_am_IpAppAccountManager_queryVoucherRes_op[] = "queryVoucherRes" ;
static const char org_csapi_am_IpAppAccountManager_queryVoucherErr_op[] = "queryVoucherErr" ;
static const char org_csapi_am_IpAppAccountManager_queryUserVouchersRes_op[] = "queryUserVouchersRes" ;
static const char org_csapi_am_IpAppAccountManager_queryUserVouchersErr_op[] = "queryUserVouchersErr" ;
static const char org_csapi_am_IpAccountManager_createNotification_op[] = "createNotification" ;
static const char org_csapi_am_IpAccountManager_destroyNotification_op[] = "destroyNotification" ;
static const char org_csapi_am_IpAccountManager_queryBalanceReq_op[] = "queryBalanceReq" ;
static const char org_csapi_am_IpAccountManager_changeNotification_op[] = "changeNotification" ;
static const char org_csapi_am_IpAccountManager_getNotification_op[] = "getNotification" ;
static const char org_csapi_am_IpAccountManager_retrieveTransactionHistoryReq_op[] = "retrieveTransactionHistoryReq" ;
static const char org_csapi_am_IpAccountManager_enableNotifications_op[] = "enableNotifications" ;
static const char org_csapi_am_IpAccountManager_disableNotifications_op[] = "disableNotifications" ;
static const char org_csapi_am_IpAccountManager_queryBalanceExpiryDateReq_op[] = "queryBalanceExpiryDateReq" ;
static const char org_csapi_am_IpAccountManager_updateBalanceReq_op[] = "updateBalanceReq" ;
static const char org_csapi_am_IpAccountManager_createVoucherReq_op[] = "createVoucherReq" ;
static const char org_csapi_am_IpAccountManager_destroyVoucherReq_op[] = "destroyVoucherReq" ;
static const char org_csapi_am_IpAccountManager_queryVoucherReq_op[] = "queryVoucherReq" ;
static const char org_csapi_am_IpAccountManager_queryUserVouchersReq_op[] = "queryUserVouchersReq" ;
static const char org_csapi_cs_IpAppChargingSession_creditAmountErr_op[] = "creditAmountErr" ;
static const char org_csapi_cs_IpAppChargingSession_creditAmountRes_op[] = "creditAmountRes" ;
static const char org_csapi_cs_IpAppChargingSession_creditUnitErr_op[] = "creditUnitErr" ;
static const char org_csapi_cs_IpAppChargingSession_creditUnitRes_op[] = "creditUnitRes" ;
static const char org_csapi_cs_IpAppChargingSession_debitAmountErr_op[] = "debitAmountErr" ;
static const char org_csapi_cs_IpAppChargingSession_debitAmountRes_op[] = "debitAmountRes" ;
static const char org_csapi_cs_IpAppChargingSession_debitUnitErr_op[] = "debitUnitErr" ;
static const char org_csapi_cs_IpAppChargingSession_debitUnitRes_op[] = "debitUnitRes" ;
static const char org_csapi_cs_IpAppChargingSession_directCreditAmountErr_op[] = "directCreditAmountErr" ;
static const char org_csapi_cs_IpAppChargingSession_directCreditAmountRes_op[] = "directCreditAmountRes" ;
static const char org_csapi_cs_IpAppChargingSession_directCreditUnitErr_op[] = "directCreditUnitErr" ;
static const char org_csapi_cs_IpAppChargingSession_directCreditUnitRes_op[] = "directCreditUnitRes" ;
static const char org_csapi_cs_IpAppChargingSession_directDebitAmountErr_op[] = "directDebitAmountErr" ;
static const char org_csapi_cs_IpAppChargingSession_directDebitAmountRes_op[] = "directDebitAmountRes" ;
static const char org_csapi_cs_IpAppChargingSession_directDebitUnitErr_op[] = "directDebitUnitErr" ;
static const char org_csapi_cs_IpAppChargingSession_directDebitUnitRes_op[] = "directDebitUnitRes" ;
static const char org_csapi_cs_IpAppChargingSession_extendLifeTimeErr_op[] = "extendLifeTimeErr" ;
static const char org_csapi_cs_IpAppChargingSession_extendLifeTimeRes_op[] = "extendLifeTimeRes" ;
static const char org_csapi_cs_IpAppChargingSession_rateErr_op[] = "rateErr" ;
static const char org_csapi_cs_IpAppChargingSession_rateRes_op[] = "rateRes" ;
static const char org_csapi_cs_IpAppChargingSession_reserveAmountErr_op[] = "reserveAmountErr" ;
static const char org_csapi_cs_IpAppChargingSession_reserveAmountRes_op[] = "reserveAmountRes" ;
static const char org_csapi_cs_IpAppChargingSession_reserveUnitErr_op[] = "reserveUnitErr" ;
static const char org_csapi_cs_IpAppChargingSession_reserveUnitRes_op[] = "reserveUnitRes" ;
static const char org_csapi_cs_IpAppChargingSession_sessionEnded_op[] = "sessionEnded" ;
static const char org_csapi_cs_IpChargingSession_creditAmountReq_op[] = "creditAmountReq" ;
static const char org_csapi_cs_IpChargingSession_creditUnitReq_op[] = "creditUnitReq" ;
static const char org_csapi_cs_IpChargingSession_debitAmountReq_op[] = "debitAmountReq" ;
static const char org_csapi_cs_IpChargingSession_debitUnitReq_op[] = "debitUnitReq" ;
static const char org_csapi_cs_IpChargingSession_directCreditAmountReq_op[] = "directCreditAmountReq" ;
static const char org_csapi_cs_IpChargingSession_directCreditUnitReq_op[] = "directCreditUnitReq" ;
static const char org_csapi_cs_IpChargingSession_directDebitAmountReq_op[] = "directDebitAmountReq" ;
static const char org_csapi_cs_IpChargingSession_directDebitUnitReq_op[] = "directDebitUnitReq" ;
static const char org_csapi_cs_IpChargingSession_extendLifeTimeReq_op[] = "extendLifeTimeReq" ;
static const char org_csapi_cs_IpChargingSession_getAmountLeft_op[] = "getAmountLeft" ;
static const char org_csapi_cs_IpChargingSession_getLifeTimeLeft_op[] = "getLifeTimeLeft" ;
static const char org_csapi_cs_IpChargingSession_getUnitLeft_op[] = "getUnitLeft" ;
static const char org_csapi_cs_IpChargingSession_rateReq_op[] = "rateReq" ;
static const char org_csapi_cs_IpChargingSession_release_op[] = "release" ;
static const char org_csapi_cs_IpChargingSession_reserveAmountReq_op[] = "reserveAmountReq" ;
static const char org_csapi_cs_IpChargingSession_reserveUnitReq_op[] = "reserveUnitReq" ;
static const char org_csapi_cs_IpAppChargingManager_sessionAborted_op[] = "sessionAborted" ;
static const char org_csapi_cs_IpAppChargingManager_abortMultipleChargingSessions_op[] = "abortMultipleChargingSessions" ;
static const char org_csapi_cs_IpChargingManager_createChargingSession_op[] = "createChargingSession" ;
static const char org_csapi_cs_IpChargingManager_createSplitChargingSession_op[] = "createSplitChargingSession" ;
static const char org_csapi_policy_evaluation_IpAppPolicyDomain_reportNotification_op[] = "reportNotification" ;
static const char org_csapi_policy_evaluation_IpAppPolicyDomain_evalPolicyRes_op[] = "evalPolicyRes" ;
static const char org_csapi_policy_evaluation_IpAppPolicyDomain_evalPolicyErr_op[] = "evalPolicyErr" ;
static const char org_csapi_policy_evaluation_IpPolicyEvalManager_evalPolicy_op[] = "evalPolicy" ;
static const char org_csapi_policy_evaluation_IpPolicyEvalManager_evalPolicyReq_op[] = "evalPolicyReq" ;
static const char org_csapi_policy_evaluation_IpPolicyEvalManager_abortEvalPolicyReq_op[] = "abortEvalPolicyReq" ;
static const char org_csapi_policy_evaluation_IpPolicyEvalManager_generateEvent_op[] = "generateEvent" ;
static const char org_csapi_policy_evaluation_IpPolicyEvalManager_createNotification_op[] = "createNotification" ;
static const char org_csapi_policy_evaluation_IpPolicyEvalManager_destroyNotification_op[] = "destroyNotification" ;
static const char org_csapi_policy_provisioning_IpPolicy_getAttribute_op[] = "getAttribute" ;
static const char org_csapi_policy_provisioning_IpPolicy_setAttribute_op[] = "setAttribute" ;
static const char org_csapi_policy_provisioning_IpPolicy_getAttributes_op[] = "getAttributes" ;
static const char org_csapi_policy_provisioning_IpPolicy_setAttributes_op[] = "setAttributes" ;
static const char org_csapi_policy_provisioning_IpPolicyIterator_getList_op[] = "getList" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_getParentRepository_op[] = "getParentRepository" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_createRepository_op[] = "createRepository" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_getRepository_op[] = "getRepository" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_removeRepository_op[] = "removeRepository" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_getRepositoryCount_op[] = "getRepositoryCount" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_getRepositoryIterator_op[] = "getRepositoryIterator" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_createCondition_op[] = "createCondition" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_getCondition_op[] = "getCondition" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_removeCondition_op[] = "removeCondition" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_getConditionCount_op[] = "getConditionCount" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_getConditionIterator_op[] = "getConditionIterator" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_createAction_op[] = "createAction" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_getAction_op[] = "getAction" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_removeAction_op[] = "removeAction" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_getActionCount_op[] = "getActionCount" ;
static const char org_csapi_policy_provisioning_IpPolicyRepository_getActionIterator_op[] = "getActionIterator" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_getParentGroup_op[] = "getParentGroup" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_getParentDomain_op[] = "getParentDomain" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_createCondition_op[] = "createCondition" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_getCondition_op[] = "getCondition" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_removeCondition_op[] = "removeCondition" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_getConditionCount_op[] = "getConditionCount" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_getConditionIterator_op[] = "getConditionIterator" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_createAction_op[] = "createAction" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_getAction_op[] = "getAction" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_removeAction_op[] = "removeAction" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_getActionCount_op[] = "getActionCount" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_getActionIterator_op[] = "getActionIterator" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_setValidityPeriodConditionByName_op[] = "setValidityPeriodConditionByName" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_setValidityPeriodCondition_op[] = "setValidityPeriodCondition" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_getValidityPeriodCondition_op[] = "getValidityPeriodCondition" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_unsetValidityPeriodCondition_op[] = "unsetValidityPeriodCondition" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_setConditionList_op[] = "setConditionList" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_getConditionList_op[] = "getConditionList" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_setActionList_op[] = "setActionList" ;
static const char org_csapi_policy_provisioning_IpPolicyRule_getActionList_op[] = "getActionList" ;
static const char org_csapi_policy_provisioning_IpPolicyManager_createDomain_op[] = "createDomain" ;
static const char org_csapi_policy_provisioning_IpPolicyManager_getDomain_op[] = "getDomain" ;
static const char org_csapi_policy_provisioning_IpPolicyManager_removeDomain_op[] = "removeDomain" ;
static const char org_csapi_policy_provisioning_IpPolicyManager_getDomainCount_op[] = "getDomainCount" ;
static const char org_csapi_policy_provisioning_IpPolicyManager_getDomainIterator_op[] = "getDomainIterator" ;
static const char org_csapi_policy_provisioning_IpPolicyManager_findMatchingDomains_op[] = "findMatchingDomains" ;
static const char org_csapi_policy_provisioning_IpPolicyManager_createRepository_op[] = "createRepository" ;
static const char org_csapi_policy_provisioning_IpPolicyManager_getRepository_op[] = "getRepository" ;
static const char org_csapi_policy_provisioning_IpPolicyManager_removeRepository_op[] = "removeRepository" ;
static const char org_csapi_policy_provisioning_IpPolicyManager_getRepositoryCount_op[] = "getRepositoryCount" ;
static const char org_csapi_policy_provisioning_IpPolicyManager_getRepositoryIterator_op[] = "getRepositoryIterator" ;
static const char org_csapi_policy_provisioning_IpPolicyManager_startTransaction_op[] = "startTransaction" ;
static const char org_csapi_policy_provisioning_IpPolicyManager_commitTransaction_op[] = "commitTransaction" ;
static const char org_csapi_policy_provisioning_IpPolicyManager_abortTransaction_op[] = "abortTransaction" ;
static const char org_csapi_policy_provisioning_IpPolicyGroup_getParentDomain_op[] = "getParentDomain" ;
static const char org_csapi_policy_provisioning_IpPolicyGroup_getParentGroup_op[] = "getParentGroup" ;
static const char org_csapi_policy_provisioning_IpPolicyGroup_createGroup_op[] = "createGroup" ;
static const char org_csapi_policy_provisioning_IpPolicyGroup_getGroup_op[] = "getGroup" ;
static const char org_csapi_policy_provisioning_IpPolicyGroup_removeGroup_op[] = "removeGroup" ;
static const char org_csapi_policy_provisioning_IpPolicyGroup_getGroupCount_op[] = "getGroupCount" ;
static const char org_csapi_policy_provisioning_IpPolicyGroup_getGroupIterator_op[] = "getGroupIterator" ;
static const char org_csapi_policy_provisioning_IpPolicyGroup_createRule_op[] = "createRule" ;
static const char org_csapi_policy_provisioning_IpPolicyGroup_getRule_op[] = "getRule" ;
static const char org_csapi_policy_provisioning_IpPolicyGroup_removeRule_op[] = "removeRule" ;
static const char org_csapi_policy_provisioning_IpPolicyGroup_getRuleCount_op[] = "getRuleCount" ;
static const char org_csapi_policy_provisioning_IpPolicyGroup_getRuleIterator_op[] = "getRuleIterator" ;
static const char org_csapi_policy_provisioning_IpPolicyEventDefinition_setRequiredAttributes_op[] = "setRequiredAttributes" ;
static const char org_csapi_policy_provisioning_IpPolicyEventDefinition_setOptionalAttributes_op[] = "setOptionalAttributes" ;
static const char org_csapi_policy_provisioning_IpPolicyEventDefinition_getRequiredAttributes_op[] = "getRequiredAttributes" ;
static const char org_csapi_policy_provisioning_IpPolicyEventDefinition_getOptionalAttributes_op[] = "getOptionalAttributes" ;
static const char org_csapi_policy_provisioning_IpPolicyEventDefinition_getParentDomain_op[] = "getParentDomain" ;
static const char org_csapi_policy_provisioning_IpPolicyCondition_getParentRepository_op[] = "getParentRepository" ;
static const char org_csapi_policy_provisioning_IpPolicyCondition_getParentRule_op[] = "getParentRule" ;
static const char org_csapi_policy_provisioning_IpPolicyAction_getParentRepository_op[] = "getParentRepository" ;
static const char org_csapi_policy_provisioning_IpPolicyAction_getParentRule_op[] = "getParentRule" ;
static const char org_csapi_policy_provisioning_IpPolicySignature_setInputVariables_op[] = "setInputVariables" ;
static const char org_csapi_policy_provisioning_IpPolicySignature_setOutputVariables_op[] = "setOutputVariables" ;
static const char org_csapi_policy_provisioning_IpPolicySignature_getInputVariables_op[] = "getInputVariables" ;
static const char org_csapi_policy_provisioning_IpPolicySignature_getOutputVariables_op[] = "getOutputVariables" ;
static const char org_csapi_policy_provisioning_IpPolicySignature_setGroupNames_op[] = "setGroupNames" ;
static const char org_csapi_policy_provisioning_IpPolicySignature_setPolicyRoles_op[] = "setPolicyRoles" ;
static const char org_csapi_policy_provisioning_IpPolicySignature_getGroupNames_op[] = "getGroupNames" ;
static const char org_csapi_policy_provisioning_IpPolicySignature_getPolicyRoles_op[] = "getPolicyRoles" ;
static const char org_csapi_policy_provisioning_IpPolicySignature_getParentDomain_op[] = "getParentDomain" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getParentDomain_op[] = "getParentDomain" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_createDomain_op[] = "createDomain" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getDomain_op[] = "getDomain" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_removeDomain_op[] = "removeDomain" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getDomainCount_op[] = "getDomainCount" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getDomainIterator_op[] = "getDomainIterator" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_createGroup_op[] = "createGroup" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getGroup_op[] = "getGroup" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_removeGroup_op[] = "removeGroup" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getGroupCount_op[] = "getGroupCount" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getGroupIterator_op[] = "getGroupIterator" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_createRule_op[] = "createRule" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getRule_op[] = "getRule" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_removeRule_op[] = "removeRule" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getRuleCount_op[] = "getRuleCount" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getRuleIterator_op[] = "getRuleIterator" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_createEventDefinition_op[] = "createEventDefinition" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinition_op[] = "getEventDefinition" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_removeEventDefinition_op[] = "removeEventDefinition" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinitionCount_op[] = "getEventDefinitionCount" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinitionIterator_op[] = "getEventDefinitionIterator" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_createVariableSet_op[] = "createVariableSet" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getVariableSet_op[] = "getVariableSet" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_removeVariableSet_op[] = "removeVariableSet" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getVariableSetCount_op[] = "getVariableSetCount" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getVariableSetIterator_op[] = "getVariableSetIterator" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_createVariable_op[] = "createVariable" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_setVariableValue_op[] = "setVariableValue" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getVariableType_op[] = "getVariableType" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getVariableValue_op[] = "getVariableValue" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getVariable_op[] = "getVariable" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_removeVariable_op[] = "removeVariable" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_createSignature_op[] = "createSignature" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getSignature_op[] = "getSignature" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_removeSignature_op[] = "removeSignature" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getSignatureCount_op[] = "getSignatureCount" ;
static const char org_csapi_policy_provisioning_IpPolicyDomain_getSignatureIterator_op[] = "getSignatureIterator" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_createIdentity_op[] = "createIdentity" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_deleteIdentity_op[] = "deleteIdentity" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_isIdentity_op[] = "isIdentity" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_createGroupIdentity_op[] = "createGroupIdentity" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_deleteGroupIdentity_op[] = "deleteGroupIdentity" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_addToGroup_op[] = "addToGroup" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_removeFromGroup_op[] = "removeFromGroup" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_listMembers_op[] = "listMembers" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_isGroupIdentity_op[] = "isGroupIdentity" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_listGroupMembership_op[] = "listGroupMembership" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_addAlias_op[] = "addAlias" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_removeAliases_op[] = "removeAliases" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_listAliases_op[] = "listAliases" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_lookupByAlias_op[] = "lookupByAlias" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_associateTypes_op[] = "associateTypes" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_disassociateTypes_op[] = "disassociateTypes" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_listTypesOfIdentity_op[] = "listTypesOfIdentity" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_hasType_op[] = "hasType" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_getIdentityAttributes_op[] = "getIdentityAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityManagement_setIdentityAttributes_op[] = "setIdentityAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMAgentManagement_createAgent_op[] = "createAgent" ;
static const char org_csapi_pam_provisioning_IpPAMAgentManagement_deleteAgent_op[] = "deleteAgent" ;
static const char org_csapi_pam_provisioning_IpPAMAgentManagement_isAgent_op[] = "isAgent" ;
static const char org_csapi_pam_provisioning_IpPAMAgentManagement_enableCapabilities_op[] = "enableCapabilities" ;
static const char org_csapi_pam_provisioning_IpPAMAgentManagement_disableCapabilities_op[] = "disableCapabilities" ;
static const char org_csapi_pam_provisioning_IpPAMAgentManagement_listEnabledCapabilities_op[] = "listEnabledCapabilities" ;
static const char org_csapi_pam_provisioning_IpPAMAgentManagement_listAllCapabilities_op[] = "listAllCapabilities" ;
static const char org_csapi_pam_provisioning_IpPAMAgentManagement_isCapableOf_op[] = "isCapableOf" ;
static const char org_csapi_pam_provisioning_IpPAMAgentManagement_associateTypes_op[] = "associateTypes" ;
static const char org_csapi_pam_provisioning_IpPAMAgentManagement_disassociateTypes_op[] = "disassociateTypes" ;
static const char org_csapi_pam_provisioning_IpPAMAgentManagement_listTypesOfAgent_op[] = "listTypesOfAgent" ;
static const char org_csapi_pam_provisioning_IpPAMAgentManagement_hasType_op[] = "hasType" ;
static const char org_csapi_pam_provisioning_IpPAMAgentManagement_getAgentAttributes_op[] = "getAgentAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMAgentManagement_setAgentAttributes_op[] = "setAgentAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMAgentAssignment_assignAgent_op[] = "assignAgent" ;
static const char org_csapi_pam_provisioning_IpPAMAgentAssignment_unassignAgent_op[] = "unassignAgent" ;
static const char org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssignedAgents_op[] = "listAssignedAgents" ;
static const char org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssociatedIdentitiesOfAgent_op[] = "listAssociatedIdentitiesOfAgent" ;
static const char org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssignedAgentsByCapability_op[] = "listAssignedAgentsByCapability" ;
static const char org_csapi_pam_provisioning_IpPAMAgentAssignment_listCapabilitiesOfIdentity_op[] = "listCapabilitiesOfIdentity" ;
static const char org_csapi_pam_provisioning_IpPAMAgentAssignment_isIdentityCapableOf_op[] = "isIdentityCapableOf" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_createIdentityAttribute_op[] = "createIdentityAttribute" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_deleteIdentityAttribute_op[] = "deleteIdentityAttribute" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_getIdentityAttributeDefinition_op[] = "getIdentityAttributeDefinition" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listAllIdentityAttributes_op[] = "listAllIdentityAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_createIdentityType_op[] = "createIdentityType" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_deleteIdentityType_op[] = "deleteIdentityType" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listIdentityTypes_op[] = "listIdentityTypes" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_addIdentityTypeAttributes_op[] = "addIdentityTypeAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_removeIdentityTypeAttributes_op[] = "removeIdentityTypeAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listIdentityTypeAttributes_op[] = "listIdentityTypeAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMAgentTypeManagement_createAgentAttribute_op[] = "createAgentAttribute" ;
static const char org_csapi_pam_provisioning_IpPAMAgentTypeManagement_deleteAgentAttribute_op[] = "deleteAgentAttribute" ;
static const char org_csapi_pam_provisioning_IpPAMAgentTypeManagement_getAgentAttributeDefinition_op[] = "getAgentAttributeDefinition" ;
static const char org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAllAgentAttributes_op[] = "listAllAgentAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMAgentTypeManagement_createAgentType_op[] = "createAgentType" ;
static const char org_csapi_pam_provisioning_IpPAMAgentTypeManagement_deleteAgentType_op[] = "deleteAgentType" ;
static const char org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAgentTypes_op[] = "listAgentTypes" ;
static const char org_csapi_pam_provisioning_IpPAMAgentTypeManagement_addAgentTypeAttributes_op[] = "addAgentTypeAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMAgentTypeManagement_removeAgentTypeAttributes_op[] = "removeAgentTypeAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAgentTypeAttributes_op[] = "listAgentTypeAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMCapabilityManagement_createCapabilityAttribute_op[] = "createCapabilityAttribute" ;
static const char org_csapi_pam_provisioning_IpPAMCapabilityManagement_deleteCapabilityAttribute_op[] = "deleteCapabilityAttribute" ;
static const char org_csapi_pam_provisioning_IpPAMCapabilityManagement_getCapabilityAttributeDefinition_op[] = "getCapabilityAttributeDefinition" ;
static const char org_csapi_pam_provisioning_IpPAMCapabilityManagement_listAllCapabilityAttributes_op[] = "listAllCapabilityAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMCapabilityManagement_createCapability_op[] = "createCapability" ;
static const char org_csapi_pam_provisioning_IpPAMCapabilityManagement_deleteCapability_op[] = "deleteCapability" ;
static const char org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilities_op[] = "listCapabilities" ;
static const char org_csapi_pam_provisioning_IpPAMCapabilityManagement_addCapabilityAttributes_op[] = "addCapabilityAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMCapabilityManagement_removeCapabilityAttributes_op[] = "removeCapabilityAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilityAttributes_op[] = "listCapabilityAttributes" ;
static const char org_csapi_pam_provisioning_IpPAMCapabilityManagement_assignCapabilitiesToType_op[] = "assignCapabilitiesToType" ;
static const char org_csapi_pam_provisioning_IpPAMCapabilityManagement_unassignCapabilitiesFromType_op[] = "unassignCapabilitiesFromType" ;
static const char org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilitiesOfType_op[] = "listCapabilitiesOfType" ;
static const char org_csapi_pam_provisioning_IpPAMProvisioningManager_getAuthToken_op[] = "getAuthToken" ;
static const char org_csapi_pam_provisioning_IpPAMProvisioningManager_obtainInterface_op[] = "obtainInterface" ;
static const char org_csapi_pam_provisioning_IpPAMProvisioningManager_getAccessControl_op[] = "getAccessControl" ;
static const char org_csapi_pam_provisioning_IpPAMProvisioningManager_setAccessControl_op[] = "setAccessControl" ;
static const char org_csapi_pam_access_IpPAMIdentityPresence_setIdentityPresence_op[] = "setIdentityPresence" ;
static const char org_csapi_pam_access_IpPAMIdentityPresence_setIdentityPresenceExpiration_op[] = "setIdentityPresenceExpiration" ;
static const char org_csapi_pam_access_IpPAMIdentityPresence_getIdentityPresence_op[] = "getIdentityPresence" ;
static const char org_csapi_pam_access_IpPAMAgentPresence_setAgentPresence_op[] = "setAgentPresence" ;
static const char org_csapi_pam_access_IpPAMAgentPresence_setCapabilityPresence_op[] = "setCapabilityPresence" ;
static const char org_csapi_pam_access_IpPAMAgentPresence_setAgentPresenceExpiration_op[] = "setAgentPresenceExpiration" ;
static const char org_csapi_pam_access_IpPAMAgentPresence_setCapabilityPresenceExpiration_op[] = "setCapabilityPresenceExpiration" ;
static const char org_csapi_pam_access_IpPAMAgentPresence_getAgentPresence_op[] = "getAgentPresence" ;
static const char org_csapi_pam_access_IpPAMAgentPresence_getCapabilityPresence_op[] = "getCapabilityPresence" ;
static const char org_csapi_pam_access_IpAppPAMPreferenceCheck_computeAvailability_op[] = "computeAvailability" ;
static const char org_csapi_pam_access_IpPAMAvailability_getAvailability_op[] = "getAvailability" ;
static const char org_csapi_pam_access_IpPAMAvailability_getPreference_op[] = "getPreference" ;
static const char org_csapi_pam_access_IpPAMAvailability_setPreference_op[] = "setPreference" ;
static const char org_csapi_pam_access_IpPAMPresenceAvailabilityManager_getAuthToken_op[] = "getAuthToken" ;
static const char org_csapi_pam_access_IpPAMPresenceAvailabilityManager_obtainInterface_op[] = "obtainInterface" ;
static const char org_csapi_pam_access_IpPAMPresenceAvailabilityManager_getAccessControl_op[] = "getAccessControl" ;
static const char org_csapi_pam_access_IpPAMPresenceAvailabilityManager_setAccessControl_op[] = "setAccessControl" ;
static const char org_csapi_pam_access_IpPAMPresenceAvailabilityManager_activateService_op[] = "activateService" ;
static const char org_csapi_pam_access_IpPAMPresenceAvailabilityManager_deactivateService_op[] = "deactivateService" ;
static const char org_csapi_pam_access_IpPAMPresenceAvailabilityManager_isActiveIdentity_op[] = "isActiveIdentity" ;
static const char org_csapi_pam_event_IpAppPAMEventHandler_eventNotify_op[] = "eventNotify" ;
static const char org_csapi_pam_event_IpAppPAMEventHandler_eventNotifyErr_op[] = "eventNotifyErr" ;
static const char org_csapi_pam_event_IpPAMEventHandler_isRegistered_op[] = "isRegistered" ;
static const char org_csapi_pam_event_IpPAMEventHandler_registerAppInterface_op[] = "registerAppInterface" ;
static const char org_csapi_pam_event_IpPAMEventHandler_registerForEvent_op[] = "registerForEvent" ;
static const char org_csapi_pam_event_IpPAMEventHandler_deregisterAppInterface_op[] = "deregisterAppInterface" ;
static const char org_csapi_pam_event_IpPAMEventHandler_deregisterFromEvent_op[] = "deregisterFromEvent" ;
static const char org_csapi_pam_event_IpPAMEventManager_getAuthToken_op[] = "getAuthToken" ;
static const char org_csapi_pam_event_IpPAMEventManager_obtainInterface_op[] = "obtainInterface" ;
static const char org_csapi_pam_event_IpPAMEventManager_getAccessControl_op[] = "getAccessControl" ;
static const char org_csapi_pam_event_IpPAMEventManager_setAccessControl_op[] = "setAccessControl" ;
static const char org_csapi_pam_event_IpPAMEventManager_activateService_op[] = "activateService" ;
static const char org_csapi_pam_event_IpPAMEventManager_deactivateService_op[] = "deactivateService" ;
static const char org_csapi_pam_event_IpPAMEventManager_isActiveIdentity_op[] = "isActiveIdentity" ;
static const char org_csapi_mmm_IpAppMultiMediaMessagingManager_mailboxTerminated_op[] = "mailboxTerminated" ;
static const char org_csapi_mmm_IpAppMultiMediaMessagingManager_reportNotification_op[] = "reportNotification" ;
static const char org_csapi_mmm_IpAppMultiMediaMessagingManager_notificationsInterrupted_op[] = "notificationsInterrupted" ;
static const char org_csapi_mmm_IpAppMultiMediaMessagingManager_notificationsResumed_op[] = "notificationsResumed" ;
static const char org_csapi_mmm_IpAppMultiMediaMessagingManager_multiMediaMessagingTerminated_op[] = "multiMediaMessagingTerminated" ;
static const char org_csapi_mmm_IpAppMultiMediaMessagingManager_terminateMultipleMailboxes_op[] = "terminateMultipleMailboxes" ;
static const char org_csapi_mmm_IpAppMultiMediaMessagingManager_terminateMultipleMultiMediaMessagingSessions_op[] = "terminateMultipleMultiMediaMessagingSessions" ;
static const char org_csapi_mmm_IpMultiMediaMessagingManager_openMailbox_op[] = "openMailbox" ;
static const char org_csapi_mmm_IpMultiMediaMessagingManager_openMultiMediaMessaging_op[] = "openMultiMediaMessaging" ;
static const char org_csapi_mmm_IpMultiMediaMessagingManager_createNotification_op[] = "createNotification" ;
static const char org_csapi_mmm_IpMultiMediaMessagingManager_destroyNotification_op[] = "destroyNotification" ;
static const char org_csapi_mmm_IpMultiMediaMessagingManager_changeNotification_op[] = "changeNotification" ;
static const char org_csapi_mmm_IpMultiMediaMessagingManager_getNextNotification_op[] = "getNextNotification" ;
static const char org_csapi_mmm_IpMultiMediaMessagingManager_enableNotifications_op[] = "enableNotifications" ;
static const char org_csapi_mmm_IpMultiMediaMessagingManager_disableNotifications_op[] = "disableNotifications" ;
static const char org_csapi_mmm_IpAppMailbox_createFolderRes_op[] = "createFolderRes" ;
static const char org_csapi_mmm_IpAppMailbox_createFolderErr_op[] = "createFolderErr" ;
static const char org_csapi_mmm_IpAppMailbox_getFoldersRes_op[] = "getFoldersRes" ;
static const char org_csapi_mmm_IpAppMailbox_getFoldersErr_op[] = "getFoldersErr" ;
static const char org_csapi_mmm_IpAppMailbox_deleteFolderRes_op[] = "deleteFolderRes" ;
static const char org_csapi_mmm_IpAppMailbox_deleteFolderErr_op[] = "deleteFolderErr" ;
static const char org_csapi_mmm_IpAppMailbox_copyFolderRes_op[] = "copyFolderRes" ;
static const char org_csapi_mmm_IpAppMailbox_copyFolderErr_op[] = "copyFolderErr" ;
static const char org_csapi_mmm_IpAppMailbox_moveFolderRes_op[] = "moveFolderRes" ;
static const char org_csapi_mmm_IpAppMailbox_moveFolderErr_op[] = "moveFolderErr" ;
static const char org_csapi_mmm_IpAppMailbox_putMessageRes_op[] = "putMessageRes" ;
static const char org_csapi_mmm_IpAppMailbox_putMessageErr_op[] = "putMessageErr" ;
static const char org_csapi_mmm_IpAppMailbox_copyMessageRes_op[] = "copyMessageRes" ;
static const char org_csapi_mmm_IpAppMailbox_copyMessageErr_op[] = "copyMessageErr" ;
static const char org_csapi_mmm_IpAppMailbox_moveMessageRes_op[] = "moveMessageRes" ;
static const char org_csapi_mmm_IpAppMailbox_moveMessageErr_op[] = "moveMessageErr" ;
static const char org_csapi_mmm_IpAppMailbox_deleteMessageRes_op[] = "deleteMessageRes" ;
static const char org_csapi_mmm_IpAppMailbox_deleteMessageErr_op[] = "deleteMessageErr" ;
static const char org_csapi_mmm_IpAppMailbox_listMessagesRes_op[] = "listMessagesRes" ;
static const char org_csapi_mmm_IpAppMailbox_listMessagesErr_op[] = "listMessagesErr" ;
static const char org_csapi_mmm_IpAppMailbox_listMessageBodyPartsRes_op[] = "listMessageBodyPartsRes" ;
static const char org_csapi_mmm_IpAppMailbox_listMessageBodyPartsErr_op[] = "listMessageBodyPartsErr" ;
static const char org_csapi_mmm_IpAppMailbox_getMessageBodyPartsRes_op[] = "getMessageBodyPartsRes" ;
static const char org_csapi_mmm_IpAppMailbox_getMessageBodyPartsErr_op[] = "getMessageBodyPartsErr" ;
static const char org_csapi_mmm_IpAppMailbox_getMessageHeadersRes_op[] = "getMessageHeadersRes" ;
static const char org_csapi_mmm_IpAppMailbox_getMessageHeadersErr_op[] = "getMessageHeadersErr" ;
static const char org_csapi_mmm_IpAppMailbox_getMessageContentRes_op[] = "getMessageContentRes" ;
static const char org_csapi_mmm_IpAppMailbox_getMessageContentErr_op[] = "getMessageContentErr" ;
static const char org_csapi_mmm_IpAppMailbox_getFullMessageRes_op[] = "getFullMessageRes" ;
static const char org_csapi_mmm_IpAppMailbox_getFullMessageErr_op[] = "getFullMessageErr" ;
static const char org_csapi_mmm_IpAppMailbox_getMailboxInfoPropertiesRes_op[] = "getMailboxInfoPropertiesRes" ;
static const char org_csapi_mmm_IpAppMailbox_getFolderInfoPropertiesRes_op[] = "getFolderInfoPropertiesRes" ;
static const char org_csapi_mmm_IpAppMailbox_getMessageInfoPropertiesRes_op[] = "getMessageInfoPropertiesRes" ;
static const char org_csapi_mmm_IpAppMailbox_setMessageInfoPropertiesRes_op[] = "setMessageInfoPropertiesRes" ;
static const char org_csapi_mmm_IpAppMailbox_setMessageInfoPropertiesErr_op[] = "setMessageInfoPropertiesErr" ;
static const char org_csapi_mmm_IpAppMailbox_getMailboxInfoPropertiesErr_op[] = "getMailboxInfoPropertiesErr" ;
static const char org_csapi_mmm_IpAppMailbox_getFolderInfoPropertiesErr_op[] = "getFolderInfoPropertiesErr" ;
static const char org_csapi_mmm_IpAppMailbox_getMessageInfoPropertiesErr_op[] = "getMessageInfoPropertiesErr" ;
static const char org_csapi_mmm_IpMailbox_close_op[] = "close" ;
static const char org_csapi_mmm_IpMailbox_createFolderReq_op[] = "createFolderReq" ;
static const char org_csapi_mmm_IpMailbox_getFoldersReq_op[] = "getFoldersReq" ;
static const char org_csapi_mmm_IpMailbox_deleteFolderReq_op[] = "deleteFolderReq" ;
static const char org_csapi_mmm_IpMailbox_copyFolderReq_op[] = "copyFolderReq" ;
static const char org_csapi_mmm_IpMailbox_moveFolderReq_op[] = "moveFolderReq" ;
static const char org_csapi_mmm_IpMailbox_putMessageReq_op[] = "putMessageReq" ;
static const char org_csapi_mmm_IpMailbox_copyMessageReq_op[] = "copyMessageReq" ;
static const char org_csapi_mmm_IpMailbox_moveMessageReq_op[] = "moveMessageReq" ;
static const char org_csapi_mmm_IpMailbox_deleteMessageReq_op[] = "deleteMessageReq" ;
static const char org_csapi_mmm_IpMailbox_listMessagesReq_op[] = "listMessagesReq" ;
static const char org_csapi_mmm_IpMailbox_listMessageBodyPartsReq_op[] = "listMessageBodyPartsReq" ;
static const char org_csapi_mmm_IpMailbox_getMessageBodyPartsReq_op[] = "getMessageBodyPartsReq" ;
static const char org_csapi_mmm_IpMailbox_getMessageHeadersReq_op[] = "getMessageHeadersReq" ;
static const char org_csapi_mmm_IpMailbox_getMessageContentReq_op[] = "getMessageContentReq" ;
static const char org_csapi_mmm_IpMailbox_getFullMessageReq_op[] = "getFullMessageReq" ;
static const char org_csapi_mmm_IpMailbox_getMailboxInfoPropertiesReq_op[] = "getMailboxInfoPropertiesReq" ;
static const char org_csapi_mmm_IpMailbox_getFolderInfoPropertiesReq_op[] = "getFolderInfoPropertiesReq" ;
static const char org_csapi_mmm_IpMailbox_getMessageInfoPropertiesReq_op[] = "getMessageInfoPropertiesReq" ;
static const char org_csapi_mmm_IpMailbox_setMessageInfoPropertiesReq_op[] = "setMessageInfoPropertiesReq" ;
static const char org_csapi_mmm_IpAppMultiMediaMessaging_sendMessageRes_op[] = "sendMessageRes" ;
static const char org_csapi_mmm_IpAppMultiMediaMessaging_sendMessageErr_op[] = "sendMessageErr" ;
static const char org_csapi_mmm_IpAppMultiMediaMessaging_cancelMessageRes_op[] = "cancelMessageRes" ;
static const char org_csapi_mmm_IpAppMultiMediaMessaging_cancelMessageErr_op[] = "cancelMessageErr" ;
static const char org_csapi_mmm_IpAppMultiMediaMessaging_queryStatusRes_op[] = "queryStatusRes" ;
static const char org_csapi_mmm_IpAppMultiMediaMessaging_queryStatusErr_op[] = "queryStatusErr" ;
static const char org_csapi_mmm_IpAppMultiMediaMessaging_messageStatusReport_op[] = "messageStatusReport" ;
static const char org_csapi_mmm_IpAppMultiMediaMessaging_messageReceived_op[] = "messageReceived" ;
static const char org_csapi_mmm_IpMultiMediaMessaging_sendMessageReq_op[] = "sendMessageReq" ;
static const char org_csapi_mmm_IpMultiMediaMessaging_cancelMessageReq_op[] = "cancelMessageReq" ;
static const char org_csapi_mmm_IpMultiMediaMessaging_queryStatusReq_op[] = "queryStatusReq" ;
static const char org_csapi_mmm_IpMultiMediaMessaging_close_op[] = "close" ;

/*
 * IDL Operations End
 */

/*  Begin Exception (containing members) String  Declare  */


static const char user_exception_org_csapi_mmm_P_MMM_MAX_MESSAGE_SIZE_EXCEEDED[] = "IDL:org/csapi/mmm/P_MMM_MAX_MESSAGE_SIZE_EXCEEDED:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_INVALID_FOLDER_ID[] = "IDL:org/csapi/mmm/P_MMM_INVALID_FOLDER_ID:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_INVALID_MESSAGE_ID[] = "IDL:org/csapi/mmm/P_MMM_INVALID_MESSAGE_ID:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_INVALID_PART_ID[] = "IDL:org/csapi/mmm/P_MMM_INVALID_PART_ID:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH[] = "IDL:org/csapi/mmm/P_MMM_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH[] = "IDL:org/csapi/mmm/P_MMM_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_INVALID_PROPERTY[] = "IDL:org/csapi/mmm/P_MMM_INVALID_PROPERTY:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_INVALID_DELIVERY_TIME[] = "IDL:org/csapi/mmm/P_MMM_INVALID_DELIVERY_TIME:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_INVALID_VALIDITY_TIME[] = "IDL:org/csapi/mmm/P_MMM_INVALID_VALIDITY_TIME:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_MAX_SUBJECT_SIZE_EXCEEDED[] = "IDL:org/csapi/mmm/P_MMM_MAX_SUBJECT_SIZE_EXCEEDED:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_INFORMATION_NOT_AVAILABLE[] = "IDL:org/csapi/mmm/P_MMM_INFORMATION_NOT_AVAILABLE:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_CANNOT_CANCEL[] = "IDL:org/csapi/mmm/P_MMM_CANNOT_CANCEL:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_INVALID_HEADER[] = "IDL:org/csapi/mmm/P_MMM_INVALID_HEADER:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_INVALID_AUTHENTICATION_INFORMATION[] = "IDL:org/csapi/mmm/P_MMM_INVALID_AUTHENTICATION_INFORMATION:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_INVALID_MAILBOX[] = "IDL:org/csapi/mmm/P_MMM_INVALID_MAILBOX:1.0" ; 
static const char user_exception_org_csapi_mmm_P_MMM_INVALID_DELIVERY_TYPE[] = "IDL:org/csapi/mmm/P_MMM_INVALID_DELIVERY_TYPE:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_UNAVAILABLE_INTERFACE[] = "IDL:org/csapi/pam/P_PAM_UNAVAILABLE_INTERFACE:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_INVALID_CREDENTIAL[] = "IDL:org/csapi/pam/P_PAM_INVALID_CREDENTIAL:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_UNKNOWN_TYPE[] = "IDL:org/csapi/pam/P_PAM_UNKNOWN_TYPE:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_UNKNOWN_MEMBER[] = "IDL:org/csapi/pam/P_PAM_UNKNOWN_MEMBER:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_UNKNOWN_IDENTITY[] = "IDL:org/csapi/pam/P_PAM_UNKNOWN_IDENTITY:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_UNKNOWN_GROUP[] = "IDL:org/csapi/pam/P_PAM_UNKNOWN_GROUP:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_UNKNOWN_CAPABILITY[] = "IDL:org/csapi/pam/P_PAM_UNKNOWN_CAPABILITY:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_UNKNOWN_ATTRIBUTES[] = "IDL:org/csapi/pam/P_PAM_UNKNOWN_ATTRIBUTES:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_UNKNOWN_ATTRIBUTE[] = "IDL:org/csapi/pam/P_PAM_UNKNOWN_ATTRIBUTE:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_UNKNOWN_ASSIGNMENT[] = "IDL:org/csapi/pam/P_PAM_UNKNOWN_ASSIGNMENT:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_UNKNOWN_ALIAS[] = "IDL:org/csapi/pam/P_PAM_UNKNOWN_ALIAS:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_UNKNOWN_AGENT[] = "IDL:org/csapi/pam/P_PAM_UNKNOWN_AGENT:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_UNASSIGNED_ALIAS[] = "IDL:org/csapi/pam/P_PAM_UNASSIGNED_ALIAS:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_TYPE_EXISTS[] = "IDL:org/csapi/pam/P_PAM_TYPE_EXISTS:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_TYPE_ASSOCIATED[] = "IDL:org/csapi/pam/P_PAM_TYPE_ASSOCIATED:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_NOT_REGISTERED[] = "IDL:org/csapi/pam/P_PAM_NOT_REGISTERED:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_NOT_MEMBER[] = "IDL:org/csapi/pam/P_PAM_NOT_MEMBER:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_NO_CAPABILITY[] = "IDL:org/csapi/pam/P_PAM_NO_CAPABILITY:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_MEMBER_EXISTS[] = "IDL:org/csapi/pam/P_PAM_MEMBER_EXISTS:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_IS_CYCLIC[] = "IDL:org/csapi/pam/P_PAM_IS_CYCLIC:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_IDENTITY_EXISTS[] = "IDL:org/csapi/pam/P_PAM_IDENTITY_EXISTS:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_DISASSOCIATED_TYPE[] = "IDL:org/csapi/pam/P_PAM_DISASSOCIATED_TYPE:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_ATTRIBUTE_EXISTS[] = "IDL:org/csapi/pam/P_PAM_ATTRIBUTE_EXISTS:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_ALIAS_NOT_UNIQUE[] = "IDL:org/csapi/pam/P_PAM_ALIAS_NOT_UNIQUE:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_ALIAS_EXISTS[] = "IDL:org/csapi/pam/P_PAM_ALIAS_EXISTS:1.0" ; 
static const char user_exception_org_csapi_pam_P_PAM_AGENT_EXISTS[] = "IDL:org/csapi/pam/P_PAM_AGENT_EXISTS:1.0" ; 
static const char user_exception_org_csapi_cs_P_INVALID_USER[] = "IDL:org/csapi/cs/P_INVALID_USER:1.0" ; 
static const char user_exception_org_csapi_cs_P_INVALID_ACCOUNT[] = "IDL:org/csapi/cs/P_INVALID_ACCOUNT:1.0" ; 
static const char user_exception_org_csapi_cs_P_INVALID_REQUEST_NUMBER[] = "IDL:org/csapi/cs/P_INVALID_REQUEST_NUMBER:1.0" ; 
static const char user_exception_org_csapi_cs_P_INVALID_VOLUME[] = "IDL:org/csapi/cs/P_INVALID_VOLUME:1.0" ; 
static const char user_exception_org_csapi_policy_P_ACCESS_VIOLATION[] = "IDL:org/csapi/policy/P_ACCESS_VIOLATION:1.0" ; 
static const char user_exception_org_csapi_policy_P_SYNTAX_ERROR[] = "IDL:org/csapi/policy/P_SYNTAX_ERROR:1.0" ; 
static const char user_exception_org_csapi_policy_P_NAME_SPACE_ERROR[] = "IDL:org/csapi/policy/P_NAME_SPACE_ERROR:1.0" ; 
static const char user_exception_org_csapi_policy_P_NO_TRANSACTION_IN_PROCESS[] = "IDL:org/csapi/policy/P_NO_TRANSACTION_IN_PROCESS:1.0" ; 
static const char user_exception_org_csapi_policy_P_TRANSACTION_IN_PROCESS[] = "IDL:org/csapi/policy/P_TRANSACTION_IN_PROCESS:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_VPRP_ID[] = "IDL:org/csapi/cm/P_UNKNOWN_VPRP_ID:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_SLA_ID[] = "IDL:org/csapi/cm/P_UNKNOWN_SLA_ID:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_STATUS[] = "IDL:org/csapi/cm/P_UNKNOWN_STATUS:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_QOS_INFO[] = "IDL:org/csapi/cm/P_UNKNOWN_QOS_INFO:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_VALIDITY_INFO[] = "IDL:org/csapi/cm/P_UNKNOWN_VALIDITY_INFO:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_PIPEQOSINFO[] = "IDL:org/csapi/cm/P_UNKNOWN_PIPEQOSINFO:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_DSCODEPOINT[] = "IDL:org/csapi/cm/P_UNKNOWN_DSCODEPOINT:1.0" ; 
static const char user_exception_org_csapi_cm_P_ILLEGAL_VPRPID[] = "IDL:org/csapi/cm/P_ILLEGAL_VPRPID:1.0" ; 
static const char user_exception_org_csapi_cm_P_ILLEGAL_REF_VALUE[] = "IDL:org/csapi/cm/P_ILLEGAL_REF_VALUE:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_INTERFACE[] = "IDL:org/csapi/cm/P_UNKNOWN_INTERFACE:1.0" ; 
static const char user_exception_org_csapi_cm_P_CANT_DELETE_VPRP[] = "IDL:org/csapi/cm/P_CANT_DELETE_VPRP:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_TEMPLATES[] = "IDL:org/csapi/cm/P_UNKNOWN_TEMPLATES:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_MENU[] = "IDL:org/csapi/cm/P_UNKNOWN_MENU:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_ENTERPRISE_NETWORK[] = "IDL:org/csapi/cm/P_UNKNOWN_ENTERPRISE_NETWORK:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_TEMPLATE_TYPE[] = "IDL:org/csapi/cm/P_UNKNOWN_TEMPLATE_TYPE:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_DESCRIPTION[] = "IDL:org/csapi/cm/P_UNKNOWN_DESCRIPTION:1.0" ; 
static const char user_exception_org_csapi_cm_P_ILLEGAL_SLA_ID[] = "IDL:org/csapi/cm/P_ILLEGAL_SLA_ID:1.0" ; 
static const char user_exception_org_csapi_cm_P_ILLEGAL_TAG[] = "IDL:org/csapi/cm/P_ILLEGAL_TAG:1.0" ; 
static const char user_exception_org_csapi_cm_P_ILLEGAL_VALUE[] = "IDL:org/csapi/cm/P_ILLEGAL_VALUE:1.0" ; 
static const char user_exception_org_csapi_cm_P_ILLEGAL_COMBINATION[] = "IDL:org/csapi/cm/P_ILLEGAL_COMBINATION:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_SITES[] = "IDL:org/csapi/cm/P_UNKNOWN_SITES:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_VPRN[] = "IDL:org/csapi/cm/P_UNKNOWN_VPRN:1.0" ; 
static const char user_exception_org_csapi_cm_P_ILLEGAL_SITE_ID[] = "IDL:org/csapi/cm/P_ILLEGAL_SITE_ID:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_SITE_ID[] = "IDL:org/csapi/cm/P_UNKNOWN_SITE_ID:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_SAPS[] = "IDL:org/csapi/cm/P_UNKNOWN_SAPS:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_SITE_LOCATION[] = "IDL:org/csapi/cm/P_UNKNOWN_SITE_LOCATION:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_SITE_DESCRIPTION[] = "IDL:org/csapi/cm/P_UNKNOWN_SITE_DESCRIPTION:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_IPSUBNET[] = "IDL:org/csapi/cm/P_UNKNOWN_IPSUBNET:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_SAP[] = "IDL:org/csapi/cm/P_UNKNOWN_SAP:1.0" ; 
static const char user_exception_org_csapi_cm_P_UNKNOWN_VPRP[] = "IDL:org/csapi/cm/P_UNKNOWN_VPRP:1.0" ; 
static const char user_exception_org_csapi_am_P_UNAUTHORIZED_APPLICATION[] = "IDL:org/csapi/am/P_UNAUTHORIZED_APPLICATION:1.0" ; 
static const char user_exception_org_csapi_gms_P_GMS_INVALID_FOLDER_ID[] = "IDL:org/csapi/gms/P_GMS_INVALID_FOLDER_ID:1.0" ; 
static const char user_exception_org_csapi_gms_P_GMS_INSUFFICIENT_PRIVILEGE[] = "IDL:org/csapi/gms/P_GMS_INSUFFICIENT_PRIVILEGE:1.0" ; 
static const char user_exception_org_csapi_gms_P_GMS_INVALID_AUTHENTICATION_INFORMATION[] = "IDL:org/csapi/gms/P_GMS_INVALID_AUTHENTICATION_INFORMATION:1.0" ; 
static const char user_exception_org_csapi_gms_P_GMS_INVALID_MAILBOX[] = "IDL:org/csapi/gms/P_GMS_INVALID_MAILBOX:1.0" ; 
static const char user_exception_org_csapi_gms_P_GMS_INVALID_MESSAGE_ID[] = "IDL:org/csapi/gms/P_GMS_INVALID_MESSAGE_ID:1.0" ; 
static const char user_exception_org_csapi_gms_P_GMS_LOCKING_LOCKED_MAILBOX[] = "IDL:org/csapi/gms/P_GMS_LOCKING_LOCKED_MAILBOX:1.0" ; 
static const char user_exception_org_csapi_gms_P_GMS_MESSAGE_NOT_REMOVED[] = "IDL:org/csapi/gms/P_GMS_MESSAGE_NOT_REMOVED:1.0" ; 
static const char user_exception_org_csapi_gms_P_GMS_NUMBER_NOT_POSITIVE[] = "IDL:org/csapi/gms/P_GMS_NUMBER_NOT_POSITIVE:1.0" ; 
static const char user_exception_org_csapi_gms_P_GMS_UNLOCKING_UNLOCKED_MAILBOX[] = "IDL:org/csapi/gms/P_GMS_UNLOCKING_UNLOCKED_MAILBOX:1.0" ; 
static const char user_exception_org_csapi_gms_P_GMS_MAILBOX_LOCKED[] = "IDL:org/csapi/gms/P_GMS_MAILBOX_LOCKED:1.0" ; 
static const char user_exception_org_csapi_gms_P_GMS_CANNOT_UNLOCK_MAILBOX[] = "IDL:org/csapi/gms/P_GMS_CANNOT_UNLOCK_MAILBOX:1.0" ; 
static const char user_exception_org_csapi_gms_P_GMS_PROPERTY_NOT_SET[] = "IDL:org/csapi/gms/P_GMS_PROPERTY_NOT_SET:1.0" ; 
static const char user_exception_org_csapi_gms_P_GMS_FOLDER_IS_OPEN[] = "IDL:org/csapi/gms/P_GMS_FOLDER_IS_OPEN:1.0" ; 
static const char user_exception_org_csapi_gms_P_GMS_MAILBOX_OPEN[] = "IDL:org/csapi/gms/P_GMS_MAILBOX_OPEN:1.0" ; 
static const char user_exception_org_csapi_termcap_P_INVALID_TERMINAL_ID[] = "IDL:org/csapi/termcap/P_INVALID_TERMINAL_ID:1.0" ; 
static const char user_exception_org_csapi_mm_P_REQUESTED_ACCURACY_CANNOT_BE_DELIVERED[] = "IDL:org/csapi/mm/P_REQUESTED_ACCURACY_CANNOT_BE_DELIVERED:1.0" ; 
static const char user_exception_org_csapi_mm_P_REQUESTED_RESPONSE_TIME_CANNOT_BE_DELIVERED[] = "IDL:org/csapi/mm/P_REQUESTED_RESPONSE_TIME_CANNOT_BE_DELIVERED:1.0" ; 
static const char user_exception_org_csapi_mm_P_INVALID_REPORTING_INTERVAL[] = "IDL:org/csapi/mm/P_INVALID_REPORTING_INTERVAL:1.0" ; 
static const char user_exception_org_csapi_mm_P_TRIGGER_CONDITIONS_NOT_SUBSCRIBED[] = "IDL:org/csapi/mm/P_TRIGGER_CONDITIONS_NOT_SUBSCRIBED:1.0" ; 
static const char user_exception_org_csapi_ui_P_ID_NOT_FOUND[] = "IDL:org/csapi/ui/P_ID_NOT_FOUND:1.0" ; 
static const char user_exception_org_csapi_ui_P_ILLEGAL_ID[] = "IDL:org/csapi/ui/P_ILLEGAL_ID:1.0" ; 
static const char user_exception_org_csapi_ui_P_ILLEGAL_RANGE[] = "IDL:org/csapi/ui/P_ILLEGAL_RANGE:1.0" ; 
static const char user_exception_org_csapi_ui_P_INVALID_COLLECTION_CRITERIA[] = "IDL:org/csapi/ui/P_INVALID_COLLECTION_CRITERIA:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_SERVICE_ID[] = "IDL:org/csapi/fw/P_INVALID_SERVICE_ID:1.0" ; 
static const char user_exception_org_csapi_fw_P_SERVICE_ACCESS_DENIED[] = "IDL:org/csapi/fw/P_SERVICE_ACCESS_DENIED:1.0" ; 
static const char user_exception_org_csapi_fw_P_ACCESS_DENIED[] = "IDL:org/csapi/fw/P_ACCESS_DENIED:1.0" ; 
static const char user_exception_org_csapi_fw_P_SERVICE_NOT_ENABLED[] = "IDL:org/csapi/fw/P_SERVICE_NOT_ENABLED:1.0" ; 
static const char user_exception_org_csapi_fw_P_NO_ACCEPTABLE_ENCRYPTION_CAPABILITY[] = "IDL:org/csapi/fw/P_NO_ACCEPTABLE_ENCRYPTION_CAPABILITY:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_AGREEMENT_TEXT[] = "IDL:org/csapi/fw/P_INVALID_AGREEMENT_TEXT:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_SERVICE_TOKEN[] = "IDL:org/csapi/fw/P_INVALID_SERVICE_TOKEN:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_SIGNATURE[] = "IDL:org/csapi/fw/P_INVALID_SIGNATURE:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_SIGNING_ALGORITHM[] = "IDL:org/csapi/fw/P_INVALID_SIGNING_ALGORITHM:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_DOMAIN_ID[] = "IDL:org/csapi/fw/P_INVALID_DOMAIN_ID:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_PROPERTY[] = "IDL:org/csapi/fw/P_INVALID_PROPERTY:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_ACCESS_TYPE[] = "IDL:org/csapi/fw/P_INVALID_ACCESS_TYPE:1.0" ; 
static const char user_exception_org_csapi_fw_P_ILLEGAL_SERVICE_TYPE[] = "IDL:org/csapi/fw/P_ILLEGAL_SERVICE_TYPE:1.0" ; 
static const char user_exception_org_csapi_fw_P_UNKNOWN_SERVICE_TYPE[] = "IDL:org/csapi/fw/P_UNKNOWN_SERVICE_TYPE:1.0" ; 
static const char user_exception_org_csapi_fw_P_MISSING_MANDATORY_PROPERTY[] = "IDL:org/csapi/fw/P_MISSING_MANDATORY_PROPERTY:1.0" ; 
static const char user_exception_org_csapi_fw_P_DUPLICATE_PROPERTY_NAME[] = "IDL:org/csapi/fw/P_DUPLICATE_PROPERTY_NAME:1.0" ; 
static const char user_exception_org_csapi_fw_P_PROPERTY_TYPE_MISMATCH[] = "IDL:org/csapi/fw/P_PROPERTY_TYPE_MISMATCH:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_CLIENT_APP_ID[] = "IDL:org/csapi/fw/P_INVALID_CLIENT_APP_ID:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_AUTH_TYPE[] = "IDL:org/csapi/fw/P_INVALID_AUTH_TYPE:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_SAG_ID[] = "IDL:org/csapi/fw/P_INVALID_SAG_ID:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_SERVICE_PROFILE_ID[] = "IDL:org/csapi/fw/P_INVALID_SERVICE_PROFILE_ID:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_SERVICE_CONTRACT_ID[] = "IDL:org/csapi/fw/P_INVALID_SERVICE_CONTRACT_ID:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_ACTIVITY_TEST_ID[] = "IDL:org/csapi/fw/P_INVALID_ACTIVITY_TEST_ID:1.0" ; 
static const char user_exception_org_csapi_fw_P_ILLEGAL_SERVICE_ID[] = "IDL:org/csapi/fw/P_ILLEGAL_SERVICE_ID:1.0" ; 
static const char user_exception_org_csapi_fw_P_UNKNOWN_SERVICE_ID[] = "IDL:org/csapi/fw/P_UNKNOWN_SERVICE_ID:1.0" ; 
static const char user_exception_org_csapi_fw_P_SERVICE_TYPE_UNAVAILABLE[] = "IDL:org/csapi/fw/P_SERVICE_TYPE_UNAVAILABLE:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_ADDITION_TO_SAG[] = "IDL:org/csapi/fw/P_INVALID_ADDITION_TO_SAG:1.0" ; 
static const char user_exception_org_csapi_fw_P_INVALID_SAG_TO_SERVICE_PROFILE_ASSIGNMENT[] = "IDL:org/csapi/fw/P_INVALID_SAG_TO_SERVICE_PROFILE_ASSIGNMENT:1.0" ; 
static const char user_exception_org_csapi_fw_P_NO_ACCEPTABLE_AUTHENTICATION_MECHANISM[] = "IDL:org/csapi/fw/P_NO_ACCEPTABLE_AUTHENTICATION_MECHANISM:1.0" ; 
static const char user_exception_org_csapi_fw_P_NO_ACCEPTABLE_SIGNING_ALGORITHM[] = "IDL:org/csapi/fw/P_NO_ACCEPTABLE_SIGNING_ALGORITHM:1.0" ; 
static const char user_exception_org_csapi_P_INVALID_ASSIGNMENT_ID[] = "IDL:org/csapi/P_INVALID_ASSIGNMENT_ID:1.0" ; 
static const char user_exception_org_csapi_P_INVALID_TIME_AND_DATE_FORMAT[] = "IDL:org/csapi/P_INVALID_TIME_AND_DATE_FORMAT:1.0" ; 
static const char user_exception_org_csapi_P_INVALID_EVENT_TYPE[] = "IDL:org/csapi/P_INVALID_EVENT_TYPE:1.0" ; 
static const char user_exception_org_csapi_P_INVALID_INTERFACE_NAME[] = "IDL:org/csapi/P_INVALID_INTERFACE_NAME:1.0" ; 
static const char user_exception_org_csapi_P_INVALID_INTERFACE_TYPE[] = "IDL:org/csapi/P_INVALID_INTERFACE_TYPE:1.0" ; 
static const char user_exception_org_csapi_P_UNKNOWN_SUBSCRIBER[] = "IDL:org/csapi/P_UNKNOWN_SUBSCRIBER:1.0" ; 
static const char user_exception_org_csapi_P_INFORMATION_NOT_AVAILABLE[] = "IDL:org/csapi/P_INFORMATION_NOT_AVAILABLE:1.0" ; 
static const char user_exception_org_csapi_P_INVALID_CRITERIA[] = "IDL:org/csapi/P_INVALID_CRITERIA:1.0" ; 
static const char user_exception_org_csapi_P_INVALID_SESSION_ID[] = "IDL:org/csapi/P_INVALID_SESSION_ID:1.0" ; 
static const char user_exception_org_csapi_TpCommonExceptions[] = "IDL:org/csapi/TpCommonExceptions:1.0" ; 
static const char user_exception_org_csapi_P_INVALID_CURRENCY[] = "IDL:org/csapi/P_INVALID_CURRENCY:1.0" ; 
static const char user_exception_org_csapi_P_INVALID_AMOUNT[] = "IDL:org/csapi/P_INVALID_AMOUNT:1.0" ; 
static const char user_exception_org_csapi_P_APPLICATION_NOT_ACTIVATED[] = "IDL:org/csapi/P_APPLICATION_NOT_ACTIVATED:1.0" ; 
static const char user_exception_org_csapi_P_INVALID_ADDRESS[] = "IDL:org/csapi/P_INVALID_ADDRESS:1.0" ; 
static const char user_exception_org_csapi_P_UNSUPPORTED_ADDRESS_PLAN[] = "IDL:org/csapi/P_UNSUPPORTED_ADDRESS_PLAN:1.0" ; 
static const char user_exception_org_csapi_P_UNAUTHORISED_PARAMETER_VALUE[] = "IDL:org/csapi/P_UNAUTHORISED_PARAMETER_VALUE:1.0" ; 
static const char user_exception_org_csapi_P_INVALID_VERSION[] = "IDL:org/csapi/P_INVALID_VERSION:1.0" ; 
static const char user_exception_org_csapi_P_INVALID_NETWORK_STATE[] = "IDL:org/csapi/P_INVALID_NETWORK_STATE:1.0" ; 

/*  End Exception (containing members) String Declare  */

/*
 * IDL Attributes Start
 */
 

/*
 * IDL Attributes End
 */

/*
 * IDL Enums Start
 */
 
/*
 * Enum = IDL:org/csapi/TpAddressError:1.0
 */
 
static const value_string org_csapi_TpAddressError[] = {

   { 0, "P_ADDRESS_INVALID_UNDEFINED" }, 
   { 1, "P_ADDRESS_INVALID_MISSING" }, 
   { 2, "P_ADDRESS_INVALID_MISSING_ELEMENT" }, 
   { 3, "P_ADDRESS_INVALID_OUT_OF_RANGE" }, 
   { 4, "P_ADDRESS_INVALID_INCOMPLETE" }, 
   { 5, "P_ADDRESS_INVALID_CANNOT_DECODE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/TpAddressPlan:1.0
 */
 
static const value_string org_csapi_TpAddressPlan[] = {

   { 0, "P_ADDRESS_PLAN_NOT_PRESENT" }, 
   { 1, "P_ADDRESS_PLAN_UNDEFINED" }, 
   { 2, "P_ADDRESS_PLAN_IP" }, 
   { 3, "P_ADDRESS_PLAN_MULTICAST" }, 
   { 4, "P_ADDRESS_PLAN_UNICAST" }, 
   { 5, "P_ADDRESS_PLAN_E164" }, 
   { 6, "P_ADDRESS_PLAN_AESA" }, 
   { 7, "P_ADDRESS_PLAN_URL" }, 
   { 8, "P_ADDRESS_PLAN_NSAP" }, 
   { 9, "P_ADDRESS_PLAN_SMTP" }, 
   { 10, "P_ADDRESS_PLAN_MSMAIL" }, 
   { 11, "P_ADDRESS_PLAN_X400" }, 
   { 12, "P_ADDRESS_PLAN_SIP" }, 
   { 13, "P_ADDRESS_PLAN_ANY" }, 
   { 14, "P_ADDRESS_PLAN_NATIONAL" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/TpAddressPresentation:1.0
 */
 
static const value_string org_csapi_TpAddressPresentation[] = {

   { 0, "P_ADDRESS_PRESENTATION_UNDEFINED" }, 
   { 1, "P_ADDRESS_PRESENTATION_ALLOWED" }, 
   { 2, "P_ADDRESS_PRESENTATION_RESTRICTED" }, 
   { 3, "P_ADDRESS_PRESENTATION_ADDRESS_NOT_AVAILABLE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/TpAddressScreening:1.0
 */
 
static const value_string org_csapi_TpAddressScreening[] = {

   { 0, "P_ADDRESS_SCREENING_UNDEFINED" }, 
   { 1, "P_ADDRESS_SCREENING_USER_VERIFIED_PASSED" }, 
   { 2, "P_ADDRESS_SCREENING_USER_NOT_VERIFIED" }, 
   { 3, "P_ADDRESS_SCREENING_USER_VERIFIED_FAILED" }, 
   { 4, "P_ADDRESS_SCREENING_NETWORK" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/TpCallAoCOrderCategory:1.0
 */
 
static const value_string org_csapi_TpCallAoCOrderCategory[] = {

   { 0, "P_CHARGE_ADVICE_INFO" }, 
   { 1, "P_CHARGE_PER_TIME" }, 
   { 2, "P_CHARGE_NETWORK" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/TpDataSessionQosClass:1.0
 */
 
static const value_string org_csapi_TpDataSessionQosClass[] = {

   { 0, "P_DATA_SESSION_QOS_CLASS_CONVERSATIONAL" }, 
   { 1, "P_DATA_SESSION_QOS_CLASS_STREAMING" }, 
   { 2, "P_DATA_SESSION_QOS_CLASS_INTERACTIVE" }, 
   { 3, "P_DATA_SESSION_QOS_CLASS_BACKGROUND" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/TpSimpleAttributeTypeInfo:1.0
 */
 
static const value_string org_csapi_TpSimpleAttributeTypeInfo[] = {

   { 0, "P_BOOLEAN" }, 
   { 1, "P_OCTET" }, 
   { 2, "P_CHAR" }, 
   { 3, "P_WCHAR" }, 
   { 4, "P_STRING" }, 
   { 5, "P_WSTRING" }, 
   { 6, "P_INT16" }, 
   { 7, "P_UNSIGNED_INT16" }, 
   { 8, "P_INT32" }, 
   { 9, "P_UNSIGNED_INT32" }, 
   { 10, "P_INT64" }, 
   { 11, "P_UNSIGNED_INT64" }, 
   { 12, "P_FLOAT" }, 
   { 13, "P_DOUBLE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/TpAttributeTagInfo:1.0
 */
 
static const value_string org_csapi_TpAttributeTagInfo[] = {

   { 0, "P_SIMPLE_TYPE" }, 
   { 1, "P_STRUCTURED_TYPE" }, 
   { 2, "P_XML_TYPE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpAPIUnavailReason:1.0
 */
 
static const value_string org_csapi_fw_TpAPIUnavailReason[] = {

   { 0, "API_UNAVAILABLE_UNDEFINED" }, 
   { 1, "API_UNAVAILABLE_LOCAL_FAILURE" }, 
   { 2, "API_UNAVAILABLE_GATEWAY_FAILURE" }, 
   { 3, "API_UNAVAILABLE_OVERLOADED" }, 
   { 4, "API_UNAVAILABLE_CLOSED" }, 
   { 5, "API_UNAVAILABLE_PROTOCOL_FAILURE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpDomainIDType:1.0
 */
 
static const value_string org_csapi_fw_TpDomainIDType[] = {

   { 0, "P_FW" }, 
   { 1, "P_CLIENT_APPLICATION" }, 
   { 2, "P_ENT_OP" }, 
   { 3, "P_SERVICE_INSTANCE" }, 
   { 4, "P_SERVICE_SUPPLIER" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpFwEventName:1.0
 */
 
static const value_string org_csapi_fw_TpFwEventName[] = {

   { 0, "P_EVENT_FW_NAME_UNDEFINED" }, 
   { 1, "P_EVENT_FW_SERVICE_AVAILABLE" }, 
   { 2, "P_EVENT_FW_SERVICE_UNAVAILABLE" }, 
   { 3, "P_EVENT_FW_MIGRATION_SERVICE_AVAILABLE" }, 
   { 4, "P_EVENT_FW_APP_SESSION_CREATED" }, 
   { 5, "P_EVENT_FW_APP_SESSION_TERMINATED" }, 
   { 6, "P_EVENT_FW_APP_AGREEMENT_SIGNED" }, 
   { 7, "P_EVENT_FW_APP_AGREEMENT_ENDED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpFWExceptionType:1.0
 */
 
static const value_string org_csapi_fw_TpFWExceptionType[] = {

   { 0, "P_FW_DUMMY" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpFwUnavailReason:1.0
 */
 
static const value_string org_csapi_fw_TpFwUnavailReason[] = {

   { 0, "FW_UNAVAILABLE_UNDEFINED" }, 
   { 1, "FW_UNAVAILABLE_LOCAL_FAILURE" }, 
   { 2, "FW_UNAVAILABLE_GATEWAY_FAILURE" }, 
   { 3, "FW_UNAVAILABLE_OVERLOADED" }, 
   { 4, "FW_UNAVAILABLE_CLOSED" }, 
   { 5, "FW_UNAVAILABLE_PROTOCOL_FAILURE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpInterfaceFault:1.0
 */
 
static const value_string org_csapi_fw_TpInterfaceFault[] = {

   { 0, "INTERFACE_FAULT_UNDEFINED" }, 
   { 1, "INTERFACE_FAULT_LOCAL_FAILURE" }, 
   { 2, "INTERFACE_FAULT_GATEWAY_FAILURE" }, 
   { 3, "INTERFACE_FAULT_PROTOCOL_ERROR" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpLoadLevel:1.0
 */
 
static const value_string org_csapi_fw_TpLoadLevel[] = {

   { 0, "LOAD_LEVEL_NORMAL" }, 
   { 1, "LOAD_LEVEL_OVERLOAD" }, 
   { 2, "LOAD_LEVEL_SEVERE_OVERLOAD" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpLoadStatisticEntityType:1.0
 */
 
static const value_string org_csapi_fw_TpLoadStatisticEntityType[] = {

   { 0, "P_LOAD_STATISTICS_FW_TYPE" }, 
   { 1, "P_LOAD_STATISTICS_SVC_TYPE" }, 
   { 2, "P_LOAD_STATISTICS_APP_TYPE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpLoadStatisticInfoType:1.0
 */
 
static const value_string org_csapi_fw_TpLoadStatisticInfoType[] = {

   { 0, "P_LOAD_STATISTICS_VALID" }, 
   { 1, "P_LOAD_STATISTICS_INVALID" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpLoadStatusError:1.0
 */
 
static const value_string org_csapi_fw_TpLoadStatusError[] = {

   { 0, "LOAD_STATUS_ERROR_UNDEFINED" }, 
   { 1, "LOAD_STATUS_ERROR_UNAVAILABLE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpServiceTypePropertyMode:1.0
 */
 
static const value_string org_csapi_fw_TpServiceTypePropertyMode[] = {

   { 0, "NORMAL" }, 
   { 1, "MANDATORY" }, 
   { 2, "READONLY" }, 
   { 3, "MANDATORY_READONLY" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpSvcUnavailReason:1.0
 */
 
static const value_string org_csapi_fw_TpSvcUnavailReason[] = {

   { 0, "SERVICE_UNAVAILABLE_UNDEFINED" }, 
   { 1, "SERVICE_UNAVAILABLE_LOCAL_FAILURE" }, 
   { 2, "SERVICE_UNAVAILABLE_GATEWAY_FAILURE" }, 
   { 3, "SERVICE_UNAVAILABLE_OVERLOADED" }, 
   { 4, "SERVICE_UNAVAILABLE_CLOSED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpLoadStatisticError:1.0
 */
 
static const value_string org_csapi_fw_TpLoadStatisticError[] = {

   { 0, "P_LOAD_INFO_ERROR_UNDEFINED" }, 
   { 1, "P_LOAD_INFO_UNAVAILABLE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpSubjectType:1.0
 */
 
static const value_string org_csapi_fw_TpSubjectType[] = {

   { 0, "P_SUBJECT_UNDEFINED" }, 
   { 1, "P_SUBJECT_CLIENT_APP" }, 
   { 2, "P_SUBJECT_FW" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpFaultStatisticsError:1.0
 */
 
static const value_string org_csapi_fw_TpFaultStatisticsError[] = {

   { 0, "P_FAULT_INFO_ERROR_UNDEFINED" }, 
   { 1, "P_FAULT_INFO_UNAVAILABLE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpSvcAvailStatusReason:1.0
 */
 
static const value_string org_csapi_fw_TpSvcAvailStatusReason[] = {

   { 0, "SVC_UNAVAILABLE_UNDEFINED" }, 
   { 1, "SVC_UNAVAILABLE_LOCAL_FAILURE" }, 
   { 2, "SVC_UNAVAILABLE_GATEWAY_FAILURE" }, 
   { 3, "SVC_UNAVAILABLE_OVERLOADED" }, 
   { 4, "SVC_UNAVAILABLE_CLOSED" }, 
   { 5, "SVC_UNAVAILABLE_NO_RESPONSE" }, 
   { 6, "SVC_UNAVAILABLE_SW_UPGRADE" }, 
   { 7, "SVC_AVAILABLE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpAppAvailStatusReason:1.0
 */
 
static const value_string org_csapi_fw_TpAppAvailStatusReason[] = {

   { 0, "APP_UNAVAILABLE_UNDEFINED" }, 
   { 1, "APP_UNAVAILABLE_LOCAL_FAILURE" }, 
   { 2, "APP_UNAVAILABLE_REMOTE_FAILURE" }, 
   { 3, "APP_UNAVAILABLE_OVERLOADED" }, 
   { 4, "APP_UNAVAILABLE_CLOSED" }, 
   { 5, "APP_UNAVAILABLE_NO_RESPONSE" }, 
   { 6, "APP_UNAVAILABLE_SW_UPGRADE" }, 
   { 7, "APP_AVAILABLE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpMigrationAdditionalInfoType:1.0
 */
 
static const value_string org_csapi_fw_TpMigrationAdditionalInfoType[] = {

   { 0, "P_MIGRATION_INFO_UNDEFINED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpFwAvailStatusReason:1.0
 */
 
static const value_string org_csapi_fw_TpFwAvailStatusReason[] = {

   { 0, "FRAMEWORK_UNAVAILABLE_UNDEFINED" }, 
   { 1, "FRAMEWORK_UNAVAILABLE_LOCAL_FAILURE" }, 
   { 2, "FRAMEWORK_UNAVAILABLE_REMOTE_FAILURE" }, 
   { 3, "FRAMEWORK_UNAVAILABLE_OVERLOADED" }, 
   { 4, "FRAMEWORK_UNAVAILABLE_CLOSED" }, 
   { 5, "FRAMEWORK_UNAVAILABLE_PROTOCOL_FAILURE" }, 
   { 6, "FRAMEWORK_UNAVAILABLE_SW_UPGRADE" }, 
   { 7, "FRAMEWORK_AVAILABLE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUIVariablePartType:1.0
 */
 
static const value_string org_csapi_ui_TpUIVariablePartType[] = {

   { 0, "P_UI_VARIABLE_PART_INT" }, 
   { 1, "P_UI_VARIABLE_PART_ADDRESS" }, 
   { 2, "P_UI_VARIABLE_PART_TIME" }, 
   { 3, "P_UI_VARIABLE_PART_DATE" }, 
   { 4, "P_UI_VARIABLE_PART_PRICE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUIReport:1.0
 */
 
static const value_string org_csapi_ui_TpUIReport[] = {

   { 0, "P_UI_REPORT_UNDEFINED" }, 
   { 1, "P_UI_REPORT_INFO_SENT" }, 
   { 2, "P_UI_REPORT_INFO_COLLECTED" }, 
   { 3, "P_UI_REPORT_NO_INPUT" }, 
   { 4, "P_UI_REPORT_TIMEOUT" }, 
   { 5, "P_UI_REPORT_MESSAGE_STORED" }, 
   { 6, "P_UI_REPORT_MESSAGE_NOT_STORED" }, 
   { 7, "P_UI_REPORT_MESSAGE_DELETED" }, 
   { 8, "P_UI_REPORT_MESSAGE_NOT_DELETED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUIInfoType:1.0
 */
 
static const value_string org_csapi_ui_TpUIInfoType[] = {

   { 0, "P_UI_INFO_ID" }, 
   { 1, "P_UI_INFO_DATA" }, 
   { 2, "P_UI_INFO_ADDRESS" }, 
   { 3, "P_UI_INFO_BIN_DATA" }, 
   { 4, "P_UI_INFO_UUENCODED" }, 
   { 5, "P_UI_INFO_MIME" }, 
   { 6, "P_UI_INFO_WAVE" }, 
   { 7, "P_UI_INFO_AU" }, 
   { 8, "P_UI_INFO_VXML" }, 
   { 9, "P_UI_INFO_SYNTHESIS" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUIFault:1.0
 */
 
static const value_string org_csapi_ui_TpUIFault[] = {

   { 0, "P_UI_FAULT_UNDEFINED" }, 
   { 1, "P_UI_CALL_ENDED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUIEventInfoDataType:1.0
 */
 
static const value_string org_csapi_ui_TpUIEventInfoDataType[] = {

   { 0, "P_UI_EVENT_DATA_TYPE_UNDEFINED" }, 
   { 1, "P_UI_EVENT_DATA_TYPE_UNSPECIFIED" }, 
   { 2, "P_UI_EVENT_DATA_TYPE_TEXT" }, 
   { 3, "P_UI_EVENT_DATA_TYPE_USSD_DATA" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUIError:1.0
 */
 
static const value_string org_csapi_ui_TpUIError[] = {

   { 0, "P_UI_ERROR_UNDEFINED" }, 
   { 1, "P_UI_ERROR_ILLEGAL_INFO" }, 
   { 2, "P_UI_ERROR_ID_NOT_FOUND" }, 
   { 3, "P_UI_ERROR_RESOURCE_UNAVAILABLE" }, 
   { 4, "P_UI_ERROR_ILLEGAL_RANGE" }, 
   { 5, "P_UI_ERROR_IMPROPER_USER_RESPONSE" }, 
   { 6, "P_UI_ERROR_ABANDON" }, 
   { 7, "P_UI_ERROR_NO_OPERATION_ACTIVE" }, 
   { 8, "P_UI_ERROR_NO_SPACE_AVAILABLE" }, 
   { 9, "P_UI_ERROR_RESOURCE_TIMEOUT" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUICollectMode:1.0
 */
 
static const value_string org_csapi_ui_TpUICollectMode[] = {

   { 0, "P_UI_COLLECT_MODE_DTMF" }, 
   { 1, "P_UI_COLLECT_MODE_VOICE" }, 
   { 2, "P_UI_COLLECT_MODE_DTMFANDVOICE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUIPronounceType:1.0
 */
 
static const value_string org_csapi_ui_TpUIPronounceType[] = {

   { 0, "P_UI_PRONOUNCE_IPA" }, 
   { 1, "P_UI_PRONOUNCE_SOUNDSLIKE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUISynthesisRange:1.0
 */
 
static const value_string org_csapi_ui_TpUISynthesisRange[] = {

   { 0, "P_UI_RANGE_CALMER" }, 
   { 1, "P_UI_RANGE_CALM" }, 
   { 2, "P_UI_RANGE_AVERAGE" }, 
   { 3, "P_UI_RANGE_EXCITED" }, 
   { 4, "P_UI_RANGE_MORE_EXCITED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUISynthesisRate:1.0
 */
 
static const value_string org_csapi_ui_TpUISynthesisRate[] = {

   { 0, "P_UI_RATE_SLOW" }, 
   { 1, "P_UI_RATE_AVERAGE" }, 
   { 2, "P_UI_RATE_FAST" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUISynthesisAge:1.0
 */
 
static const value_string org_csapi_ui_TpUISynthesisAge[] = {

   { 0, "P_UI_AGE_CHILD" }, 
   { 1, "P_UI_AGE_YOUNG_ADULT" }, 
   { 2, "P_UI_AGE_ADULT" }, 
   { 3, "P_UI_AGE_OLDER_ADULT" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUISynthesisGender:1.0
 */
 
static const value_string org_csapi_ui_TpUISynthesisGender[] = {

   { 0, "P_UI_GENDER_MALE" }, 
   { 1, "P_UI_GENDER_FEMALE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpReleaseCause:1.0
 */
 
static const value_string org_csapi_cc_TpReleaseCause[] = {

   { 0, "P_UNDEFINED" }, 
   { 1, "P_USER_NOT_AVAILABLE" }, 
   { 2, "P_BUSY" }, 
   { 3, "P_NO_ANSWER" }, 
   { 4, "P_NOT_REACHABLE" }, 
   { 5, "P_ROUTING_FAILURE" }, 
   { 6, "P_PREMATURE_DISCONNECT" }, 
   { 7, "P_DISCONNECTED" }, 
   { 8, "P_CALL_RESTRICTED" }, 
   { 9, "P_UNAVAILABLE_RESOURCE" }, 
   { 10, "P_GENERAL_FAILURE" }, 
   { 11, "P_TIMER_EXPIRY" }, 
   { 12, "P_UNSUPPORTED_MEDIA" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallMonitorMode:1.0
 */
 
static const value_string org_csapi_cc_TpCallMonitorMode[] = {

   { 0, "P_CALL_MONITOR_MODE_INTERRUPT" }, 
   { 1, "P_CALL_MONITOR_MODE_NOTIFY" }, 
   { 2, "P_CALL_MONITOR_MODE_DO_NOT_MONITOR" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallBearerService:1.0
 */
 
static const value_string org_csapi_cc_TpCallBearerService[] = {

   { 0, "P_CALL_BEARER_SERVICE_UNKNOWN" }, 
   { 1, "P_CALL_BEARER_SERVICE_SPEECH" }, 
   { 2, "P_CALL_BEARER_SERVICE_DIGITALUNRESTRICTED" }, 
   { 3, "P_CALL_BEARER_SERVICE_DIGITALRESTRICTED" }, 
   { 4, "P_CALL_BEARER_SERVICE_AUDIO" }, 
   { 5, "P_CALL_BEARER_SERVICE_DIGITALUNRESTRICTEDTONES" }, 
   { 6, "P_CALL_BEARER_SERVICE_VIDEO" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallChargeOrderCategory:1.0
 */
 
static const value_string org_csapi_cc_TpCallChargeOrderCategory[] = {

   { 0, "P_CALL_CHARGE_TRANSPARENT" }, 
   { 1, "P_CALL_CHARGE_PREDEFINED_SET" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallErrorType:1.0
 */
 
static const value_string org_csapi_cc_TpCallErrorType[] = {

   { 0, "P_CALL_ERROR_UNDEFINED" }, 
   { 1, "P_CALL_ERROR_INVALID_ADDRESS" }, 
   { 2, "P_CALL_ERROR_INVALID_STATE" }, 
   { 3, "P_CALL_ERROR_RESOURCE_UNAVAILABLE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallLoadControlMechanismType:1.0
 */
 
static const value_string org_csapi_cc_TpCallLoadControlMechanismType[] = {

   { 0, "P_CALL_LOAD_CONTROL_PER_INTERVAL" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallNetworkAccessType:1.0
 */
 
static const value_string org_csapi_cc_TpCallNetworkAccessType[] = {

   { 0, "P_CALL_NETWORK_ACCESS_TYPE_UNKNOWN" }, 
   { 1, "P_CALL_NETWORK_ACCESS_TYPE_POT" }, 
   { 2, "P_CALL_NETWORK_ACCESS_TYPE_ISDN" }, 
   { 3, "P_CALL_NETWORK_ACCESS_TYPE_DIALUPINTERNET" }, 
   { 4, "P_CALL_NETWORK_ACCESS_TYPE_XDSL" }, 
   { 5, "P_CALL_NETWORK_ACCESS_TYPE_WIRELESS" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallPartyCategory:1.0
 */
 
static const value_string org_csapi_cc_TpCallPartyCategory[] = {

   { 0, "P_CALL_PARTY_CATEGORY_UNKNOWN" }, 
   { 1, "P_CALL_PARTY_CATEGORY_OPERATOR_F" }, 
   { 2, "P_CALL_PARTY_CATEGORY_OPERATOR_E" }, 
   { 3, "P_CALL_PARTY_CATEGORY_OPERATOR_G" }, 
   { 4, "P_CALL_PARTY_CATEGORY_OPERATOR_R" }, 
   { 5, "P_CALL_PARTY_CATEGORY_OPERATOR_S" }, 
   { 6, "P_CALL_PARTY_CATEGORY_ORDINARY_SUB" }, 
   { 7, "P_CALL_PARTY_CATEGORY_PRIORITY_SUB" }, 
   { 8, "P_CALL_PARTY_CATEGORY_DATA_CALL" }, 
   { 9, "P_CALL_PARTY_CATEGORY_TEST_CALL" }, 
   { 10, "P_CALL_PARTY_CATEGORY_PAYPHONE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallServiceCodeType:1.0
 */
 
static const value_string org_csapi_cc_TpCallServiceCodeType[] = {

   { 0, "P_CALL_SERVICE_CODE_UNDEFINED" }, 
   { 1, "P_CALL_SERVICE_CODE_DIGITS" }, 
   { 2, "P_CALL_SERVICE_CODE_FACILITY" }, 
   { 3, "P_CALL_SERVICE_CODE_U2U" }, 
   { 4, "P_CALL_SERVICE_CODE_HOOKFLASH" }, 
   { 5, "P_CALL_SERVICE_CODE_RECALL" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallTeleService:1.0
 */
 
static const value_string org_csapi_cc_TpCallTeleService[] = {

   { 0, "P_CALL_TELE_SERVICE_UNKNOWN" }, 
   { 1, "P_CALL_TELE_SERVICE_TELEPHONY" }, 
   { 2, "P_CALL_TELE_SERVICE_FAX_2_3" }, 
   { 3, "P_CALL_TELE_SERVICE_FAX_4_I" }, 
   { 4, "P_CALL_TELE_SERVICE_FAX_4_II_III" }, 
   { 5, "P_CALL_TELE_SERVICE_VIDEOTEX_SYN" }, 
   { 6, "P_CALL_TELE_SERVICE_VIDEOTEX_INT" }, 
   { 7, "P_CALL_TELE_SERVICE_TELEX" }, 
   { 8, "P_CALL_TELE_SERVICE_MHS" }, 
   { 9, "P_CALL_TELE_SERVICE_OSI" }, 
   { 10, "P_CALL_TELE_SERVICE_FTAM" }, 
   { 11, "P_CALL_TELE_SERVICE_VIDEO" }, 
   { 12, "P_CALL_TELE_SERVICE_VIDEO_CONF" }, 
   { 13, "P_CALL_TELE_SERVICE_AUDIOGRAPH_CONF" }, 
   { 14, "P_CALL_TELE_SERVICE_MULTIMEDIA" }, 
   { 15, "P_CALL_TELE_SERVICE_CS_INI_H221" }, 
   { 16, "P_CALL_TELE_SERVICE_CS_SUB_H221" }, 
   { 17, "P_CALL_TELE_SERVICE_CS_INI_CALL" }, 
   { 18, "P_CALL_TELE_SERVICE_DATATRAFFIC" }, 
   { 19, "P_CALL_TELE_SERVICE_EMERGENCY_CALLS" }, 
   { 20, "P_CALL_TELE_SERVICE_SMS_MT_PP" }, 
   { 21, "P_CALL_TELE_SERVICE_SMS_MO_PP" }, 
   { 22, "P_CALL_TELE_SERVICE_CELL_BROADCAST" }, 
   { 23, "P_CALL_TELE_SERVICE_ALT_SPEECH_FAX_3" }, 
   { 24, "P_CALL_TELE_SERVICE_AUTOMATIC_FAX_3" }, 
   { 25, "P_CALL_TELE_SERVICE_VOICE_GROUP_CALL" }, 
   { 26, "P_CALL_TELE_SERVICE_VOICE_BROADCAST" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallTreatmentType:1.0
 */
 
static const value_string org_csapi_cc_TpCallTreatmentType[] = {

   { 0, "P_CALL_TREATMENT_DEFAULT" }, 
   { 1, "P_CALL_TREATMENT_RELEASE" }, 
   { 2, "P_CALL_TREATMENT_SIAR" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallPartyToChargeType:1.0
 */
 
static const value_string org_csapi_cc_TpCallPartyToChargeType[] = {

   { 0, "P_CALL_PARTY_ORIGINATING" }, 
   { 1, "P_CALL_PARTY_DESTINATION" }, 
   { 2, "P_CALL_PARTY_SPECIAL" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/gccs/TpCallNotificationType:1.0
 */
 
static const value_string org_csapi_cc_gccs_TpCallNotificationType[] = {

   { 0, "P_ORIGINATING" }, 
   { 1, "P_TERMINATING" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/gccs/TpCallAppInfoType:1.0
 */
 
static const value_string org_csapi_cc_gccs_TpCallAppInfoType[] = {

   { 0, "P_CALL_APP_UNDEFINED" }, 
   { 1, "P_CALL_APP_ALERTING_MECHANISM" }, 
   { 2, "P_CALL_APP_NETWORK_ACCESS_TYPE" }, 
   { 3, "P_CALL_APP_TELE_SERVICE" }, 
   { 4, "P_CALL_APP_BEARER_SERVICE" }, 
   { 5, "P_CALL_APP_PARTY_CATEGORY" }, 
   { 6, "P_CALL_APP_PRESENTATION_ADDRESS" }, 
   { 7, "P_CALL_APP_GENERIC_INFO" }, 
   { 8, "P_CALL_APP_ADDITIONAL_ADDRESS" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/gccs/TpCallReportType:1.0
 */
 
static const value_string org_csapi_cc_gccs_TpCallReportType[] = {

   { 0, "P_CALL_REPORT_UNDEFINED" }, 
   { 1, "P_CALL_REPORT_PROGRESS" }, 
   { 2, "P_CALL_REPORT_ALERTING" }, 
   { 3, "P_CALL_REPORT_ANSWER" }, 
   { 4, "P_CALL_REPORT_BUSY" }, 
   { 5, "P_CALL_REPORT_NO_ANSWER" }, 
   { 6, "P_CALL_REPORT_DISCONNECT" }, 
   { 7, "P_CALL_REPORT_REDIRECTED" }, 
   { 8, "P_CALL_REPORT_SERVICE_CODE" }, 
   { 9, "P_CALL_REPORT_ROUTING_FAILURE" }, 
   { 10, "P_CALL_REPORT_QUEUED" }, 
   { 11, "P_CALL_REPORT_NOT_REACHABLE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/gccs/TpCallFault:1.0
 */
 
static const value_string org_csapi_cc_gccs_TpCallFault[] = {

   { 0, "P_CALL_FAULT_UNDEFINED" }, 
   { 1, "P_CALL_TIMEOUT_ON_RELEASE" }, 
   { 2, "P_CALL_TIMEOUT_ON_INTERRUPT" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallAppInfoType:1.0
 */
 
static const value_string org_csapi_cc_TpCallAppInfoType[] = {

   { 0, "P_CALL_APP_UNDEFINED" }, 
   { 1, "P_CALL_APP_ALERTING_MECHANISM" }, 
   { 2, "P_CALL_APP_NETWORK_ACCESS_TYPE" }, 
   { 3, "P_CALL_APP_TELE_SERVICE" }, 
   { 4, "P_CALL_APP_BEARER_SERVICE" }, 
   { 5, "P_CALL_APP_PARTY_CATEGORY" }, 
   { 6, "P_CALL_APP_PRESENTATION_ADDRESS" }, 
   { 7, "P_CALL_APP_GENERIC_INFO" }, 
   { 8, "P_CALL_APP_ADDITIONAL_ADDRESS" }, 
   { 9, "P_CALL_APP_ORIGINAL_DESTINATION_ADDRESS" }, 
   { 10, "P_CALL_APP_REDIRECTING_ADDRESS" }, 
   { 11, "P_CALL_APP_HIGH_PROBABILITY_COMPLETION" }, 
   { 12, "P_CALL_APP_CARRIER" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallEventType:1.0
 */
 
static const value_string org_csapi_cc_TpCallEventType[] = {

   { 0, "P_CALL_EVENT_UNDEFINED" }, 
   { 1, "P_CALL_EVENT_ORIGINATING_CALL_ATTEMPT" }, 
   { 2, "P_CALL_EVENT_ORIGINATING_CALL_ATTEMPT_AUTHORISED" }, 
   { 3, "P_CALL_EVENT_ADDRESS_COLLECTED" }, 
   { 4, "P_CALL_EVENT_ADDRESS_ANALYSED" }, 
   { 5, "P_CALL_EVENT_ORIGINATING_SERVICE_CODE" }, 
   { 6, "P_CALL_EVENT_ORIGINATING_RELEASE" }, 
   { 7, "P_CALL_EVENT_TERMINATING_CALL_ATTEMPT" }, 
   { 8, "P_CALL_EVENT_TERMINATING_CALL_ATTEMPT_AUTHORISED" }, 
   { 9, "P_CALL_EVENT_ALERTING" }, 
   { 10, "P_CALL_EVENT_ANSWER" }, 
   { 11, "P_CALL_EVENT_TERMINATING_RELEASE" }, 
   { 12, "P_CALL_EVENT_REDIRECTED" }, 
   { 13, "P_CALL_EVENT_TERMINATING_SERVICE_CODE" }, 
   { 14, "P_CALL_EVENT_QUEUED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallLegAttachMechanism:1.0
 */
 
static const value_string org_csapi_cc_TpCallLegAttachMechanism[] = {

   { 0, "P_CALLLEG_ATTACH_IMPLICITLY" }, 
   { 1, "P_CALLLEG_ATTACH_EXPLICITLY" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCarrierSelectionField:1.0
 */
 
static const value_string org_csapi_cc_TpCarrierSelectionField[] = {

   { 0, "P_CIC_UNDEFINED" }, 
   { 1, "P_CIC_NO_INPUT" }, 
   { 2, "P_CIC_INPUT" }, 
   { 3, "P_CIC_UNDETERMINED" }, 
   { 4, "P_CIC_NOT_PRESCRIBED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/mpccs/TpAppMultiPartyCallBackRefType:1.0
 */
 
static const value_string org_csapi_cc_mpccs_TpAppMultiPartyCallBackRefType[] = {

   { 0, "P_APP_CALLBACK_UNDEFINED" }, 
   { 1, "P_APP_MULTIPARTY_CALL_CALLBACK" }, 
   { 2, "P_APP_CALL_LEG_CALLBACK" }, 
   { 3, "P_APP_CALL_AND_CALL_LEG_CALLBACK" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/mmccs/TpMediaStreamDirection:1.0
 */
 
static const value_string org_csapi_cc_mmccs_TpMediaStreamDirection[] = {

   { 0, "P_SEND_ONLY" }, 
   { 1, "P_RECEIVE_ONLY" }, 
   { 2, "P_SEND_RECEIVE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/mmccs/TpMediaStreamEventType:1.0
 */
 
static const value_string org_csapi_cc_mmccs_TpMediaStreamEventType[] = {

   { 0, "P_MEDIA_STREAM_ADDED" }, 
   { 1, "P_MEDIA_STREAM_SUBTRACTED" }, 
   { 2, "P_MEDIA_STREAM_QOS_CLASS_CHANGED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/mmccs/TpMediaStreamDataTypeRequestType:1.0
 */
 
static const value_string org_csapi_cc_mmccs_TpMediaStreamDataTypeRequestType[] = {

   { 0, "P_AUDIO_CAPABILITIES" }, 
   { 1, "P_VIDEO_CAPABILITIES" }, 
   { 2, "P_DATA_CAPABILITIES" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/mmccs/TpAppMultiMediaCallBackRefType:1.0
 */
 
static const value_string org_csapi_cc_mmccs_TpAppMultiMediaCallBackRefType[] = {

   { 0, "P_APP_CALLBACK_UNDEFINED" }, 
   { 1, "P_APP_MULTIMEDIA_CALL_CALLBACK" }, 
   { 2, "P_APP_CALL_LEG_CALLBACK" }, 
   { 3, "P_APP_CALL_AND_CALL_LEG_CALLBACK" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/cccs/TpConfPolicyType:1.0
 */
 
static const value_string org_csapi_cc_cccs_TpConfPolicyType[] = {

   { 0, "P_CONFERENCE_POLICY_UNDEFINED" }, 
   { 1, "P_CONFERENCE_POLICY_MONOMEDIA" }, 
   { 2, "P_CONFERENCE_POLICY_MULTIMEDIA" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/cccs/TpVideoHandlingType:1.0
 */
 
static const value_string org_csapi_cc_cccs_TpVideoHandlingType[] = {

   { 0, "P_MIXED_VIDEO" }, 
   { 1, "P_SWITCHED_VIDEO_CHAIR_CONTROLLED" }, 
   { 2, "P_SWITCHED_VIDEO_VOICE_CONTROLLED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUITargetObjectType:1.0
 */
 
static const value_string org_csapi_ui_TpUITargetObjectType[] = {

   { 0, "P_UI_TARGET_OBJECT_CALL" }, 
   { 1, "P_UI_TARGET_OBJECT_MULTI_PARTY_CALL" }, 
   { 2, "P_UI_TARGET_OBJECT_CALL_LEG" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpLocationPriority:1.0
 */
 
static const value_string org_csapi_mm_TpLocationPriority[] = {

   { 0, "P_M_NORMAL" }, 
   { 1, "P_M_HIGH" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpLocationResponseIndicator:1.0
 */
 
static const value_string org_csapi_mm_TpLocationResponseIndicator[] = {

   { 0, "P_M_NO_DELAY" }, 
   { 1, "P_M_LOW_DELAY" }, 
   { 2, "P_M_DELAY_TOLERANT" }, 
   { 3, "P_M_USE_TIMER_VALUE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpLocationTriggerCriteria:1.0
 */
 
static const value_string org_csapi_mm_TpLocationTriggerCriteria[] = {

   { 0, "P_UL_ENTERING_AREA" }, 
   { 1, "P_UL_LEAVING_AREA" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpLocationType:1.0
 */
 
static const value_string org_csapi_mm_TpLocationType[] = {

   { 0, "P_M_CURRENT" }, 
   { 1, "P_M_CURRENT_OR_LAST_KNOWN" }, 
   { 2, "P_M_INITIAL" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpLocationUncertaintyShape:1.0
 */
 
static const value_string org_csapi_mm_TpLocationUncertaintyShape[] = {

   { 0, "P_M_SHAPE_NONE" }, 
   { 1, "P_M_SHAPE_CIRCLE" }, 
   { 2, "P_M_SHAPE_CIRCLE_SECTOR" }, 
   { 3, "P_M_SHAPE_CIRCLE_ARC_STRIPE" }, 
   { 4, "P_M_SHAPE_ELLIPSE" }, 
   { 5, "P_M_SHAPE_ELLIPSE_SECTOR" }, 
   { 6, "P_M_SHAPE_ELLIPSE_ARC_STRIPE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpMobilityDiagnostic:1.0
 */
 
static const value_string org_csapi_mm_TpMobilityDiagnostic[] = {

   { 0, "P_M_NO_INFORMATION" }, 
   { 1, "P_M_APPL_NOT_IN_PRIV_EXCEPT_LST" }, 
   { 2, "P_M_CALL_TO_USER_NOT_SETUP" }, 
   { 3, "P_M_PRIVACY_OVERRIDE_NOT_APPLIC" }, 
   { 4, "P_M_DISALL_BY_LOCAL_REGULAT_REQ" }, 
   { 5, "P_M_CONGESTION" }, 
   { 6, "P_M_INSUFFICIENT_RESOURCES" }, 
   { 7, "P_M_INSUFFICIENT_MEAS_DATA" }, 
   { 8, "P_M_INCONSISTENT_MEAS_DATA" }, 
   { 9, "P_M_LOC_PROC_NOT_COMPLETED" }, 
   { 10, "P_M_LOC_PROC_NOT_SUPP_BY_USER" }, 
   { 11, "P_M_QOS_NOT_ATTAINABLE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpMobilityError:1.0
 */
 
static const value_string org_csapi_mm_TpMobilityError[] = {

   { 0, "P_M_OK" }, 
   { 1, "P_M_SYSTEM_FAILURE" }, 
   { 2, "P_M_UNAUTHORIZED_NETWORK" }, 
   { 3, "P_M_UNAUTHORIZED_APPLICATION" }, 
   { 4, "P_M_UNKNOWN_SUBSCRIBER" }, 
   { 5, "P_M_ABSENT_SUBSCRIBER" }, 
   { 6, "P_M_POSITION_METHOD_FAILURE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpMobilityStopScope:1.0
 */
 
static const value_string org_csapi_mm_TpMobilityStopScope[] = {

   { 0, "P_M_ALL_IN_ASSIGNMENT" }, 
   { 1, "P_M_SPECIFIED_USERS" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpTerminalType:1.0
 */
 
static const value_string org_csapi_mm_TpTerminalType[] = {

   { 0, "P_M_FIXED" }, 
   { 1, "P_M_MOBILE" }, 
   { 2, "P_M_IP" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpUserLocationEmergencyTrigger:1.0
 */
 
static const value_string org_csapi_mm_TpUserLocationEmergencyTrigger[] = {

   { 0, "P_ULE_CALL_ORIGINATION" }, 
   { 1, "P_ULE_CALL_RELEASE" }, 
   { 2, "P_ULE_LOCATION_REQUEST" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpUserStatusIndicator:1.0
 */
 
static const value_string org_csapi_mm_TpUserStatusIndicator[] = {

   { 0, "P_US_REACHABLE" }, 
   { 1, "P_US_NOT_REACHABLE" }, 
   { 2, "P_US_BUSY" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpAuthStatusIndicator:1.0
 */
 
static const value_string org_csapi_mm_TpAuthStatusIndicator[] = {

   { 0, "P_AUTHENTICATED_FOR_NETWORK_ONLY" }, 
   { 1, "P_AUTHENTICATED_FOR_NETWORK_AND_IP_SERVICES" }, 
   { 2, "P_NOT_AUTHENTICATED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpAccessTechnology:1.0
 */
 
static const value_string org_csapi_mm_TpAccessTechnology[] = {

   { 0, "P_MOBILE_ACCESS_PS" }, 
   { 1, "P_MOBILE_ACCESS_CS" }, 
   { 2, "P_FIXED_ACCESS" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpRoamingStatus:1.0
 */
 
static const value_string org_csapi_mm_TpRoamingStatus[] = {

   { 0, "P_UNKNOWN_ROAMING_STATUS" }, 
   { 1, "P_HOME_USER" }, 
   { 2, "P_NATIONAL_ROAMING" }, 
   { 3, "P_INTERNATIONAL_ROAMING" }, 
   { 4, "P_OPERATOR_ROAMING" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpBindingEntryType:1.0
 */
 
static const value_string org_csapi_mm_TpBindingEntryType[] = {

   { 0, "P_UB_UNDEFINED" }, 
   { 1, "P_UB_EXPIRES" }, 
   { 2, "P_UB_CONTACT_ADDRESS" }, 
   { 3, "P_UB_PREFERENCE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/termcap/TpTerminalCapabilitiesError:1.0
 */
 
static const value_string org_csapi_termcap_TpTerminalCapabilitiesError[] = {

   { 0, "P_TERMCAP_ERROR_UNDEFINED" }, 
   { 1, "P_TERMCAP_INVALID_TERMINALID" }, 
   { 2, "P_TERMCAP_SYSTEM_FAILURE" }, 
   { 3, "P_TERMCAP_INFO_UNAVAILABLE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/termcap/TpTerminalCapabilityScopeType:1.0
 */
 
static const value_string org_csapi_termcap_TpTerminalCapabilityScopeType[] = {

   { 0, "P_TERMINAL_CAPABILITY_SCOPE_TYPE_UNDEFINED" }, 
   { 1, "P_TERMINAL_CAPABILITY_SCOPE_TYPE_CCPP" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/dsc/TpDataSessionChargeOrderCategory:1.0
 */
 
static const value_string org_csapi_dsc_TpDataSessionChargeOrderCategory[] = {

   { 0, "P_DATA_SESSION_CHARGE_PER_VOLUME" }, 
   { 1, "P_DATA_SESSION_CHARGE_NETWORK" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/dsc/TpDataSessionErrorType:1.0
 */
 
static const value_string org_csapi_dsc_TpDataSessionErrorType[] = {

   { 0, "P_DATA_SESSION_ERROR_UNDEFINED" }, 
   { 1, "P_DATA_SESSION_ERROR_INVALID_ADDRESS" }, 
   { 2, "P_DATA_SESSION_ERROR_INVALID_STATE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/dsc/TpDataSessionFault:1.0
 */
 
static const value_string org_csapi_dsc_TpDataSessionFault[] = {

   { 0, "P_DATA_SESSION_FAULT_UNDEFINED" }, 
   { 1, "P_DATA_SESSION_FAULT_USER_ABORTED" }, 
   { 2, "P_DATA_SESSION_TIMEOUT_ON_RELEASE" }, 
   { 3, "P_DATA_SESSION_TIMEOUT_ON_INTERRUPT" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/dsc/TpDataSessionMonitorMode:1.0
 */
 
static const value_string org_csapi_dsc_TpDataSessionMonitorMode[] = {

   { 0, "P_DATA_SESSION_MONITOR_MODE_INTERRUPT" }, 
   { 1, "P_DATA_SESSION_MONITOR_MODE_NOTIFY" }, 
   { 2, "P_DATA_SESSION_MONITOR_MODE_DO_NOT_MONITOR" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/dsc/TpDataSessionReportType:1.0
 */
 
static const value_string org_csapi_dsc_TpDataSessionReportType[] = {

   { 0, "P_DATA_SESSION_REPORT_UNDEFINED" }, 
   { 1, "P_DATA_SESSION_REPORT_CONNECTED" }, 
   { 2, "P_DATA_SESSION_REPORT_DISCONNECT" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpMessagingFault:1.0
 */
 
static const value_string org_csapi_gms_TpMessagingFault[] = {

   { 0, "P_MESSAGING_FAULT_UNDEFINED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpMessagingEventName:1.0
 */
 
static const value_string org_csapi_gms_TpMessagingEventName[] = {

   { 0, "P_EVENT_GMS_NAME_UNDEFINED" }, 
   { 1, "P_EVENT_GMS_NEW_MESSAGE_ARRIVED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpMessageStatus:1.0
 */
 
static const value_string org_csapi_gms_TpMessageStatus[] = {

   { 0, "P_MESSAGING_MESSAGE_STATUS_READ_MESSAGE" }, 
   { 1, "P_MESSAGING_MESSAGE_STATUS_UNREAD_MESSAGE" }, 
   { 2, "P_MESSAGING_MESSAGE_STATUS_FORWARDED_MESSAGE" }, 
   { 3, "P_MESSAGING_MESSAGE_STATUS_REPLIED_TO_MESSAGE" }, 
   { 4, "P_MESSAGING_MESSAGE_STATUS_SAVED_OR_UNSENT_MESSAGE" }, 
   { 5, "P_MESSAGING_MESSAGE_STATUS_NOTIFICATION_THAT_A_MESSAGE_WAS_DELIVERED" }, 
   { 6, "P_MESSAGING_MESSAGE_STATUS_NOTIFICATION_THAT_A_MESSAGE_WAS_READ" }, 
   { 7, "P_MESSAGING_MESSAGE_STATUS_NOTIFICATION_THAT_A_MESSAGE_WAS_NOT_DELIVERED" }, 
   { 8, "P_MESSAGING_MESSAGE_STATUS_NOTIFICATION_THAT_A_MESSAGE_WAS_NOT_READ" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpMessagePriority:1.0
 */
 
static const value_string org_csapi_gms_TpMessagePriority[] = {

   { 0, "P_MESSAGING_MESSAGE_PRIORITY_UNDEFINED" }, 
   { 1, "P_MESSAGING_MESSAGE_PRIORITY_HIGH" }, 
   { 2, "P_MESSAGING_MESSAGE_PRIORITY_LOW" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpMessageInfoPropertyName:1.0
 */
 
static const value_string org_csapi_gms_TpMessageInfoPropertyName[] = {

   { 0, "P_MESSAGING_MESSAGE_UNDEFINED" }, 
   { 1, "P_MESSAGING_MESSAGE_ID" }, 
   { 2, "P_MESSAGING_MESSAGE_SUBJECT" }, 
   { 3, "P_MESSAGING_MESSAGE_DATE_SENT" }, 
   { 4, "P_MESSAGING_MESSAGE_DATE_RECEIVED" }, 
   { 5, "P_MESSAGING_MESSAGE_DATE_CHANGED" }, 
   { 6, "P_MESSAGING_MESSAGE_SENT_FROM" }, 
   { 7, "P_MESSAGING_MESSAGE_SENT_TO" }, 
   { 8, "P_MESSAGING_MESSAGE_CC_TO" }, 
   { 9, "P_MESSAGING_MESSAGE_BCC_TO" }, 
   { 10, "P_MESSAGING_MESSAGE_SIZE" }, 
   { 11, "P_MESSAGING_MESSAGE_PRIORITY" }, 
   { 12, "P_MESSAGING_MESSAGE_FORMAT" }, 
   { 13, "P_MESSAGING_MESSAGE_FOLDER" }, 
   { 14, "P_MESSAGING_MESSAGE_STATUS" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpMessageFormat:1.0
 */
 
static const value_string org_csapi_gms_TpMessageFormat[] = {

   { 0, "P_MESSAGING_MESSAGE_FORMAT_UNDEFINED" }, 
   { 1, "P_MESSAGING_MESSAGE_FORMAT_TEXT" }, 
   { 2, "P_MESSAGING_MESSAGE_FORMAT_BINARY" }, 
   { 3, "P_MESSAGING_MESSAGE_FORMAT_UUENCODED" }, 
   { 4, "P_MESSAGING_MESSAGE_FORMAT_MIME" }, 
   { 5, "P_MESSAGING_MESSAGE_FORMAT_WAVE" }, 
   { 6, "P_MESSAGING_MESSAGE_FORMAT_AU" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpMailboxInfoPropertyName:1.0
 */
 
static const value_string org_csapi_gms_TpMailboxInfoPropertyName[] = {

   { 0, "P_MESSAGING_MAILBOX_UNDEFINED" }, 
   { 1, "P_MESSAGING_MAILBOX_ID" }, 
   { 2, "P_MESSAGING_MAILBOX_OWNER" }, 
   { 3, "P_MESSAGING_MAILBOX_FOLDER" }, 
   { 4, "P_MESSAGING_MAILBOX_DATE_CREATED" }, 
   { 5, "P_MESSAGING_MAILBOX_DATE_CHANGED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpFolderInfoPropertyName:1.0
 */
 
static const value_string org_csapi_gms_TpFolderInfoPropertyName[] = {

   { 0, "P_MESSAGING_FOLDER_UNDEFINED" }, 
   { 1, "P_MESSAGING_FOLDER_ID" }, 
   { 2, "P_MESSAGING_FOLDER_MESSAGE" }, 
   { 3, "P_MESSAGING_FOLDER_SUBFOLDER" }, 
   { 4, "P_MESSAGING_FOLDER_DATE_CREATED" }, 
   { 5, "P_MESSAGING_FOLDER_DATE_CHANGED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cm/TpTrafficDirection:1.0
 */
 
static const value_string org_csapi_cm_TpTrafficDirection[] = {

   { 0, "UNIDIRECTIONAL" }, 
   { 1, "BIDIRECTIONAL" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cm/TpTagValue:1.0
 */
 
static const value_string org_csapi_cm_TpTagValue[] = {

   { 0, "PROVIDER_SPECIFIED" }, 
   { 1, "OPERATOR_SPECIFIED" }, 
   { 2, "UNSPECIFIED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cm/TpSiteOrSap:1.0
 */
 
static const value_string org_csapi_cm_TpSiteOrSap[] = {

   { 0, "SITE" }, 
   { 1, "SAP" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cm/TpIPVersion:1.0
 */
 
static const value_string org_csapi_cm_TpIPVersion[] = {

   { 0, "VERSION_UNKNOWN" }, 
   { 1, "VERSION_IPV4" }, 
   { 2, "VERSION_IPV6" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cm/TpIPv4AddType:1.0
 */
 
static const value_string org_csapi_cm_TpIPv4AddType[] = {

   { 0, "IPV4_ADD_CLASS_A" }, 
   { 1, "IPV4_ADD_CLASS_B" }, 
   { 2, "IPV4_ADD_CLASS_C" }, 
   { 3, "IPV4_ADD_CLASS_D" }, 
   { 4, "IPV4_ADD_CLASS_E" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cm/TpAction:1.0
 */
 
static const value_string org_csapi_cm_TpAction[] = {

   { 0, "DROP" }, 
   { 1, "TRANSMIT" }, 
   { 2, "RESHAPE" }, 
   { 3, "REMARK" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cm/TpVprpStatus:1.0
 */
 
static const value_string org_csapi_cm_TpVprpStatus[] = {

   { 0, "ACTIVE" }, 
   { 1, "PENDING" }, 
   { 2, "DISALLOWED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/am/TpChargingEventName:1.0
 */
 
static const value_string org_csapi_am_TpChargingEventName[] = {

   { 0, "P_AM_CHARGING" }, 
   { 1, "P_AM_RECHARGING" }, 
   { 2, "P_AM_ACCOUNT_LOW" }, 
   { 3, "P_AM_ACCOUNT_ZERO" }, 
   { 4, "P_AM_ACCOUNT_DISABLED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/am/TpBalanceQueryError:1.0
 */
 
static const value_string org_csapi_am_TpBalanceQueryError[] = {

   { 0, "P_BALANCE_QUERY_OK" }, 
   { 1, "P_BALANCE_QUERY_ERROR_UNDEFINED" }, 
   { 2, "P_BALANCE_QUERY_UNKNOWN_SUBSCRIBER" }, 
   { 3, "P_BALANCE_QUERY_UNAUTHORIZED_APPLICATION" }, 
   { 4, "P_BALANCE_QUERY_SYSTEM_FAILURE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/am/TpTransactionHistoryStatus:1.0
 */
 
static const value_string org_csapi_am_TpTransactionHistoryStatus[] = {

   { 0, "P_AM_TRANSACTION_ERROR_UNSPECIFIED" }, 
   { 1, "P_AM_TRANSACTION_INVALID_INTERVAL" }, 
   { 2, "P_AM_TRANSACTION_UNKNOWN_ACCOUNT" }, 
   { 3, "P_AM_TRANSACTION_UNAUTHORIZED_APPLICATION" }, 
   { 4, "P_AM_TRANSACTION_PROCESSING_ERROR" }, 
   { 5, "P_AM_TRANSACTION_SYSTEM_FAILURE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/am/TpVoucherError:1.0
 */
 
static const value_string org_csapi_am_TpVoucherError[] = {

   { 0, "P_VOUCHER_OK" }, 
   { 1, "P_VOUCHER_UNDEFINED" }, 
   { 2, "P_VOUCHER_UNKNOWN_SUBSCRIBER" }, 
   { 3, "P_VOUCHER_UNAUTHORIZED_APPLICATION" }, 
   { 4, "P_VOUCHER_SYSTEM_FAILURE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cs/TpChargingParameterValueType:1.0
 */
 
static const value_string org_csapi_cs_TpChargingParameterValueType[] = {

   { 0, "P_CHS_PARAMETER_INT32" }, 
   { 1, "P_CHS_PARAMETER_FLOAT" }, 
   { 2, "P_CHS_PARAMETER_STRING" }, 
   { 3, "P_CHS_PARAMETER_BOOLEAN" }, 
   { 4, "P_CHS_PARAMETER_OCTETSET" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cs/TpChargingError:1.0
 */
 
static const value_string org_csapi_cs_TpChargingError[] = {

   { 0, "P_CHS_ERR_UNDEFINED" }, 
   { 1, "P_CHS_ERR_ACCOUNT" }, 
   { 2, "P_CHS_ERR_USER" }, 
   { 3, "P_CHS_ERR_PARAMETER" }, 
   { 4, "P_CHS_ERR_NO_DEBIT" }, 
   { 5, "P_CHS_ERR_NO_CREDIT" }, 
   { 6, "P_CHS_ERR_VOLUMES" }, 
   { 7, "P_CHS_ERR_CURRENCY" }, 
   { 8, "P_CHS_ERR_NO_EXTEND" }, 
   { 9, "P_CHS_ERR_RESERVATION_LIMIT" }, 
   { 10, "P_CHS_ERR_CONFIRMATION_REQUIRED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cs/TpSessionEndedCause:1.0
 */
 
static const value_string org_csapi_cs_TpSessionEndedCause[] = {

   { 0, "P_CHS_CAUSE_UNDEFINED" }, 
   { 1, "P_CHS_CAUSE_TIMER_EXPIRED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cs/TpAppInformationType:1.0
 */
 
static const value_string org_csapi_cs_TpAppInformationType[] = {

   { 0, "P_APP_INF_TIMESTAMP" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/policy/TpPolicyConditionListType:1.0
 */
 
static const value_string org_csapi_policy_TpPolicyConditionListType[] = {

   { 0, "P_PM_DNF" }, 
   { 1, "P_PM_CNF" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/policy/TpPolicyConditionType:1.0
 */
 
static const value_string org_csapi_policy_TpPolicyConditionType[] = {

   { 0, "P_PM_TIME_PERIOD_CONDITION" }, 
   { 1, "P_PM_EVENT_CONDITION" }, 
   { 2, "P_PM_EXPRESSION_CONDITION" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/policy/TpPolicyActionType:1.0
 */
 
static const value_string org_csapi_policy_TpPolicyActionType[] = {

   { 0, "P_PM_EVENT_ACTION" }, 
   { 1, "P_PM_EXPRESSION_ACTION" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/policy/TpPolicyTypeInfo:1.0
 */
 
static const value_string org_csapi_policy_TpPolicyTypeInfo[] = {

   { 0, "P_PM_SIMPLE_TYPE" }, 
   { 1, "P_PM_TYPE_RECORD" }, 
   { 2, "P_PM_TYPE_LIST" }, 
   { 3, "P_PM_STRUCTURED_TYPE" }, 
   { 4, "P_PM_XML_TYPE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/pam/TpPAMContextName:1.0
 */
 
static const value_string org_csapi_pam_TpPAMContextName[] = {

   { 0, "PAM_CONTEXT_ANY" }, 
   { 1, "PAM_CONTEXT_COMMUNICATION" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/pam/TpPAMACLDefault:1.0
 */
 
static const value_string org_csapi_pam_TpPAMACLDefault[] = {

   { 0, "PAM_ACCESS_ALLOW" }, 
   { 1, "PAM_ACCESS_DENY" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/pam/TpPAMPreferenceType:1.0
 */
 
static const value_string org_csapi_pam_TpPAMPreferenceType[] = {

   { 0, "PAM_ACCESS_LIST" }, 
   { 1, "PAM_EXTERNAL_CONTROL" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/pam/TpPAMEventName:1.0
 */
 
static const value_string org_csapi_pam_TpPAMEventName[] = {

   { 0, "PAM_CE_IDENTITY_PRESENCE_SET" }, 
   { 1, "PAM_CE_AVAILABILITY_CHANGED" }, 
   { 2, "PAM_CE_WATCHERS_CHANGED" }, 
   { 3, "PAM_CE_IDENTITY_CREATED" }, 
   { 4, "PAM_CE_IDENTITY_DELETED" }, 
   { 5, "PAM_CE_GROUP_MEMBERSHIP_CHANGED" }, 
   { 6, "PAM_CE_AGENT_CREATED" }, 
   { 7, "PAM_CE_AGENT_DELETED" }, 
   { 8, "PAM_CE_AGENT_ASSIGNED" }, 
   { 9, "PAM_CE_AGENT_UNASSIGNED" }, 
   { 10, "PAM_CE_CAPABILITY_CHANGED" }, 
   { 11, "PAM_CE_AGENT_CAPABILITY_PRESENCE_SET" }, 
   { 12, "PAM_CE_AGENT_PRESENCE_SET" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/pam/TpPAMwatcherChangeType:1.0
 */
 
static const value_string org_csapi_pam_TpPAMwatcherChangeType[] = {

   { 0, "PAM_WATCHERS_PERIODIC" }, 
   { 1, "PAM_WATCHERS_ADDED" }, 
   { 2, "PAM_WATCHERS_DELETED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/pam/TpPAMErrorCause:1.0
 */
 
static const value_string org_csapi_pam_TpPAMErrorCause[] = {

   { 0, "P_PAM_CAUSE_UNDEFINED" }, 
   { 1, "P_PAM_CAUSE_INVALID_ADDRESS" }, 
   { 2, "P_PAM_CAUSE_SYSTEM_FAILURE" }, 
   { 3, "P_PAM_CAUSE_INFO_UNAVAILABLE" }, 
   { 4, "P_PAM_CAUSE_EVENT_REGISTRATION_CANCELLED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpFolderInfoPropertyName:1.0
 */
 
static const value_string org_csapi_mmm_TpFolderInfoPropertyName[] = {

   { 0, "P_MMM_FOLDER_UNDEFINED" }, 
   { 1, "P_MMM_FOLDER_DATE_CREATED" }, 
   { 2, "P_MMM_FOLDER_DATE_CHANGED" }, 
   { 3, "P_MMM_FOLDER_SIZE" }, 
   { 4, "P_MMM_FOLDER_NUMBER_OF_MESSAGES" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMailboxInfoPropertyName:1.0
 */
 
static const value_string org_csapi_mmm_TpMailboxInfoPropertyName[] = {

   { 0, "P_MMM_MAILBOX_UNDEFINED" }, 
   { 1, "P_MMM_MAILBOX_OWNER" }, 
   { 2, "P_MMM_MAILBOX_DATE_CREATED" }, 
   { 3, "P_MMM_MAILBOX_DATE_CHANGED" }, 
   { 4, "P_MMM_MAILBOX_SIZE" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMessageInfoPropertyName:1.0
 */
 
static const value_string org_csapi_mmm_TpMessageInfoPropertyName[] = {

   { 0, "P_MMM_MESSAGE_UNDEFINED" }, 
   { 1, "P_MMM_MESSAGE_DATE_CREATED" }, 
   { 2, "P_MMM_MESSAGE_DATE_RECEIVED" }, 
   { 3, "P_MMM_MESSAGE_DATE_CHANGED" }, 
   { 4, "P_MMM_MESSAGE_SIZE" }, 
   { 5, "P_MMM_MESSAGE_STATUS" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMessagePriority:1.0
 */
 
static const value_string org_csapi_mmm_TpMessagePriority[] = {

   { 0, "P_MMM_MESSAGE_PRIORITY_UNDEFINED" }, 
   { 1, "P_MMM_MESSAGE_PRIORITY_HIGH" }, 
   { 2, "P_MMM_MESSAGE_PRIORITY_LOW" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMessageHeaderFieldType:1.0
 */
 
static const value_string org_csapi_mmm_TpMessageHeaderFieldType[] = {

   { 0, "P_MESSAGE_DATE_SENT" }, 
   { 1, "P_MESSAGE_SENT_FROM" }, 
   { 2, "P_MESSAGE_SENDER" }, 
   { 3, "P_MESSAGE_REPLY_TO" }, 
   { 4, "P_MESSAGE_SENT_TO" }, 
   { 5, "P_MESSAGE_CC_TO" }, 
   { 6, "P_MESSAGE_BCC_TO" }, 
   { 7, "P_MESSAGE_RFC822_MESSAGE_ID" }, 
   { 8, "P_MESSAGE_IN_REPLY_TO" }, 
   { 9, "P_MESSAGE_REFERENCES" }, 
   { 10, "P_MESSAGE_SUBJECT" }, 
   { 11, "P_MESSAGE_COMMENTS" }, 
   { 12, "P_MESSAGE_KEYWORDS" }, 
   { 13, "P_MESSAGE_TRACE_FIELD" }, 
   { 14, "P_MESSAGE_RESENT_FIELD" }, 
   { 15, "P_MESSAGE_MIME_VERSION" }, 
   { 16, "P_MESSAGE_MIME_CONTENT" }, 
   { 17, "P_MESSAGE_MIME_ENCODING" }, 
   { 18, "P_MESSAGE_MIME_ID" }, 
   { 19, "P_MESSAGE_MIME_DESCRIPTION" }, 
   { 20, "P_MESSAGE_MIME_DISPOSITION" }, 
   { 21, "P_MESSAGE_MIME_EXTENSION_FIELD" }, 
   { 22, "P_MESSAGE_EXTENSION_FIELD" }, 
   { 23, "P_MESSAGE_PRIORITY" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMailboxMessageStatus:1.0
 */
 
static const value_string org_csapi_mmm_TpMailboxMessageStatus[] = {

   { 0, "P_MMM_RECEIVED_MSG_STATUS_READ" }, 
   { 1, "P_MMM_RECEIVED_MSG_STATUS_UNREAD" }, 
   { 2, "P_MMM_RECEIVED_MSG_STATUS_FORWARDED" }, 
   { 3, "P_MMM_RECEIVED_MSG_STATUS_REPLIED_TO" }, 
   { 4, "P_MMM_DRAFT_MSG_STATUS_SAVED_OR_UNSENT" }, 
   { 5, "P_MMM_SENT_MSG_STATUS_SENT" }, 
   { 6, "P_MMM_SENT_MSG_STATUS_DELIVERED" }, 
   { 7, "P_MMM_SENT_MSG_STATUS_READ" }, 
   { 8, "P_MMM_SENT_MSG_STATUS_DELETED_UNREAD" }, 
   { 9, "P_MMM_SENT_MSG_STATUS_NOT_DELIVERABLE" }, 
   { 10, "P_MMM_SENT_MSG_STATUS_EXPIRED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpSetPropertyError:1.0
 */
 
static const value_string org_csapi_mmm_TpSetPropertyError[] = {

   { 0, "P_MMM_PROPERTY_NOT_SET" }, 
   { 1, "P_MMM_PROPERTY_READONLY" }, 
   { 2, "P_MMM_PROPERTY_INSUFFICIENT_PRIVILEGE" }, 
   { 3, "P_MMM_PROPERTY_NAME_UNKNOWN" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMessagingEventName:1.0
 */
 
static const value_string org_csapi_mmm_TpMessagingEventName[] = {

   { 0, "P_EVENT_MSG_NAME_UNDEFINED" }, 
   { 1, "P_EVENT_MSG_NEW_MAILBOX_MESSAGE_ARRIVED" }, 
   { 2, "P_EVENT_MSG_NEW_MESSAGE_ARRIVED" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpDeliveryTimeType:1.0
 */
 
static const value_string org_csapi_mmm_TpDeliveryTimeType[] = {

   { 0, "P_MMM_SEND_IMMEDIATE" }, 
   { 1, "P_MMM_DELIVERY_TIME" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMessageTreatmentType:1.0
 */
 
static const value_string org_csapi_mmm_TpMessageTreatmentType[] = {

   { 0, "P_MMM_TREATMENT_UNDEFINED" }, 
   { 1, "P_MMM_TREATMENT_REPORT_REQUESTED" }, 
   { 2, "P_MMM_TREATMENT_BILLING_ID" }, 
   { 3, "P_MMM_TREATMENT_DELIVERY_TIME" }, 
   { 4, "P_MMM_TREATMENT_VALIDITY_TIME" }, 
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMessagingError:1.0
 */
 
static const value_string org_csapi_mmm_TpMessagingError[] = {

   { 0, "P_MMM_ERROR_UNDEFINED" }, 
   { 1, "P_MMM_ERROR_INVALID_AUTHENTICATION_INFORMATION" }, 
   { 2, "P_MMM_ERROR_INVALID_MAILBOX" }, 
   { 3, "P_MMM_ERROR_INVALID_DELIVERY_TYPE" }, 
   { 4, "P_MMM_ERROR_MAX_MESSAGE_SIZE_EXCEEDED" }, 
   { 5, "P_MMM_ERROR_INVALID_FOLDER_ID" }, 
   { 6, "P_MMM_ERROR_INVALID_MESSAGE_ID" }, 
   { 7, "P_MMM_ERROR_INVALID_PART_ID" }, 
   { 8, "P_MMM_ERROR_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH" }, 
   { 9, "P_MMM_ERROR_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH" }, 
   { 10, "P_MMM_ERROR_INVALID_DELIVERY_TIME" }, 
   { 11, "P_MMM_ERROR_INVALID_VALIDITY_TIME" }, 
   { 12, "P_MMM_ERROR_MAX_SUBJECT_SIZE_EXCEEDED" }, 
   { 13, "P_MMM_ERROR_INVALID_ID" }, 
   { 14, "P_MMM_ERROR_INVALID_NESTING_LEVEL" }, 
   { 15, "P_MMM_ERROR_INVALID_CRITERIA" }, 
   { 16, "P_MMM_ERROR_INFORMATION_NOT_AVAILABLE" }, 
   { 17, "P_MMM_ERROR_CANNOT_CANCEL" }, 
   { 18, "P_MMM_ERROR_INVALID_HEADER" }, 
   { 19, "P_MMM_INVALID_NETWORK_STATE" }, 
   { 20, "P_MMM_ERROR_RESOURCE_UNAVAILABLE" }, 
   { 21, "P_MMM_ERROR_RESOURCE_TIMEOUT" }, 
   { 0,       NULL },
};

/*
 * IDL Enums End
 */
 
/*  Begin Exception Helper Functions  */


/* Exception = IDL:org/csapi/mmm/P_MMM_MAX_MESSAGE_SIZE_EXCEEDED:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_MAX_MESSAGE_SIZE_EXCEEDED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_MAX_MESSAGE_SIZE_EXCEEDED_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_FOLDER_ID:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_INVALID_FOLDER_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_INVALID_FOLDER_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_MESSAGE_ID:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_INVALID_MESSAGE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_INVALID_MESSAGE_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_PART_ID:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_INVALID_PART_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_INVALID_PART_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_PROPERTY:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_INVALID_PROPERTY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_INVALID_PROPERTY_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_DELIVERY_TIME:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_INVALID_DELIVERY_TIME(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_INVALID_DELIVERY_TIME_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_VALIDITY_TIME:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_INVALID_VALIDITY_TIME(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_INVALID_VALIDITY_TIME_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_MAX_SUBJECT_SIZE_EXCEEDED:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_MAX_SUBJECT_SIZE_EXCEEDED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_MAX_SUBJECT_SIZE_EXCEEDED_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INFORMATION_NOT_AVAILABLE:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_INFORMATION_NOT_AVAILABLE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_INFORMATION_NOT_AVAILABLE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_CANNOT_CANCEL:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_CANNOT_CANCEL(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_CANNOT_CANCEL_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_HEADER:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_INVALID_HEADER(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_INVALID_HEADER_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_AUTHENTICATION_INFORMATION:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_INVALID_AUTHENTICATION_INFORMATION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_INVALID_AUTHENTICATION_INFORMATION_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_MAILBOX:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_INVALID_MAILBOX(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_INVALID_MAILBOX_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_DELIVERY_TYPE:1.0 */

static void decode_ex_org_csapi_mmm_P_MMM_INVALID_DELIVERY_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MMM_INVALID_DELIVERY_TYPE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNAVAILABLE_INTERFACE:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_UNAVAILABLE_INTERFACE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_UNAVAILABLE_INTERFACE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_INVALID_CREDENTIAL:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_INVALID_CREDENTIAL(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_INVALID_CREDENTIAL_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_TYPE:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_UNKNOWN_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_UNKNOWN_TYPE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_MEMBER:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_UNKNOWN_MEMBER(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_UNKNOWN_MEMBER_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_IDENTITY:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_UNKNOWN_IDENTITY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_UNKNOWN_IDENTITY_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_GROUP:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_UNKNOWN_GROUP(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_UNKNOWN_GROUP_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_CAPABILITY:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_UNKNOWN_CAPABILITY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_UNKNOWN_CAPABILITY_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_ATTRIBUTES:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ATTRIBUTES(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_UNKNOWN_ATTRIBUTES_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_ATTRIBUTE:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ATTRIBUTE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_UNKNOWN_ATTRIBUTE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_ASSIGNMENT:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ASSIGNMENT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_UNKNOWN_ASSIGNMENT_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_ALIAS:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ALIAS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_UNKNOWN_ALIAS_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_AGENT:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_UNKNOWN_AGENT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_UNKNOWN_AGENT_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNASSIGNED_ALIAS:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_UNASSIGNED_ALIAS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_UNASSIGNED_ALIAS_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_TYPE_EXISTS:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_TYPE_EXISTS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_TYPE_EXISTS_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_TYPE_ASSOCIATED:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_TYPE_ASSOCIATED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_TYPE_ASSOCIATED_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_NOT_REGISTERED:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_NOT_REGISTERED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_NOT_REGISTERED_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_NOT_MEMBER:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_NOT_MEMBER(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_NOT_MEMBER_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_NO_CAPABILITY:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_NO_CAPABILITY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_NO_CAPABILITY_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_MEMBER_EXISTS:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_MEMBER_EXISTS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_MEMBER_EXISTS_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_IS_CYCLIC:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_IS_CYCLIC(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_IS_CYCLIC_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_IDENTITY_EXISTS:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_IDENTITY_EXISTS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_IDENTITY_EXISTS_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_DISASSOCIATED_TYPE:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_DISASSOCIATED_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_DISASSOCIATED_TYPE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_ATTRIBUTE_EXISTS:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_ATTRIBUTE_EXISTS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_ATTRIBUTE_EXISTS_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_ALIAS_NOT_UNIQUE:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_ALIAS_NOT_UNIQUE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_ALIAS_NOT_UNIQUE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_ALIAS_EXISTS:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_ALIAS_EXISTS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_ALIAS_EXISTS_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/pam/P_PAM_AGENT_EXISTS:1.0 */

static void decode_ex_org_csapi_pam_P_PAM_AGENT_EXISTS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PAM_AGENT_EXISTS_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cs/P_INVALID_USER:1.0 */

static void decode_ex_org_csapi_cs_P_INVALID_USER(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_USER_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cs/P_INVALID_ACCOUNT:1.0 */

static void decode_ex_org_csapi_cs_P_INVALID_ACCOUNT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_ACCOUNT_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cs/P_INVALID_REQUEST_NUMBER:1.0 */

static void decode_ex_org_csapi_cs_P_INVALID_REQUEST_NUMBER(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_REQUEST_NUMBER_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cs/P_INVALID_VOLUME:1.0 */

static void decode_ex_org_csapi_cs_P_INVALID_VOLUME(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_VOLUME_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/policy/P_ACCESS_VIOLATION:1.0 */

static void decode_ex_org_csapi_policy_P_ACCESS_VIOLATION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_ACCESS_VIOLATION_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/policy/P_SYNTAX_ERROR:1.0 */

static void decode_ex_org_csapi_policy_P_SYNTAX_ERROR(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_SYNTAX_ERROR_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/policy/P_NAME_SPACE_ERROR:1.0 */

static void decode_ex_org_csapi_policy_P_NAME_SPACE_ERROR(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_NAME_SPACE_ERROR_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/policy/P_NO_TRANSACTION_IN_PROCESS:1.0 */

static void decode_ex_org_csapi_policy_P_NO_TRANSACTION_IN_PROCESS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_NO_TRANSACTION_IN_PROCESS_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/policy/P_TRANSACTION_IN_PROCESS:1.0 */

static void decode_ex_org_csapi_policy_P_TRANSACTION_IN_PROCESS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_TRANSACTION_IN_PROCESS_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_VPRP_ID:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_VPRP_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_VPRP_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_SLA_ID:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_SLA_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_SLA_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_STATUS:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_STATUS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_STATUS_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_QOS_INFO:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_QOS_INFO(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_QOS_INFO_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_VALIDITY_INFO:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_VALIDITY_INFO(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_VALIDITY_INFO_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_PIPEQOSINFO:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_PIPEQOSINFO(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_PIPEQOSINFO_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_DSCODEPOINT:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_DSCODEPOINT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_DSCODEPOINT_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_ILLEGAL_VPRPID:1.0 */

static void decode_ex_org_csapi_cm_P_ILLEGAL_VPRPID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_ILLEGAL_VPRPID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_ILLEGAL_REF_VALUE:1.0 */

static void decode_ex_org_csapi_cm_P_ILLEGAL_REF_VALUE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_ILLEGAL_REF_VALUE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_INTERFACE:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_INTERFACE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_INTERFACE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_CANT_DELETE_VPRP:1.0 */

static void decode_ex_org_csapi_cm_P_CANT_DELETE_VPRP(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_CANT_DELETE_VPRP_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_TEMPLATES:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_TEMPLATES(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_TEMPLATES_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_MENU:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_MENU(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_MENU_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_ENTERPRISE_NETWORK:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_ENTERPRISE_NETWORK(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_ENTERPRISE_NETWORK_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_TEMPLATE_TYPE:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_TEMPLATE_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_TEMPLATE_TYPE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_DESCRIPTION:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_DESCRIPTION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_DESCRIPTION_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_ILLEGAL_SLA_ID:1.0 */

static void decode_ex_org_csapi_cm_P_ILLEGAL_SLA_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_ILLEGAL_SLA_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_ILLEGAL_TAG:1.0 */

static void decode_ex_org_csapi_cm_P_ILLEGAL_TAG(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_ILLEGAL_TAG_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_ILLEGAL_VALUE:1.0 */

static void decode_ex_org_csapi_cm_P_ILLEGAL_VALUE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_ILLEGAL_VALUE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_ILLEGAL_COMBINATION:1.0 */

static void decode_ex_org_csapi_cm_P_ILLEGAL_COMBINATION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_ILLEGAL_COMBINATION_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_SITES:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_SITES(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_SITES_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_VPRN:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_VPRN(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_VPRN_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_ILLEGAL_SITE_ID:1.0 */

static void decode_ex_org_csapi_cm_P_ILLEGAL_SITE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_ILLEGAL_SITE_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_SITE_ID:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_SITE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_SITE_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_SAPS:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_SAPS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_SAPS_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_SITE_LOCATION:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_SITE_LOCATION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_SITE_LOCATION_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_SITE_DESCRIPTION:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_SITE_DESCRIPTION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_SITE_DESCRIPTION_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_IPSUBNET:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_IPSUBNET(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_IPSUBNET_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_SAP:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_SAP(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_SAP_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_VPRP:1.0 */

static void decode_ex_org_csapi_cm_P_UNKNOWN_VPRP(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_VPRP_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/am/P_UNAUTHORIZED_APPLICATION:1.0 */

static void decode_ex_org_csapi_am_P_UNAUTHORIZED_APPLICATION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNAUTHORIZED_APPLICATION_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/gms/P_GMS_INVALID_FOLDER_ID:1.0 */

static void decode_ex_org_csapi_gms_P_GMS_INVALID_FOLDER_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_GMS_INVALID_FOLDER_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/gms/P_GMS_INSUFFICIENT_PRIVILEGE:1.0 */

static void decode_ex_org_csapi_gms_P_GMS_INSUFFICIENT_PRIVILEGE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_GMS_INSUFFICIENT_PRIVILEGE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/gms/P_GMS_INVALID_AUTHENTICATION_INFORMATION:1.0 */

static void decode_ex_org_csapi_gms_P_GMS_INVALID_AUTHENTICATION_INFORMATION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_GMS_INVALID_AUTHENTICATION_INFORMATION_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/gms/P_GMS_INVALID_MAILBOX:1.0 */

static void decode_ex_org_csapi_gms_P_GMS_INVALID_MAILBOX(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_GMS_INVALID_MAILBOX_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/gms/P_GMS_INVALID_MESSAGE_ID:1.0 */

static void decode_ex_org_csapi_gms_P_GMS_INVALID_MESSAGE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_GMS_INVALID_MESSAGE_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/gms/P_GMS_LOCKING_LOCKED_MAILBOX:1.0 */

static void decode_ex_org_csapi_gms_P_GMS_LOCKING_LOCKED_MAILBOX(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_GMS_LOCKING_LOCKED_MAILBOX_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/gms/P_GMS_MESSAGE_NOT_REMOVED:1.0 */

static void decode_ex_org_csapi_gms_P_GMS_MESSAGE_NOT_REMOVED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_GMS_MESSAGE_NOT_REMOVED_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/gms/P_GMS_NUMBER_NOT_POSITIVE:1.0 */

static void decode_ex_org_csapi_gms_P_GMS_NUMBER_NOT_POSITIVE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_GMS_NUMBER_NOT_POSITIVE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/gms/P_GMS_UNLOCKING_UNLOCKED_MAILBOX:1.0 */

static void decode_ex_org_csapi_gms_P_GMS_UNLOCKING_UNLOCKED_MAILBOX(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_GMS_UNLOCKING_UNLOCKED_MAILBOX_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/gms/P_GMS_MAILBOX_LOCKED:1.0 */

static void decode_ex_org_csapi_gms_P_GMS_MAILBOX_LOCKED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_GMS_MAILBOX_LOCKED_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/gms/P_GMS_CANNOT_UNLOCK_MAILBOX:1.0 */

static void decode_ex_org_csapi_gms_P_GMS_CANNOT_UNLOCK_MAILBOX(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_GMS_CANNOT_UNLOCK_MAILBOX_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/gms/P_GMS_PROPERTY_NOT_SET:1.0 */

static void decode_ex_org_csapi_gms_P_GMS_PROPERTY_NOT_SET(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_GMS_PROPERTY_NOT_SET_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/gms/P_GMS_FOLDER_IS_OPEN:1.0 */

static void decode_ex_org_csapi_gms_P_GMS_FOLDER_IS_OPEN(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_GMS_FOLDER_IS_OPEN_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/gms/P_GMS_MAILBOX_OPEN:1.0 */

static void decode_ex_org_csapi_gms_P_GMS_MAILBOX_OPEN(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_GMS_MAILBOX_OPEN_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/termcap/P_INVALID_TERMINAL_ID:1.0 */

static void decode_ex_org_csapi_termcap_P_INVALID_TERMINAL_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_TERMINAL_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mm/P_REQUESTED_ACCURACY_CANNOT_BE_DELIVERED:1.0 */

static void decode_ex_org_csapi_mm_P_REQUESTED_ACCURACY_CANNOT_BE_DELIVERED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_REQUESTED_ACCURACY_CANNOT_BE_DELIVERED_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mm/P_REQUESTED_RESPONSE_TIME_CANNOT_BE_DELIVERED:1.0 */

static void decode_ex_org_csapi_mm_P_REQUESTED_RESPONSE_TIME_CANNOT_BE_DELIVERED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_REQUESTED_RESPONSE_TIME_CANNOT_BE_DELIVERED_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mm/P_INVALID_REPORTING_INTERVAL:1.0 */

static void decode_ex_org_csapi_mm_P_INVALID_REPORTING_INTERVAL(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_REPORTING_INTERVAL_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/mm/P_TRIGGER_CONDITIONS_NOT_SUBSCRIBED:1.0 */

static void decode_ex_org_csapi_mm_P_TRIGGER_CONDITIONS_NOT_SUBSCRIBED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_TRIGGER_CONDITIONS_NOT_SUBSCRIBED_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/ui/P_ID_NOT_FOUND:1.0 */

static void decode_ex_org_csapi_ui_P_ID_NOT_FOUND(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_ID_NOT_FOUND_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/ui/P_ILLEGAL_ID:1.0 */

static void decode_ex_org_csapi_ui_P_ILLEGAL_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_ILLEGAL_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/ui/P_ILLEGAL_RANGE:1.0 */

static void decode_ex_org_csapi_ui_P_ILLEGAL_RANGE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_ILLEGAL_RANGE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/ui/P_INVALID_COLLECTION_CRITERIA:1.0 */

static void decode_ex_org_csapi_ui_P_INVALID_COLLECTION_CRITERIA(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_COLLECTION_CRITERIA_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SERVICE_ID:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_SERVICE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_SERVICE_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_SERVICE_ACCESS_DENIED:1.0 */

static void decode_ex_org_csapi_fw_P_SERVICE_ACCESS_DENIED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_SERVICE_ACCESS_DENIED_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_ACCESS_DENIED:1.0 */

static void decode_ex_org_csapi_fw_P_ACCESS_DENIED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_ACCESS_DENIED_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_SERVICE_NOT_ENABLED:1.0 */

static void decode_ex_org_csapi_fw_P_SERVICE_NOT_ENABLED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_SERVICE_NOT_ENABLED_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_NO_ACCEPTABLE_ENCRYPTION_CAPABILITY:1.0 */

static void decode_ex_org_csapi_fw_P_NO_ACCEPTABLE_ENCRYPTION_CAPABILITY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_NO_ACCEPTABLE_ENCRYPTION_CAPABILITY_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_AGREEMENT_TEXT:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_AGREEMENT_TEXT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_AGREEMENT_TEXT_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SERVICE_TOKEN:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_SERVICE_TOKEN(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_SERVICE_TOKEN_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SIGNATURE:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_SIGNATURE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_SIGNATURE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SIGNING_ALGORITHM:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_SIGNING_ALGORITHM(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_SIGNING_ALGORITHM_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_DOMAIN_ID:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_DOMAIN_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_DOMAIN_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_PROPERTY:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_PROPERTY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_PROPERTY_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_ACCESS_TYPE:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_ACCESS_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_ACCESS_TYPE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_ILLEGAL_SERVICE_TYPE:1.0 */

static void decode_ex_org_csapi_fw_P_ILLEGAL_SERVICE_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_ILLEGAL_SERVICE_TYPE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_UNKNOWN_SERVICE_TYPE:1.0 */

static void decode_ex_org_csapi_fw_P_UNKNOWN_SERVICE_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_SERVICE_TYPE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_MISSING_MANDATORY_PROPERTY:1.0 */

static void decode_ex_org_csapi_fw_P_MISSING_MANDATORY_PROPERTY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_MISSING_MANDATORY_PROPERTY_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_DUPLICATE_PROPERTY_NAME:1.0 */

static void decode_ex_org_csapi_fw_P_DUPLICATE_PROPERTY_NAME(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_DUPLICATE_PROPERTY_NAME_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_PROPERTY_TYPE_MISMATCH:1.0 */

static void decode_ex_org_csapi_fw_P_PROPERTY_TYPE_MISMATCH(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_PROPERTY_TYPE_MISMATCH_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_CLIENT_APP_ID:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_CLIENT_APP_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_CLIENT_APP_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_AUTH_TYPE:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_AUTH_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_AUTH_TYPE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SAG_ID:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_SAG_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_SAG_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SERVICE_PROFILE_ID:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_SERVICE_PROFILE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_SERVICE_PROFILE_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SERVICE_CONTRACT_ID:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_SERVICE_CONTRACT_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_SERVICE_CONTRACT_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_ACTIVITY_TEST_ID:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_ACTIVITY_TEST_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_ACTIVITY_TEST_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_ILLEGAL_SERVICE_ID:1.0 */

static void decode_ex_org_csapi_fw_P_ILLEGAL_SERVICE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_ILLEGAL_SERVICE_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_UNKNOWN_SERVICE_ID:1.0 */

static void decode_ex_org_csapi_fw_P_UNKNOWN_SERVICE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_SERVICE_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_SERVICE_TYPE_UNAVAILABLE:1.0 */

static void decode_ex_org_csapi_fw_P_SERVICE_TYPE_UNAVAILABLE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_SERVICE_TYPE_UNAVAILABLE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_ADDITION_TO_SAG:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_ADDITION_TO_SAG(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_ADDITION_TO_SAG_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SAG_TO_SERVICE_PROFILE_ASSIGNMENT:1.0 */

static void decode_ex_org_csapi_fw_P_INVALID_SAG_TO_SERVICE_PROFILE_ASSIGNMENT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_SAG_TO_SERVICE_PROFILE_ASSIGNMENT_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_NO_ACCEPTABLE_AUTHENTICATION_MECHANISM:1.0 */

static void decode_ex_org_csapi_fw_P_NO_ACCEPTABLE_AUTHENTICATION_MECHANISM(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_NO_ACCEPTABLE_AUTHENTICATION_MECHANISM_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/fw/P_NO_ACCEPTABLE_SIGNING_ALGORITHM:1.0 */

static void decode_ex_org_csapi_fw_P_NO_ACCEPTABLE_SIGNING_ALGORITHM(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_NO_ACCEPTABLE_SIGNING_ALGORITHM_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_INVALID_ASSIGNMENT_ID:1.0 */

static void decode_ex_org_csapi_P_INVALID_ASSIGNMENT_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_ASSIGNMENT_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_INVALID_TIME_AND_DATE_FORMAT:1.0 */

static void decode_ex_org_csapi_P_INVALID_TIME_AND_DATE_FORMAT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_TIME_AND_DATE_FORMAT_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_INVALID_EVENT_TYPE:1.0 */

static void decode_ex_org_csapi_P_INVALID_EVENT_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_EVENT_TYPE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_INVALID_INTERFACE_NAME:1.0 */

static void decode_ex_org_csapi_P_INVALID_INTERFACE_NAME(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_INTERFACE_NAME_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_INVALID_INTERFACE_TYPE:1.0 */

static void decode_ex_org_csapi_P_INVALID_INTERFACE_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_INTERFACE_TYPE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_UNKNOWN_SUBSCRIBER:1.0 */

static void decode_ex_org_csapi_P_UNKNOWN_SUBSCRIBER(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNKNOWN_SUBSCRIBER_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_INFORMATION_NOT_AVAILABLE:1.0 */

static void decode_ex_org_csapi_P_INFORMATION_NOT_AVAILABLE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INFORMATION_NOT_AVAILABLE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_INVALID_CRITERIA:1.0 */

static void decode_ex_org_csapi_P_INVALID_CRITERIA(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_CRITERIA_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_INVALID_SESSION_ID:1.0 */

static void decode_ex_org_csapi_P_INVALID_SESSION_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_SESSION_ID_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/TpCommonExceptions:1.0 */

static void decode_ex_org_csapi_TpCommonExceptions(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCommonExceptions_ExceptionType = %i",s_octet4);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCommonExceptions_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_INVALID_CURRENCY:1.0 */

static void decode_ex_org_csapi_P_INVALID_CURRENCY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_CURRENCY_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_INVALID_AMOUNT:1.0 */

static void decode_ex_org_csapi_P_INVALID_AMOUNT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_AMOUNT_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_APPLICATION_NOT_ACTIVATED:1.0 */

static void decode_ex_org_csapi_P_APPLICATION_NOT_ACTIVATED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_APPLICATION_NOT_ACTIVATED_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_INVALID_ADDRESS:1.0 */

static void decode_ex_org_csapi_P_INVALID_ADDRESS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_ADDRESS_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_UNSUPPORTED_ADDRESS_PLAN:1.0 */

static void decode_ex_org_csapi_P_UNSUPPORTED_ADDRESS_PLAN(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNSUPPORTED_ADDRESS_PLAN_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_UNAUTHORISED_PARAMETER_VALUE:1.0 */

static void decode_ex_org_csapi_P_UNAUTHORISED_PARAMETER_VALUE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_UNAUTHORISED_PARAMETER_VALUE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_INVALID_VERSION:1.0 */

static void decode_ex_org_csapi_P_INVALID_VERSION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_VERSION_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Exception = IDL:org/csapi/P_INVALID_NETWORK_STATE:1.0 */

static void decode_ex_org_csapi_P_INVALID_NETWORK_STATE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"P_INVALID_NETWORK_STATE_ExtraInformation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}


/*  End Exception Helper Functions  */

/*
 * Main delegator for exception handling
 *
 */

static gboolean decode_user_exception(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *ptree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_ ) {

    gboolean be _U_;                        /* big endianess */
    proto_tree *tree _U_;

    if (!header->exception_id)
        return FALSE;

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_MAX_MESSAGE_SIZE_EXCEEDED) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_MAX_MESSAGE_SIZE_EXCEEDED(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_MAX_MESSAGE_SIZE_EXCEEDED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_INVALID_FOLDER_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_FOLDER_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_FOLDER_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_INVALID_MESSAGE_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_MESSAGE_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_MESSAGE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_INVALID_PART_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_PART_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_PART_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_INVALID_PROPERTY) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_PROPERTY(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_PROPERTY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_INVALID_DELIVERY_TIME) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_DELIVERY_TIME(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_DELIVERY_TIME:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_INVALID_VALIDITY_TIME) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_VALIDITY_TIME(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_VALIDITY_TIME:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_MAX_SUBJECT_SIZE_EXCEEDED) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_MAX_SUBJECT_SIZE_EXCEEDED(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_MAX_SUBJECT_SIZE_EXCEEDED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_INFORMATION_NOT_AVAILABLE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INFORMATION_NOT_AVAILABLE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_INFORMATION_NOT_AVAILABLE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_CANNOT_CANCEL) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_CANNOT_CANCEL(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_CANNOT_CANCEL:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_INVALID_HEADER) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_HEADER(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_HEADER:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_INVALID_AUTHENTICATION_INFORMATION) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_AUTHENTICATION_INFORMATION(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_AUTHENTICATION_INFORMATION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_INVALID_MAILBOX) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_MAILBOX(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_MAILBOX:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mmm_P_MMM_INVALID_DELIVERY_TYPE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_DELIVERY_TYPE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_DELIVERY_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_UNAVAILABLE_INTERFACE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNAVAILABLE_INTERFACE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_UNAVAILABLE_INTERFACE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_INVALID_CREDENTIAL) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_INVALID_CREDENTIAL(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_INVALID_CREDENTIAL:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_UNKNOWN_TYPE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_TYPE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_UNKNOWN_MEMBER) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_MEMBER(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_MEMBER:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_UNKNOWN_IDENTITY) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_IDENTITY(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_IDENTITY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_UNKNOWN_GROUP) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_GROUP(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_GROUP:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_UNKNOWN_CAPABILITY) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_CAPABILITY(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_CAPABILITY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_UNKNOWN_ATTRIBUTES) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ATTRIBUTES(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_ATTRIBUTES:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_UNKNOWN_ATTRIBUTE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ATTRIBUTE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_ATTRIBUTE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_UNKNOWN_ASSIGNMENT) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ASSIGNMENT(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_ASSIGNMENT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_UNKNOWN_ALIAS) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ALIAS(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_ALIAS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_UNKNOWN_AGENT) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_AGENT(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_AGENT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_UNASSIGNED_ALIAS) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNASSIGNED_ALIAS(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_UNASSIGNED_ALIAS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_TYPE_EXISTS) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_TYPE_EXISTS(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_TYPE_EXISTS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_TYPE_ASSOCIATED) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_TYPE_ASSOCIATED(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_TYPE_ASSOCIATED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_NOT_REGISTERED) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_NOT_REGISTERED(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_NOT_REGISTERED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_NOT_MEMBER) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_NOT_MEMBER(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_NOT_MEMBER:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_NO_CAPABILITY) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_NO_CAPABILITY(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_NO_CAPABILITY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_MEMBER_EXISTS) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_MEMBER_EXISTS(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_MEMBER_EXISTS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_IS_CYCLIC) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_IS_CYCLIC(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_IS_CYCLIC:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_IDENTITY_EXISTS) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_IDENTITY_EXISTS(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_IDENTITY_EXISTS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_DISASSOCIATED_TYPE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_DISASSOCIATED_TYPE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_DISASSOCIATED_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_ATTRIBUTE_EXISTS) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_ATTRIBUTE_EXISTS(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_ATTRIBUTE_EXISTS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_ALIAS_NOT_UNIQUE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_ALIAS_NOT_UNIQUE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_ALIAS_NOT_UNIQUE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_ALIAS_EXISTS) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_ALIAS_EXISTS(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_ALIAS_EXISTS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_pam_P_PAM_AGENT_EXISTS) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_AGENT_EXISTS(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/pam/P_PAM_AGENT_EXISTS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cs_P_INVALID_USER) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cs_P_INVALID_USER(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cs/P_INVALID_USER:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cs_P_INVALID_ACCOUNT) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cs_P_INVALID_ACCOUNT(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cs/P_INVALID_ACCOUNT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cs_P_INVALID_REQUEST_NUMBER) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cs_P_INVALID_REQUEST_NUMBER(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cs/P_INVALID_REQUEST_NUMBER:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cs_P_INVALID_VOLUME) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cs_P_INVALID_VOLUME(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cs/P_INVALID_VOLUME:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_policy_P_ACCESS_VIOLATION) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_policy_P_ACCESS_VIOLATION(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/policy/P_ACCESS_VIOLATION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_policy_P_SYNTAX_ERROR) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_policy_P_SYNTAX_ERROR(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/policy/P_SYNTAX_ERROR:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_policy_P_NAME_SPACE_ERROR) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_policy_P_NAME_SPACE_ERROR(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/policy/P_NAME_SPACE_ERROR:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_policy_P_NO_TRANSACTION_IN_PROCESS) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_policy_P_NO_TRANSACTION_IN_PROCESS(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/policy/P_NO_TRANSACTION_IN_PROCESS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_policy_P_TRANSACTION_IN_PROCESS) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_policy_P_TRANSACTION_IN_PROCESS(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/policy/P_TRANSACTION_IN_PROCESS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_VPRP_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_VPRP_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_VPRP_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_SLA_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_SLA_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_SLA_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_STATUS) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_STATUS(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_STATUS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_QOS_INFO) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_QOS_INFO(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_QOS_INFO:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_VALIDITY_INFO) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_VALIDITY_INFO(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_VALIDITY_INFO:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_PIPEQOSINFO) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_PIPEQOSINFO(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_PIPEQOSINFO:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_DSCODEPOINT) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_DSCODEPOINT(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_DSCODEPOINT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_ILLEGAL_VPRPID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_ILLEGAL_VPRPID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_ILLEGAL_VPRPID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_ILLEGAL_REF_VALUE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_ILLEGAL_REF_VALUE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_ILLEGAL_REF_VALUE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_INTERFACE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_INTERFACE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_INTERFACE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_CANT_DELETE_VPRP) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_CANT_DELETE_VPRP(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_CANT_DELETE_VPRP:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_TEMPLATES) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_TEMPLATES(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_TEMPLATES:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_MENU) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_MENU(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_MENU:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_ENTERPRISE_NETWORK) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_ENTERPRISE_NETWORK(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_ENTERPRISE_NETWORK:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_TEMPLATE_TYPE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_TEMPLATE_TYPE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_TEMPLATE_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_DESCRIPTION) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_DESCRIPTION(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_DESCRIPTION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_ILLEGAL_SLA_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_ILLEGAL_SLA_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_ILLEGAL_SLA_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_ILLEGAL_TAG) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_ILLEGAL_TAG(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_ILLEGAL_TAG:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_ILLEGAL_VALUE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_ILLEGAL_VALUE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_ILLEGAL_VALUE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_ILLEGAL_COMBINATION) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_ILLEGAL_COMBINATION(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_ILLEGAL_COMBINATION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_SITES) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_SITES(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_SITES:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_VPRN) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_VPRN(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_VPRN:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_ILLEGAL_SITE_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_ILLEGAL_SITE_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_ILLEGAL_SITE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_SITE_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_SITE_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_SITE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_SAPS) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_SAPS(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_SAPS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_SITE_LOCATION) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_SITE_LOCATION(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_SITE_LOCATION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_SITE_DESCRIPTION) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_SITE_DESCRIPTION(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_SITE_DESCRIPTION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_IPSUBNET) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_IPSUBNET(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_IPSUBNET:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_SAP) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_SAP(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_SAP:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_cm_P_UNKNOWN_VPRP) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_VPRP(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/cm/P_UNKNOWN_VPRP:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_am_P_UNAUTHORIZED_APPLICATION) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_am_P_UNAUTHORIZED_APPLICATION(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/am/P_UNAUTHORIZED_APPLICATION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_gms_P_GMS_INVALID_FOLDER_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_INVALID_FOLDER_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/gms/P_GMS_INVALID_FOLDER_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_gms_P_GMS_INSUFFICIENT_PRIVILEGE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_INSUFFICIENT_PRIVILEGE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/gms/P_GMS_INSUFFICIENT_PRIVILEGE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_gms_P_GMS_INVALID_AUTHENTICATION_INFORMATION) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_INVALID_AUTHENTICATION_INFORMATION(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/gms/P_GMS_INVALID_AUTHENTICATION_INFORMATION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_gms_P_GMS_INVALID_MAILBOX) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_INVALID_MAILBOX(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/gms/P_GMS_INVALID_MAILBOX:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_gms_P_GMS_INVALID_MESSAGE_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_INVALID_MESSAGE_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/gms/P_GMS_INVALID_MESSAGE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_gms_P_GMS_LOCKING_LOCKED_MAILBOX) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_LOCKING_LOCKED_MAILBOX(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/gms/P_GMS_LOCKING_LOCKED_MAILBOX:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_gms_P_GMS_MESSAGE_NOT_REMOVED) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_MESSAGE_NOT_REMOVED(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/gms/P_GMS_MESSAGE_NOT_REMOVED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_gms_P_GMS_NUMBER_NOT_POSITIVE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_NUMBER_NOT_POSITIVE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/gms/P_GMS_NUMBER_NOT_POSITIVE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_gms_P_GMS_UNLOCKING_UNLOCKED_MAILBOX) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_UNLOCKING_UNLOCKED_MAILBOX(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/gms/P_GMS_UNLOCKING_UNLOCKED_MAILBOX:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_gms_P_GMS_MAILBOX_LOCKED) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_MAILBOX_LOCKED(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/gms/P_GMS_MAILBOX_LOCKED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_gms_P_GMS_CANNOT_UNLOCK_MAILBOX) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_CANNOT_UNLOCK_MAILBOX(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/gms/P_GMS_CANNOT_UNLOCK_MAILBOX:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_gms_P_GMS_PROPERTY_NOT_SET) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_PROPERTY_NOT_SET(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/gms/P_GMS_PROPERTY_NOT_SET:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_gms_P_GMS_FOLDER_IS_OPEN) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_FOLDER_IS_OPEN(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/gms/P_GMS_FOLDER_IS_OPEN:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_gms_P_GMS_MAILBOX_OPEN) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_MAILBOX_OPEN(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/gms/P_GMS_MAILBOX_OPEN:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_termcap_P_INVALID_TERMINAL_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_termcap_P_INVALID_TERMINAL_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/termcap/P_INVALID_TERMINAL_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mm_P_REQUESTED_ACCURACY_CANNOT_BE_DELIVERED) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mm_P_REQUESTED_ACCURACY_CANNOT_BE_DELIVERED(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mm/P_REQUESTED_ACCURACY_CANNOT_BE_DELIVERED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mm_P_REQUESTED_RESPONSE_TIME_CANNOT_BE_DELIVERED) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mm_P_REQUESTED_RESPONSE_TIME_CANNOT_BE_DELIVERED(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mm/P_REQUESTED_RESPONSE_TIME_CANNOT_BE_DELIVERED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mm_P_INVALID_REPORTING_INTERVAL) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mm_P_INVALID_REPORTING_INTERVAL(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mm/P_INVALID_REPORTING_INTERVAL:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_mm_P_TRIGGER_CONDITIONS_NOT_SUBSCRIBED) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mm_P_TRIGGER_CONDITIONS_NOT_SUBSCRIBED(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/mm/P_TRIGGER_CONDITIONS_NOT_SUBSCRIBED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_ui_P_ID_NOT_FOUND) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_ui_P_ID_NOT_FOUND(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/ui/P_ID_NOT_FOUND:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_ui_P_ILLEGAL_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_ui_P_ILLEGAL_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/ui/P_ILLEGAL_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_ui_P_ILLEGAL_RANGE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_ui_P_ILLEGAL_RANGE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/ui/P_ILLEGAL_RANGE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_ui_P_INVALID_COLLECTION_CRITERIA) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_ui_P_INVALID_COLLECTION_CRITERIA(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/ui/P_INVALID_COLLECTION_CRITERIA:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_SERVICE_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SERVICE_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_SERVICE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_SERVICE_ACCESS_DENIED) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_SERVICE_ACCESS_DENIED(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_SERVICE_ACCESS_DENIED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_ACCESS_DENIED) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_ACCESS_DENIED(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_ACCESS_DENIED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_SERVICE_NOT_ENABLED) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_SERVICE_NOT_ENABLED(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_SERVICE_NOT_ENABLED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_NO_ACCEPTABLE_ENCRYPTION_CAPABILITY) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_NO_ACCEPTABLE_ENCRYPTION_CAPABILITY(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_NO_ACCEPTABLE_ENCRYPTION_CAPABILITY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_AGREEMENT_TEXT) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_AGREEMENT_TEXT(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_AGREEMENT_TEXT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_SERVICE_TOKEN) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SERVICE_TOKEN(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_SERVICE_TOKEN:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_SIGNATURE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SIGNATURE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_SIGNATURE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_SIGNING_ALGORITHM) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SIGNING_ALGORITHM(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_SIGNING_ALGORITHM:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_DOMAIN_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_DOMAIN_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_DOMAIN_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_PROPERTY) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_PROPERTY(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_PROPERTY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_ACCESS_TYPE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_ACCESS_TYPE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_ACCESS_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_ILLEGAL_SERVICE_TYPE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_ILLEGAL_SERVICE_TYPE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_ILLEGAL_SERVICE_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_UNKNOWN_SERVICE_TYPE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_UNKNOWN_SERVICE_TYPE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_UNKNOWN_SERVICE_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_MISSING_MANDATORY_PROPERTY) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_MISSING_MANDATORY_PROPERTY(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_MISSING_MANDATORY_PROPERTY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_DUPLICATE_PROPERTY_NAME) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_DUPLICATE_PROPERTY_NAME(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_DUPLICATE_PROPERTY_NAME:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_PROPERTY_TYPE_MISMATCH) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_PROPERTY_TYPE_MISMATCH(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_PROPERTY_TYPE_MISMATCH:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_CLIENT_APP_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_CLIENT_APP_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_CLIENT_APP_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_AUTH_TYPE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_AUTH_TYPE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_AUTH_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_SAG_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SAG_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_SAG_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_SERVICE_PROFILE_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SERVICE_PROFILE_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_SERVICE_PROFILE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_SERVICE_CONTRACT_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SERVICE_CONTRACT_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_SERVICE_CONTRACT_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_ACTIVITY_TEST_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_ACTIVITY_TEST_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_ACTIVITY_TEST_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_ILLEGAL_SERVICE_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_ILLEGAL_SERVICE_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_ILLEGAL_SERVICE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_UNKNOWN_SERVICE_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_UNKNOWN_SERVICE_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_UNKNOWN_SERVICE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_SERVICE_TYPE_UNAVAILABLE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_SERVICE_TYPE_UNAVAILABLE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_SERVICE_TYPE_UNAVAILABLE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_ADDITION_TO_SAG) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_ADDITION_TO_SAG(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_ADDITION_TO_SAG:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_INVALID_SAG_TO_SERVICE_PROFILE_ASSIGNMENT) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SAG_TO_SERVICE_PROFILE_ASSIGNMENT(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_INVALID_SAG_TO_SERVICE_PROFILE_ASSIGNMENT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_NO_ACCEPTABLE_AUTHENTICATION_MECHANISM) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_NO_ACCEPTABLE_AUTHENTICATION_MECHANISM(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_NO_ACCEPTABLE_AUTHENTICATION_MECHANISM:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_fw_P_NO_ACCEPTABLE_SIGNING_ALGORITHM) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_NO_ACCEPTABLE_SIGNING_ALGORITHM(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/fw/P_NO_ACCEPTABLE_SIGNING_ALGORITHM:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_INVALID_ASSIGNMENT_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_ASSIGNMENT_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_INVALID_ASSIGNMENT_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_INVALID_TIME_AND_DATE_FORMAT) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_TIME_AND_DATE_FORMAT(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_INVALID_TIME_AND_DATE_FORMAT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_INVALID_EVENT_TYPE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_EVENT_TYPE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_INVALID_EVENT_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_INVALID_INTERFACE_NAME) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_INTERFACE_NAME(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_INVALID_INTERFACE_NAME:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_INVALID_INTERFACE_TYPE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_INTERFACE_TYPE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_INVALID_INTERFACE_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_UNKNOWN_SUBSCRIBER) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_UNKNOWN_SUBSCRIBER(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_UNKNOWN_SUBSCRIBER:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_INFORMATION_NOT_AVAILABLE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INFORMATION_NOT_AVAILABLE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_INFORMATION_NOT_AVAILABLE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_INVALID_CRITERIA) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_CRITERIA(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_INVALID_CRITERIA:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_INVALID_SESSION_ID) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_SESSION_ID(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_INVALID_SESSION_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_TpCommonExceptions) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_TpCommonExceptions(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/TpCommonExceptions:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_INVALID_CURRENCY) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_CURRENCY(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_INVALID_CURRENCY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_INVALID_AMOUNT) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_AMOUNT(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_INVALID_AMOUNT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_APPLICATION_NOT_ACTIVATED) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_APPLICATION_NOT_ACTIVATED(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_APPLICATION_NOT_ACTIVATED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_INVALID_ADDRESS) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_ADDRESS(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_INVALID_ADDRESS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_UNSUPPORTED_ADDRESS_PLAN) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_UNSUPPORTED_ADDRESS_PLAN(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_UNSUPPORTED_ADDRESS_PLAN:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_UNAUTHORISED_PARAMETER_VALUE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_UNAUTHORISED_PARAMETER_VALUE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_UNAUTHORISED_PARAMETER_VALUE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_INVALID_VERSION) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_VERSION(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_INVALID_VERSION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, user_exception_org_csapi_P_INVALID_NETWORK_STATE) == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_NETWORK_STATE(tvb, pinfo, tree, offset, header, operation);   /*  IDL:org/csapi/P_INVALID_NETWORK_STATE:1.0  */
       return TRUE;
    }



    return FALSE;    /* user exception not found */

}

/*  Begin Attribute Helper Functions  */


/*  End Attribute Helper Functions  */

/*
 * IDL:org/csapi/IpService/setCallback:1.0
 */

static void decode_org_csapi_IpService_setCallback(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/IpService/setCallbackWithSessionID:1.0
 */

static void decode_org_csapi_IpService_setCallbackWithSessionID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpInitial/initiateAuthentication:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpInitial_initiateAuthentication(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpAuthDomain"  */

        

        decode_org_csapi_fw_TpAuthDomain_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpAuthDomain"  */

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"authType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpAuthDomain"  */

            

            decode_org_csapi_fw_TpAuthDomain_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpAuthDomain"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpInitial/initiateAuthenticationWithVersion:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpInitial_initiateAuthenticationWithVersion(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpAuthDomain"  */

        

        decode_org_csapi_fw_TpAuthDomain_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpAuthDomain"  */

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"authType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"frameworkVersion (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpAuthDomain"  */

            

            decode_org_csapi_fw_TpAuthDomain_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpAuthDomain"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAuthentication/requestAccess:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAuthentication_requestAccess(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"accessType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpClientAccess/terminateAccess:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpClientAccess_terminateAccess(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_digitalSignature;
    guint32   i_digitalSignature;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"terminationText (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"signingAlgorithm (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_digitalSignature = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of digitalSignature = %u",u_octet4_loop_digitalSignature);
        }

        for (i_digitalSignature=0; i_digitalSignature < u_octet4_loop_digitalSignature; i_digitalSignature++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"digitalSignature = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/obtainInterface:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_obtainInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"interfaceName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/obtainInterfaceWithCallback:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_obtainInterfaceWithCallback(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"interfaceName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/endAccess:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_endAccess(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_endAccessProperties;
    guint32   i_endAccessProperties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_endAccessProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of endAccessProperties = %u",u_octet4_loop_endAccessProperties);
        }

        for (i_endAccessProperties=0; i_endAccessProperties < u_octet4_loop_endAccessProperties; i_endAccessProperties++) {

            /*  Begin struct "org_csapi_fw_TpProperty"  */

            

            decode_org_csapi_fw_TpProperty_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/listInterfaces:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_listInterfaces(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpInterfaceNameList;
    guint32   i_TpInterfaceNameList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpInterfaceNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpInterfaceNameList = %u",u_octet4_loop_TpInterfaceNameList);
            }

            for (i_TpInterfaceNameList=0; i_TpInterfaceNameList < u_octet4_loop_TpInterfaceNameList; i_TpInterfaceNameList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpInterfaceNameList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/releaseInterface:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_releaseInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"interfaceName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/selectSigningAlgorithm:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_selectSigningAlgorithm(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"signingAlgorithmCaps (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpSigningAlgorithm (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/terminateAccess:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_terminateAccess(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_digitalSignature;
    guint32   i_digitalSignature;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"terminationText (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_digitalSignature = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of digitalSignature = %u",u_octet4_loop_digitalSignature);
        }

        for (i_digitalSignature=0; i_digitalSignature < u_octet4_loop_digitalSignature; i_digitalSignature++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"digitalSignature = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/relinquishInterface:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_relinquishInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_digitalSignature;
    guint32   i_digitalSignature;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"interfaceName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"terminationText (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_digitalSignature = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of digitalSignature = %u",u_octet4_loop_digitalSignature);
        }

        for (i_digitalSignature=0; i_digitalSignature < u_octet4_loop_digitalSignature; i_digitalSignature++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"digitalSignature = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication/authenticate:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_authenticate(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_challenge;
    guint32   i_challenge;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpOctetSet;
    guint32   i_TpOctetSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_challenge = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of challenge = %u",u_octet4_loop_challenge);
        }

        for (i_challenge=0; i_challenge < u_octet4_loop_challenge; i_challenge++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"challenge = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpOctetSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpOctetSet = %u",u_octet4_loop_TpOctetSet);
            }

            for (i_TpOctetSet=0; i_TpOctetSet < u_octet4_loop_TpOctetSet; i_TpOctetSet++) {

                u_octet1 = get_CDR_octet(tvb,offset);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpOctetSet = %u",u_octet1);
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication/abortAuthentication:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_abortAuthentication(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication/authenticationSucceeded:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_authenticationSucceeded(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication/challenge:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_challenge(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_challenge;
    guint32   i_challenge;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpOctetSet;
    guint32   i_TpOctetSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_challenge = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of challenge = %u",u_octet4_loop_challenge);
        }

        for (i_challenge=0; i_challenge < u_octet4_loop_challenge; i_challenge++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"challenge = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpOctetSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpOctetSet = %u",u_octet4_loop_TpOctetSet);
            }

            for (i_TpOctetSet=0; i_TpOctetSet < u_octet4_loop_TpOctetSet; i_TpOctetSet++) {

                u_octet1 = get_CDR_octet(tvb,offset);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpOctetSet = %u",u_octet1);
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication/selectEncryptionMethod:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_selectEncryptionMethod(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"encryptionCaps (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpEncryptionCapability (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication/authenticate:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_authenticate(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_challenge;
    guint32   i_challenge;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpOctetSet;
    guint32   i_TpOctetSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_challenge = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of challenge = %u",u_octet4_loop_challenge);
        }

        for (i_challenge=0; i_challenge < u_octet4_loop_challenge; i_challenge++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"challenge = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpOctetSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpOctetSet = %u",u_octet4_loop_TpOctetSet);
            }

            for (i_TpOctetSet=0; i_TpOctetSet < u_octet4_loop_TpOctetSet; i_TpOctetSet++) {

                u_octet1 = get_CDR_octet(tvb,offset);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpOctetSet = %u",u_octet1);
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication/abortAuthentication:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_abortAuthentication(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication/authenticationSucceeded:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_authenticationSucceeded(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication/selectAuthenticationMechanism:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_selectAuthenticationMechanism(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"authMechanismList (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpAuthMechanism (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication/challenge:1.0
 */

static void decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_challenge(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_challenge;
    guint32   i_challenge;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpOctetSet;
    guint32   i_TpOctetSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_challenge = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of challenge = %u",u_octet4_loop_challenge);
        }

        for (i_challenge=0; i_challenge < u_octet4_loop_challenge; i_challenge++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"challenge = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpOctetSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpOctetSet = %u",u_octet4_loop_TpOctetSet);
            }

            for (i_TpOctetSet=0; i_TpOctetSet < u_octet4_loop_TpOctetSet; i_TpOctetSet++) {

                u_octet1 = get_CDR_octet(tvb,offset);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpOctetSet = %u",u_octet1);
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/notification/IpAppEventNotification/reportNotification:1.0
 */

static void decode_org_csapi_fw_fw_application_notification_IpAppEventNotification_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin union "org_csapi_fw_TpFwEventInfo"  */

        
        decode_org_csapi_fw_TpFwEventInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_fw_TpFwEventInfo"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/notification/IpAppEventNotification/notificationTerminated:1.0
 */

static void decode_org_csapi_fw_fw_application_notification_IpAppEventNotification_notificationTerminated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/notification/IpEventNotification/createNotification:1.0
 */

static void decode_org_csapi_fw_fw_application_notification_IpEventNotification_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin union "org_csapi_fw_TpFwEventCriteria"  */

        
        decode_org_csapi_fw_TpFwEventCriteria_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_fw_TpFwEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/notification/IpEventNotification/destroyNotification:1.0
 */

static void decode_org_csapi_fw_fw_application_notification_IpEventNotification_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/activityTestRes:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_activityTestRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"activityTestResult (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/appActivityTestReq:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_appActivityTestReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/fwFaultReportInd:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwFaultReportInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpInterfaceFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/fwFaultRecoveryInd:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwFaultRecoveryInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpInterfaceFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/svcUnavailableInd:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_svcUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSvcUnavailReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/genFaultStatsRecordRes:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/fwUnavailableInd:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFwUnavailReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/activityTestErr:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_activityTestErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/genFaultStatsRecordErr:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/appUnavailableInd:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_appUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/genFaultStatsRecordReq:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/svcAvailStatusInd:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_svcAvailStatusInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSvcAvailStatusReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/generateFaultStatisticsRecordRes:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/generateFaultStatisticsRecordErr:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_faultStatistics;
    guint32   i_faultStatistics;
    guint32   u_octet4;
    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",s_octet4);
        }

        u_octet4_loop_faultStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of faultStatistics = %u",u_octet4_loop_faultStatistics);
        }

        for (i_faultStatistics=0; i_faultStatistics < u_octet4_loop_faultStatistics; i_faultStatistics++) {

            
            u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
            }

        }

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/generateFaultStatisticsRecordReq:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/fwAvailStatusInd:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwAvailStatusInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFwAvailStatusReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/queryAppLoadReq:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryAppLoadReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/queryLoadRes:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/queryLoadErr:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/loadLevelNotification:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_loadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/resumeNotification:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_resumeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/suspendNotification:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_suspendNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/createLoadLevelNotification:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_createLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/destroyLoadLevelNotification:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_destroyLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/queryAppLoadStatsReq:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryAppLoadStatsReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/queryLoadStatsRes:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadStatsRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",s_octet4);
        }

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/queryLoadStatsErr:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadStatsErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/reportLoad:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpLoadManager_reportLoad(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadLevel,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/queryLoadReq:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryLoadReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/queryAppLoadRes:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/queryAppLoadErr:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/createLoadLevelNotification:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpLoadManager_createLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/destroyLoadLevelNotification:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpLoadManager_destroyLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/resumeNotification:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpLoadManager_resumeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/suspendNotification:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpLoadManager_suspendNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/queryLoadStatsReq:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryLoadStatsReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",s_octet4);
        }

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/queryAppLoadStatsRes:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadStatsRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",s_octet4);
        }

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/queryAppLoadStatsErr:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadStatsErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppOAM/systemDateTimeQuery:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppOAM_systemDateTimeQuery(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"systemDateAndTime (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpDateAndTime (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpOAM/systemDateTimeQuery:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpOAM_systemDateTimeQuery(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"clientDateAndTime (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpDateAndTime (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/activityTestReq:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpFaultManager_activityTestReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"svcID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/appActivityTestRes:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appActivityTestRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"activityTestResult (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/svcUnavailableInd:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpFaultManager_svcUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/genFaultStatsRecordReq:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/appActivityTestErr:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appActivityTestErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/appUnavailableInd:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/genFaultStatsRecordRes:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/genFaultStatsRecordErr:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/appAvailStatusInd:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appAvailStatusInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpAppAvailStatusReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/generateFaultStatisticsRecordReq:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/generateFaultStatisticsRecordRes:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/generateFaultStatisticsRecordErr:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpHeartBeatMgmt/enableHeartBeat:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_enableHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",s_octet4);
        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpHeartBeatMgmt/disableHeartBeat:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_disableHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpHeartBeatMgmt/changeInterval:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_changeInterval(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppHeartBeat/pulse:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeat_pulse(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpHeartBeat/pulse:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpHeartBeat_pulse(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppHeartBeatMgmt/enableAppHeartBeat:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_enableAppHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",s_octet4);
        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppHeartBeatMgmt/disableAppHeartBeat:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_disableAppHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppHeartBeatMgmt/changeInterval:1.0
 */

static void decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_changeInterval(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/discovery/IpServiceDiscovery/listServiceTypes:1.0
 */

static void decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_listServiceTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceTypeNameList;
    guint32   i_TpServiceTypeNameList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceTypeNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceTypeNameList = %u",u_octet4_loop_TpServiceTypeNameList);
            }

            for (i_TpServiceTypeNameList=0; i_TpServiceTypeNameList < u_octet4_loop_TpServiceTypeNameList; i_TpServiceTypeNameList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceTypeNameList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/discovery/IpServiceDiscovery/describeServiceType:1.0
 */

static void decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_describeServiceType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"name (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpServiceTypeDescription"  */

            

            decode_org_csapi_fw_TpServiceTypeDescription_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpServiceTypeDescription"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/discovery/IpServiceDiscovery/discoverService:1.0
 */

static void decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_discoverService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_desiredPropertyList;
    guint32   i_desiredPropertyList;
    gint32    s_octet4;
    guint32   u_octet4_loop_TpServiceList;
    guint32   i_TpServiceList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceTypeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_desiredPropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of desiredPropertyList = %u",u_octet4_loop_desiredPropertyList);
        }

        for (i_desiredPropertyList=0; i_desiredPropertyList < u_octet4_loop_desiredPropertyList; i_desiredPropertyList++) {

            /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

            

            decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpServiceProperty"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"max = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceList = %u",u_octet4_loop_TpServiceList);
            }

            for (i_TpServiceList=0; i_TpServiceList < u_octet4_loop_TpServiceList; i_TpServiceList++) {

                /*  Begin struct "org_csapi_fw_TpService"  */

                

                decode_org_csapi_fw_TpService_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_fw_TpService"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/discovery/IpServiceDiscovery/listSubscribedServices:1.0
 */

static void decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_listSubscribedServices(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceList;
    guint32   i_TpServiceList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceList = %u",u_octet4_loop_TpServiceList);
            }

            for (i_TpServiceList=0; i_TpServiceList < u_octet4_loop_TpServiceList; i_TpServiceList++) {

                /*  Begin struct "org_csapi_fw_TpService"  */

                

                decode_org_csapi_fw_TpService_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_fw_TpService"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/service_agreement/IpAppServiceAgreementManagement/signServiceAgreement:1.0
 */

static void decode_org_csapi_fw_fw_application_service_agreement_IpAppServiceAgreementManagement_signServiceAgreement(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpOctetSet;
    guint32   i_TpOctetSet;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceToken (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agreementText (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"signingAlgorithm (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpOctetSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpOctetSet = %u",u_octet4_loop_TpOctetSet);
            }

            for (i_TpOctetSet=0; i_TpOctetSet < u_octet4_loop_TpOctetSet; i_TpOctetSet++) {

                u_octet1 = get_CDR_octet(tvb,offset);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpOctetSet = %u",u_octet1);
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/service_agreement/IpAppServiceAgreementManagement/terminateServiceAgreement:1.0
 */

static void decode_org_csapi_fw_fw_application_service_agreement_IpAppServiceAgreementManagement_terminateServiceAgreement(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_digitalSignature;
    guint32   i_digitalSignature;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceToken (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"terminationText (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_digitalSignature = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of digitalSignature = %u",u_octet4_loop_digitalSignature);
        }

        for (i_digitalSignature=0; i_digitalSignature < u_octet4_loop_digitalSignature; i_digitalSignature++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"digitalSignature = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement/signServiceAgreement:1.0
 */

static void decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_signServiceAgreement(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceToken (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agreementText (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"signingAlgorithm (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpSignatureAndServiceMgr"  */

            

            decode_org_csapi_fw_TpSignatureAndServiceMgr_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpSignatureAndServiceMgr"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement/terminateServiceAgreement:1.0
 */

static void decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_terminateServiceAgreement(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_digitalSignature;
    guint32   i_digitalSignature;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceToken (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"terminationText (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_digitalSignature = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of digitalSignature = %u",u_octet4_loop_digitalSignature);
        }

        for (i_digitalSignature=0; i_digitalSignature < u_octet4_loop_digitalSignature; i_digitalSignature++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"digitalSignature = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement/selectService:1.0
 */

static void decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_selectService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceToken (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement/initiateSignServiceAgreement:1.0
 */

static void decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_initiateSignServiceAgreement(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceToken (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement/createServiceProfile:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_createServiceProfile(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpServiceProfileDescription"  */

        

        decode_org_csapi_fw_TpServiceProfileDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpServiceProfileDescription"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceProfileID (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement/modifyServiceProfile:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_modifyServiceProfile(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpServiceProfile"  */

        

        decode_org_csapi_fw_TpServiceProfile_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpServiceProfile"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement/deleteServiceProfile:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_deleteServiceProfile(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceProfileID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement/assign:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_assign(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"sagID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceProfileID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement/deassign:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_deassign(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"sagID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceProfileID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement/requestConflictInfo:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_requestConflictInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpAssignSagToServiceProfileConflictList;
    guint32   i_TpAssignSagToServiceProfileConflictList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpAssignSagToServiceProfileConflictList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpAssignSagToServiceProfileConflictList = %u",u_octet4_loop_TpAssignSagToServiceProfileConflictList);
            }

            for (i_TpAssignSagToServiceProfileConflictList=0; i_TpAssignSagToServiceProfileConflictList < u_octet4_loop_TpAssignSagToServiceProfileConflictList; i_TpAssignSagToServiceProfileConflictList++) {

                /*  Begin struct "org_csapi_fw_TpAssignSagToServiceProfileConflict"  */

                

                decode_org_csapi_fw_TpAssignSagToServiceProfileConflict_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_fw_TpAssignSagToServiceProfileConflict"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileInfoQuery/listServiceProfiles:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_listServiceProfiles(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceProfileIDList;
    guint32   i_TpServiceProfileIDList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceProfileIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceProfileIDList = %u",u_octet4_loop_TpServiceProfileIDList);
            }

            for (i_TpServiceProfileIDList=0; i_TpServiceProfileIDList < u_octet4_loop_TpServiceProfileIDList; i_TpServiceProfileIDList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceProfileIDList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileInfoQuery/describeServiceProfile:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_describeServiceProfile(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceProfileID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpServiceProfileDescription"  */

            

            decode_org_csapi_fw_TpServiceProfileDescription_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpServiceProfileDescription"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileInfoQuery/listAssignedMembers:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_listAssignedMembers(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpSagIDList;
    guint32   i_TpSagIDList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceProfileID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpSagIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpSagIDList = %u",u_octet4_loop_TpSagIDList);
            }

            for (i_TpSagIDList=0; i_TpSagIDList < u_octet4_loop_TpSagIDList; i_TpSagIDList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpSagIDList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractManagement/createServiceContract:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_createServiceContract(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpServiceContractDescription"  */

        

        decode_org_csapi_fw_TpServiceContractDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpServiceContractDescription"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceContractID (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractManagement/modifyServiceContract:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_modifyServiceContract(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpServiceContract"  */

        

        decode_org_csapi_fw_TpServiceContract_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpServiceContract"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractManagement/deleteServiceContract:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_deleteServiceContract(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceContractID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractInfoQuery/describeServiceContract:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_describeServiceContract(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceContractID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpServiceContractDescription"  */

            

            decode_org_csapi_fw_TpServiceContractDescription_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpServiceContractDescription"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractInfoQuery/listServiceContracts:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_listServiceContracts(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceContractIDList;
    guint32   i_TpServiceContractIDList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceContractIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceContractIDList = %u",u_octet4_loop_TpServiceContractIDList);
            }

            for (i_TpServiceContractIDList=0; i_TpServiceContractIDList < u_octet4_loop_TpServiceContractIDList; i_TpServiceContractIDList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceContractIDList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractInfoQuery/listServiceProfiles:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_listServiceProfiles(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpServiceProfileIDList;
    guint32   i_TpServiceProfileIDList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceContractID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceProfileIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceProfileIDList = %u",u_octet4_loop_TpServiceProfileIDList);
            }

            for (i_TpServiceProfileIDList=0; i_TpServiceProfileIDList < u_octet4_loop_TpServiceProfileIDList; i_TpServiceProfileIDList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceProfileIDList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountManagement/modifyEntOpAccount:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountManagement_modifyEntOpAccount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_enterpriseOperatorProperties;
    guint32   i_enterpriseOperatorProperties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_enterpriseOperatorProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of enterpriseOperatorProperties = %u",u_octet4_loop_enterpriseOperatorProperties);
        }

        for (i_enterpriseOperatorProperties=0; i_enterpriseOperatorProperties < u_octet4_loop_enterpriseOperatorProperties; i_enterpriseOperatorProperties++) {

            /*  Begin struct "org_csapi_fw_TpProperty"  */

            

            decode_org_csapi_fw_TpProperty_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountManagement/deleteEntOpAccount:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountManagement_deleteEntOpAccount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountInfoQuery/describeEntOpAccount:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountInfoQuery_describeEntOpAccount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpEntOp"  */

            

            decode_org_csapi_fw_TpEntOp_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpEntOp"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/createClientApp:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_createClientApp(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpClientAppDescription"  */

        

        decode_org_csapi_fw_TpClientAppDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpClientAppDescription"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/modifyClientApp:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_modifyClientApp(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpClientAppDescription"  */

        

        decode_org_csapi_fw_TpClientAppDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpClientAppDescription"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/deleteClientApp:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_deleteClientApp(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"clientAppID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/createSAG:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_createSAG(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_clientAppIDs;
    guint32   i_clientAppIDs;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpSag"  */

        

        decode_org_csapi_fw_TpSag_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpSag"  */

        u_octet4_loop_clientAppIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of clientAppIDs = %u",u_octet4_loop_clientAppIDs);
        }

        for (i_clientAppIDs=0; i_clientAppIDs < u_octet4_loop_clientAppIDs; i_clientAppIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"clientAppIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/modifySAG:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_modifySAG(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpSag"  */

        

        decode_org_csapi_fw_TpSag_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpSag"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/deleteSAG:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_deleteSAG(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"sagID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/addSAGMembers:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_addSAGMembers(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_clientAppIDs;
    guint32   i_clientAppIDs;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"sagID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_clientAppIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of clientAppIDs = %u",u_octet4_loop_clientAppIDs);
        }

        for (i_clientAppIDs=0; i_clientAppIDs < u_octet4_loop_clientAppIDs; i_clientAppIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"clientAppIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/removeSAGMembers:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_removeSAGMembers(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_clientAppIDList;
    guint32   i_clientAppIDList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"sagID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_clientAppIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of clientAppIDList = %u",u_octet4_loop_clientAppIDList);
        }

        for (i_clientAppIDList=0; i_clientAppIDList < u_octet4_loop_clientAppIDList; i_clientAppIDList++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"clientAppIDList (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/requestConflictInfo:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_requestConflictInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpAddSagMembersConflictList;
    guint32   i_TpAddSagMembersConflictList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpAddSagMembersConflictList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpAddSagMembersConflictList = %u",u_octet4_loop_TpAddSagMembersConflictList);
            }

            for (i_TpAddSagMembersConflictList=0; i_TpAddSagMembersConflictList < u_octet4_loop_TpAddSagMembersConflictList; i_TpAddSagMembersConflictList++) {

                /*  Begin struct "org_csapi_fw_TpAddSagMembersConflict"  */

                

                decode_org_csapi_fw_TpAddSagMembersConflict_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_fw_TpAddSagMembersConflict"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery/describeClientApp:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_describeClientApp(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"clientAppID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpClientAppDescription"  */

            

            decode_org_csapi_fw_TpClientAppDescription_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpClientAppDescription"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery/listClientApps:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listClientApps(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpClientAppIDList;
    guint32   i_TpClientAppIDList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpClientAppIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpClientAppIDList = %u",u_octet4_loop_TpClientAppIDList);
            }

            for (i_TpClientAppIDList=0; i_TpClientAppIDList < u_octet4_loop_TpClientAppIDList; i_TpClientAppIDList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpClientAppIDList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery/describeSAG:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_describeSAG(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"sagID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpSagDescription (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery/listSAGs:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listSAGs(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpSagIDList;
    guint32   i_TpSagIDList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpSagIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpSagIDList = %u",u_octet4_loop_TpSagIDList);
            }

            for (i_TpSagIDList=0; i_TpSagIDList < u_octet4_loop_TpSagIDList; i_TpSagIDList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpSagIDList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery/listSAGMembers:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listSAGMembers(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpClientAppIDList;
    guint32   i_TpClientAppIDList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"sagID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpClientAppIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpClientAppIDList = %u",u_octet4_loop_TpClientAppIDList);
            }

            for (i_TpClientAppIDList=0; i_TpClientAppIDList < u_octet4_loop_TpClientAppIDList; i_TpClientAppIDList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpClientAppIDList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery/listClientAppMembership:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listClientAppMembership(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpSagIDList;
    guint32   i_TpSagIDList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"clientAppID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpSagIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpSagIDList = %u",u_octet4_loop_TpSagIDList);
            }

            for (i_TpSagIDList=0; i_TpSagIDList < u_octet4_loop_TpSagIDList; i_TpSagIDList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpSagIDList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/notification/IpClientEventNotification/reportNotification:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_notification_IpClientEventNotification_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin union "org_csapi_fw_TpFwEventInfo"  */

        
        decode_org_csapi_fw_TpFwEventInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_fw_TpFwEventInfo"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/notification/IpClientEventNotification/notificationTerminated:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_notification_IpClientEventNotification_notificationTerminated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/notification/IpEventNotification/createNotification:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_notification_IpEventNotification_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin union "org_csapi_fw_TpFwEventCriteria"  */

        
        decode_org_csapi_fw_TpFwEventCriteria_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_fw_TpFwEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/notification/IpEventNotification/destroyNotification:1.0
 */

static void decode_org_csapi_fw_fw_enterprise_operator_notification_IpEventNotification_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery/listServiceTypes:1.0
 */

static void decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_listServiceTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceTypeNameList;
    guint32   i_TpServiceTypeNameList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceTypeNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceTypeNameList = %u",u_octet4_loop_TpServiceTypeNameList);
            }

            for (i_TpServiceTypeNameList=0; i_TpServiceTypeNameList < u_octet4_loop_TpServiceTypeNameList; i_TpServiceTypeNameList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceTypeNameList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery/describeServiceType:1.0
 */

static void decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_describeServiceType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"name (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpServiceTypeDescription"  */

            

            decode_org_csapi_fw_TpServiceTypeDescription_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpServiceTypeDescription"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery/discoverService:1.0
 */

static void decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_discoverService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_desiredPropertyList;
    guint32   i_desiredPropertyList;
    gint32    s_octet4;
    guint32   u_octet4_loop_TpServiceList;
    guint32   i_TpServiceList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceTypeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_desiredPropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of desiredPropertyList = %u",u_octet4_loop_desiredPropertyList);
        }

        for (i_desiredPropertyList=0; i_desiredPropertyList < u_octet4_loop_desiredPropertyList; i_desiredPropertyList++) {

            /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

            

            decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpServiceProperty"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"max = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceList = %u",u_octet4_loop_TpServiceList);
            }

            for (i_TpServiceList=0; i_TpServiceList < u_octet4_loop_TpServiceList; i_TpServiceList++) {

                /*  Begin struct "org_csapi_fw_TpService"  */

                

                decode_org_csapi_fw_TpService_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_fw_TpService"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery/listRegisteredServices:1.0
 */

static void decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_listRegisteredServices(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceList;
    guint32   i_TpServiceList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceList = %u",u_octet4_loop_TpServiceList);
            }

            for (i_TpServiceList=0; i_TpServiceList < u_octet4_loop_TpServiceList; i_TpServiceList++) {

                /*  Begin struct "org_csapi_fw_TpService"  */

                

                decode_org_csapi_fw_TpService_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_fw_TpService"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_lifecycle/IpServiceInstanceLifecycleManager/createServiceManager:1.0
 */

static void decode_org_csapi_fw_fw_service_service_lifecycle_IpServiceInstanceLifecycleManager_createServiceManager(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_serviceProperties;
    guint32   i_serviceProperties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"application (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_serviceProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceProperties = %u",u_octet4_loop_serviceProperties);
        }

        for (i_serviceProperties=0; i_serviceProperties < u_octet4_loop_serviceProperties; i_serviceProperties++) {

            /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

            

            decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpServiceProperty"  */

        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceInstanceID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_lifecycle/IpServiceInstanceLifecycleManager/destroyServiceManager:1.0
 */

static void decode_org_csapi_fw_fw_service_service_lifecycle_IpServiceInstanceLifecycleManager_destroyServiceManager(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceInstance (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration/registerService:1.0
 */

static void decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_registerService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_servicePropertyList;
    guint32   i_servicePropertyList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceTypeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_servicePropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of servicePropertyList = %u",u_octet4_loop_servicePropertyList);
        }

        for (i_servicePropertyList=0; i_servicePropertyList < u_octet4_loop_servicePropertyList; i_servicePropertyList++) {

            /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

            

            decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpServiceProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceID (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration/announceServiceAvailability:1.0
 */

static void decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_announceServiceAvailability(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration/unregisterService:1.0
 */

static void decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_unregisterService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration/describeService:1.0
 */

static void decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_describeService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpServiceDescription"  */

            

            decode_org_csapi_fw_TpServiceDescription_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpServiceDescription"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration/unannounceService:1.0
 */

static void decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_unannounceService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration/registerServiceSubType:1.0
 */

static void decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_registerServiceSubType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_servicePropertyList;
    guint32   i_servicePropertyList;
    guint32   u_octet4_loop_extendedServicePropertyList;
    guint32   i_extendedServicePropertyList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceTypeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_servicePropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of servicePropertyList = %u",u_octet4_loop_servicePropertyList);
        }

        for (i_servicePropertyList=0; i_servicePropertyList < u_octet4_loop_servicePropertyList; i_servicePropertyList++) {

            /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

            

            decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpServiceProperty"  */

        }

        u_octet4_loop_extendedServicePropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of extendedServicePropertyList = %u",u_octet4_loop_extendedServicePropertyList);
        }

        for (i_extendedServicePropertyList=0; i_extendedServicePropertyList < u_octet4_loop_extendedServicePropertyList; i_extendedServicePropertyList++) {

            /*  Begin struct "org_csapi_fw_TpServiceTypePropertyValue"  */

            

            decode_org_csapi_fw_TpServiceTypePropertyValue_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpServiceTypePropertyValue"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceID (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/querySvcLoadReq:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_querySvcLoadReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/queryLoadRes:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/queryLoadErr:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/loadLevelNotification:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_loadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/suspendNotification:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_suspendNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/resumeNotification:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_resumeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/createLoadLevelNotification:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_createLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/destroyLoadLevelNotification:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_destroyLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/querySvcLoadStatsReq:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_querySvcLoadStatsReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/queryLoadStatsRes:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadStatsRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",s_octet4);
        }

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/queryLoadStatsErr:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadStatsErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/reportLoad:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_reportLoad(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadLevel,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/queryLoadReq:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_queryLoadReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/querySvcLoadRes:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/querySvcLoadErr:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/createLoadLevelNotification:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_createLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/destroyLoadLevelNotification:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_destroyLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/suspendNotification:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_suspendNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/resumeNotification:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_resumeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/queryLoadStatsReq:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_queryLoadStatsReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/querySvcLoadStatsRes:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadStatsRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",s_octet4);
        }

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/querySvcLoadStatsErr:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadStatsErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/activityTestRes:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_activityTestRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"activityTestResult (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/svcActivityTestReq:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_svcActivityTestReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/fwFaultReportInd:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwFaultReportInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpInterfaceFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/fwFaultRecoveryInd:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwFaultRecoveryInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpInterfaceFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/fwUnavailableInd:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFwUnavailReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/svcUnavailableInd:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_svcUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/appUnavailableInd:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_appUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/genFaultStatsRecordRes:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/activityTestErr:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_activityTestErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/genFaultStatsRecordErr:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/genFaultStatsRecordReq:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/generateFaultStatsRecordReq:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/appAvailStatusInd:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_appAvailStatusInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpAppAvailStatusReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/generateFaultStatisticsRecordRes:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/generateFaultStatisticsRecordErr:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/generateFaultStatisticsRecordReq:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/fwAvailStatusInd:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwAvailStatusInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFwAvailStatusReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/activityTestReq:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_activityTestReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/svcActivityTestRes:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcActivityTestRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"activityTestResult (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/appUnavailableInd:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_appUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/genFaultStatsRecordReq:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/svcUnavailableInd:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSvcUnavailReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/svcActivityTestErr:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcActivityTestErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/genFaultStatsRecordRes:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/genFaultStatsRecordErr:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"serviceIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/generateFaultStatsRecordRes:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/generateFaultStatsRecordErr:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/svcAvailStatusInd:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcAvailStatusInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSvcAvailStatusReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/generateFaultStatisticsRecordReq:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/generateFaultStatisticsRecordRes:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/generateFaultStatisticsRecordErr:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcOAM/systemDateTimeQuery:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcOAM_systemDateTimeQuery(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"systemDateAndTime (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpDateAndTime (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwOAM/systemDateTimeQuery:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwOAM_systemDateTimeQuery(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"clientDateAndTime (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpDateAndTime (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwHeartBeatMgmt/enableHeartBeat:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_enableHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",s_octet4);
        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwHeartBeatMgmt/disableHeartBeat:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_disableHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwHeartBeatMgmt/changeInterval:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_changeInterval(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcHeartBeat/pulse:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeat_pulse(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwHeartBeat/pulse:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeat_pulse(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcHeartBeatMgmt/enableSvcHeartBeat:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_enableSvcHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",s_octet4);
        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcHeartBeatMgmt/disableSvcHeartBeat:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_disableSvcHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcHeartBeatMgmt/changeInterval:1.0
 */

static void decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_changeInterval(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/notification/IpFwEventNotification/createNotification:1.0
 */

static void decode_org_csapi_fw_fw_service_notification_IpFwEventNotification_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin union "org_csapi_fw_TpFwEventCriteria"  */

        
        decode_org_csapi_fw_TpFwEventCriteria_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_fw_TpFwEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/notification/IpFwEventNotification/destroyNotification:1.0
 */

static void decode_org_csapi_fw_fw_service_notification_IpFwEventNotification_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/notification/IpSvcEventNotification/reportNotification:1.0
 */

static void decode_org_csapi_fw_fw_service_notification_IpSvcEventNotification_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin union "org_csapi_fw_TpFwEventInfo"  */

        
        decode_org_csapi_fw_TpFwEventInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_fw_TpFwEventInfo"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/notification/IpSvcEventNotification/notificationTerminated:1.0
 */

static void decode_org_csapi_fw_fw_service_notification_IpSvcEventNotification_notificationTerminated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/routeRes:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCall_routeRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_gccs_TpCallReport"  */

        

        decode_org_csapi_cc_gccs_TpCallReport_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_gccs_TpCallReport"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/routeErr:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCall_routeErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallError"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/getCallInfoRes:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCall_getCallInfoRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_gccs_TpCallInfoReport"  */

        

        decode_org_csapi_cc_gccs_TpCallInfoReport_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_gccs_TpCallInfoReport"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/getCallInfoErr:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCall_getCallInfoErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/superviseCallRes:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCall_superviseCallRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"report = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usedTime = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/superviseCallErr:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCall_superviseCallErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/callFaultDetected:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCall_callFaultDetected(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/getMoreDialledDigitsRes:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCall_getMoreDialledDigitsRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"digits (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/getMoreDialledDigitsErr:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCall_getMoreDialledDigitsErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/callEnded:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCall_callEnded(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_gccs_TpCallEndedReport"  */

        

        decode_org_csapi_cc_gccs_TpCallEndedReport_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_gccs_TpCallEndedReport"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/routeReq:1.0
 */

static void decode_org_csapi_cc_gccs_IpCall_routeReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_responseRequested;
    guint32   i_responseRequested;
    guint32   u_octet4_loop_appInfo;
    guint32   i_appInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        u_octet4_loop_responseRequested = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of responseRequested = %u",u_octet4_loop_responseRequested);
        }

        for (i_responseRequested=0; i_responseRequested < u_octet4_loop_responseRequested; i_responseRequested++) {

            /*  Begin struct "org_csapi_cc_gccs_TpCallReportRequest"  */

            

            decode_org_csapi_cc_gccs_TpCallReportRequest_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_gccs_TpCallReportRequest"  */

        }

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        u_octet4_loop_appInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of appInfo = %u",u_octet4_loop_appInfo);
        }

        for (i_appInfo=0; i_appInfo < u_octet4_loop_appInfo; i_appInfo++) {

            /*  Begin union "org_csapi_cc_gccs_TpCallAppInfo"  */

            
            decode_org_csapi_cc_gccs_TpCallAppInfo_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_cc_gccs_TpCallAppInfo"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpSessionID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/release:1.0
 */

static void decode_org_csapi_cc_gccs_IpCall_release(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        

        decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/deassignCall:1.0
 */

static void decode_org_csapi_cc_gccs_IpCall_deassignCall(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/getCallInfoReq:1.0
 */

static void decode_org_csapi_cc_gccs_IpCall_getCallInfoReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callInfoRequested = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/setCallChargePlan:1.0
 */

static void decode_org_csapi_cc_gccs_IpCall_setCallChargePlan(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallChargePlan"  */

        

        decode_org_csapi_cc_TpCallChargePlan_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallChargePlan"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/setAdviceOfCharge:1.0
 */

static void decode_org_csapi_cc_gccs_IpCall_setAdviceOfCharge(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_TpAoCInfo"  */

        

        decode_org_csapi_TpAoCInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAoCInfo"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"tariffSwitch = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/getMoreDialledDigitsReq:1.0
 */

static void decode_org_csapi_cc_gccs_IpCall_getMoreDialledDigitsReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"length = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/superviseCallReq:1.0
 */

static void decode_org_csapi_cc_gccs_IpCall_superviseCallReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"time = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"treatment = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/continueProcessing:1.0
 */

static void decode_org_csapi_cc_gccs_IpCall_continueProcessing(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCallControlManager/callAborted:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCallControlManager_callAborted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callReference = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCallControlManager/callEventNotify:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCallControlManager_callEventNotify(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cc_gccs_TpCallIdentifier"  */

        

        decode_org_csapi_cc_gccs_TpCallIdentifier_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_gccs_TpCallIdentifier"  */

        /*  Begin struct "org_csapi_cc_gccs_TpCallEventInfo"  */

        

        decode_org_csapi_cc_gccs_TpCallEventInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_gccs_TpCallEventInfo"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCallControlManager/callNotificationInterrupted:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCallControlManager_callNotificationInterrupted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCallControlManager/callNotificationContinued:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCallControlManager_callNotificationContinued(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCallControlManager/callOverloadEncountered:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCallControlManager_callOverloadEncountered(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCallControlManager/callOverloadCeased:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCallControlManager_callOverloadCeased(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCallControlManager/abortMultipleCalls:1.0
 */

static void decode_org_csapi_cc_gccs_IpAppCallControlManager_abortMultipleCalls(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_callReferenceSet;
    guint32   i_callReferenceSet;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_callReferenceSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of callReferenceSet = %u",u_octet4_loop_callReferenceSet);
        }

        for (i_callReferenceSet=0; i_callReferenceSet < u_octet4_loop_callReferenceSet; i_callReferenceSet++) {

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"callReferenceSet = %i",s_octet4);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCallControlManager/createCall:1.0
 */

static void decode_org_csapi_cc_gccs_IpCallControlManager_createCall(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_gccs_TpCallIdentifier"  */

            

            decode_org_csapi_cc_gccs_TpCallIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_gccs_TpCallIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCallControlManager/enableCallNotification:1.0
 */

static void decode_org_csapi_cc_gccs_IpCallControlManager_enableCallNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_cc_gccs_TpCallEventCriteria"  */

        

        decode_org_csapi_cc_gccs_TpCallEventCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_gccs_TpCallEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCallControlManager/disableCallNotification:1.0
 */

static void decode_org_csapi_cc_gccs_IpCallControlManager_disableCallNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCallControlManager/setCallLoadControl:1.0
 */

static void decode_org_csapi_cc_gccs_IpCallControlManager_setCallLoadControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"duration = %i",s_octet4);
        }

        /*  Begin union "org_csapi_cc_TpCallLoadControlMechanism"  */

        
        decode_org_csapi_cc_TpCallLoadControlMechanism_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_cc_TpCallLoadControlMechanism"  */

        /*  Begin struct "org_csapi_cc_gccs_TpCallTreatment"  */

        

        decode_org_csapi_cc_gccs_TpCallTreatment_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_gccs_TpCallTreatment"  */

        /*  Begin struct "org_csapi_TpAddressRange"  */

        

        decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddressRange"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCallControlManager/changeCallNotification:1.0
 */

static void decode_org_csapi_cc_gccs_IpCallControlManager_changeCallNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_gccs_TpCallEventCriteria"  */

        

        decode_org_csapi_cc_gccs_TpCallEventCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_gccs_TpCallEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCallControlManager/getCriteria:1.0
 */

static void decode_org_csapi_cc_gccs_IpCallControlManager_getCriteria(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpCallEventCriteriaResultSet;
    guint32   i_TpCallEventCriteriaResultSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpCallEventCriteriaResultSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallEventCriteriaResultSet = %u",u_octet4_loop_TpCallEventCriteriaResultSet);
            }

            for (i_TpCallEventCriteriaResultSet=0; i_TpCallEventCriteriaResultSet < u_octet4_loop_TpCallEventCriteriaResultSet; i_TpCallEventCriteriaResultSet++) {

                /*  Begin struct "org_csapi_cc_gccs_TpCallEventCriteriaResult"  */

                

                decode_org_csapi_cc_gccs_TpCallEventCriteriaResult_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_cc_gccs_TpCallEventCriteriaResult"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/eventReportRes:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppCallLeg_eventReportRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallEventInfo"  */

        

        decode_org_csapi_cc_TpCallEventInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallEventInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/eventReportErr:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppCallLeg_eventReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/attachMediaRes:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppCallLeg_attachMediaRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/attachMediaErr:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppCallLeg_attachMediaErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/detachMediaRes:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppCallLeg_detachMediaRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/detachMediaErr:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppCallLeg_detachMediaErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/getInfoRes:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppCallLeg_getInfoRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallLegInfoReport"  */

        

        decode_org_csapi_cc_TpCallLegInfoReport_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallLegInfoReport"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/getInfoErr:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppCallLeg_getInfoErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/routeErr:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppCallLeg_routeErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/superviseRes:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppCallLeg_superviseRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"report = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usedTime = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/superviseErr:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppCallLeg_superviseErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/callLegEnded:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppCallLeg_callLegEnded(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/createCall:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_createCall(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

            

            decode_org_csapi_cc_mpccs_TpMultiPartyCallIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/createNotification:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_cc_TpCallNotificationRequest"  */

        

        decode_org_csapi_cc_TpCallNotificationRequest_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallNotificationRequest"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/destroyNotification:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/changeNotification:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_changeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallNotificationRequest"  */

        

        decode_org_csapi_cc_TpCallNotificationRequest_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallNotificationRequest"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/getNotification:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_getNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpNotificationRequestedSet;
    guint32   i_TpNotificationRequestedSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpNotificationRequestedSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNotificationRequestedSet = %u",u_octet4_loop_TpNotificationRequestedSet);
            }

            for (i_TpNotificationRequestedSet=0; i_TpNotificationRequestedSet < u_octet4_loop_TpNotificationRequestedSet; i_TpNotificationRequestedSet++) {

                /*  Begin struct "org_csapi_cc_TpNotificationRequested"  */

                

                decode_org_csapi_cc_TpNotificationRequested_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_cc_TpNotificationRequested"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/setCallLoadControl:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_setCallLoadControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"duration = %i",s_octet4);
        }

        /*  Begin union "org_csapi_cc_TpCallLoadControlMechanism"  */

        
        decode_org_csapi_cc_TpCallLoadControlMechanism_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_cc_TpCallLoadControlMechanism"  */

        /*  Begin struct "org_csapi_cc_TpCallTreatment"  */

        

        decode_org_csapi_cc_TpCallTreatment_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallTreatment"  */

        /*  Begin struct "org_csapi_TpAddressRange"  */

        

        decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddressRange"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/enableNotifications:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_enableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/disableNotifications:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_disableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/getNextNotification:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_getNextNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",u_octet1);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_TpNotificationRequestedSetEntry"  */

            

            decode_org_csapi_cc_TpNotificationRequestedSetEntry_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_TpNotificationRequestedSetEntry"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/routeReq:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_routeReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_appInfo;
    guint32   i_appInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        u_octet4_loop_appInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of appInfo = %u",u_octet4_loop_appInfo);
        }

        for (i_appInfo=0; i_appInfo < u_octet4_loop_appInfo; i_appInfo++) {

            /*  Begin union "org_csapi_cc_TpCallAppInfo"  */

            
            decode_org_csapi_cc_TpCallAppInfo_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_cc_TpCallAppInfo"  */

        }

        /*  Begin struct "org_csapi_cc_TpCallLegConnectionProperties"  */

        

        decode_org_csapi_cc_TpCallLegConnectionProperties_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallLegConnectionProperties"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/eventReportReq:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_eventReportReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_eventsRequested;
    guint32   i_eventsRequested;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        u_octet4_loop_eventsRequested = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of eventsRequested = %u",u_octet4_loop_eventsRequested);
        }

        for (i_eventsRequested=0; i_eventsRequested < u_octet4_loop_eventsRequested; i_eventsRequested++) {

            /*  Begin struct "org_csapi_cc_TpCallEventRequest"  */

            

            decode_org_csapi_cc_TpCallEventRequest_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_TpCallEventRequest"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/release:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_release(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/getInfoReq:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_getInfoReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegInfoRequested = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/getCall:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_getCall(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

            

            decode_org_csapi_cc_mpccs_TpMultiPartyCallIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/attachMediaReq:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_attachMediaReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/detachMediaReq:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_detachMediaReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/getCurrentDestinationAddress:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_getCurrentDestinationAddress(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/continueProcessing:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_continueProcessing(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/setChargePlan:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_setChargePlan(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallChargePlan"  */

        

        decode_org_csapi_cc_TpCallChargePlan_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallChargePlan"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/setAdviceOfCharge:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_setAdviceOfCharge(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_TpAoCInfo"  */

        

        decode_org_csapi_TpAoCInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAoCInfo"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"tariffSwitch = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/superviseReq:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_superviseReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"time = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"treatment = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/deassign:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_deassign(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/getProperties:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_getProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_propertyNames;
    guint32   i_propertyNames;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpCallLegPropertyList;
    guint32   i_TpCallLegPropertyList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        u_octet4_loop_propertyNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of propertyNames = %u",u_octet4_loop_propertyNames);
        }

        for (i_propertyNames=0; i_propertyNames < u_octet4_loop_propertyNames; i_propertyNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"propertyNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpCallLegPropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallLegPropertyList = %u",u_octet4_loop_TpCallLegPropertyList);
            }

            for (i_TpCallLegPropertyList=0; i_TpCallLegPropertyList < u_octet4_loop_TpCallLegPropertyList; i_TpCallLegPropertyList++) {

                /*  Begin struct "org_csapi_cc_TpCallLegProperty"  */

                

                decode_org_csapi_cc_TpCallLegProperty_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_cc_TpCallLegProperty"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/setProperties:1.0
 */

static void decode_org_csapi_cc_mpccs_IpCallLeg_setProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_properties;
    guint32   i_properties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        u_octet4_loop_properties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of properties = %u",u_octet4_loop_properties);
        }

        for (i_properties=0; i_properties < u_octet4_loop_properties; i_properties++) {

            /*  Begin struct "org_csapi_cc_TpCallLegProperty"  */

            

            decode_org_csapi_cc_TpCallLegProperty_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_TpCallLegProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCall/getInfoRes:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_getInfoRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallInfoReport"  */

        

        decode_org_csapi_cc_TpCallInfoReport_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallInfoReport"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCall/getInfoErr:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_getInfoErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCall/superviseRes:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_superviseRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"report = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usedTime = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCall/superviseErr:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_superviseErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCall/callEnded:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_callEnded(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallEndedReport"  */

        

        decode_org_csapi_cc_TpCallEndedReport_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallEndedReport"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCall/createAndRouteCallLegErr:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_createAndRouteCallLegErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

        

        decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/getCallLegs:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCall_getCallLegs(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_TpCallLegIdentifierSet;
    guint32   i_TpCallLegIdentifierSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpCallLegIdentifierSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallLegIdentifierSet = %u",u_octet4_loop_TpCallLegIdentifierSet);
            }

            for (i_TpCallLegIdentifierSet=0; i_TpCallLegIdentifierSet < u_octet4_loop_TpCallLegIdentifierSet; i_TpCallLegIdentifierSet++) {

                /*  Begin struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

                

                decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/createCallLeg:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCall_createCallLeg(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

            

            decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/createAndRouteCallLegReq:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCall_createAndRouteCallLegReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_eventsRequested;
    guint32   i_eventsRequested;
    guint32   u_octet4_loop_appInfo;
    guint32   i_appInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        u_octet4_loop_eventsRequested = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of eventsRequested = %u",u_octet4_loop_eventsRequested);
        }

        for (i_eventsRequested=0; i_eventsRequested < u_octet4_loop_eventsRequested; i_eventsRequested++) {

            /*  Begin struct "org_csapi_cc_TpCallEventRequest"  */

            

            decode_org_csapi_cc_TpCallEventRequest_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_TpCallEventRequest"  */

        }

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        u_octet4_loop_appInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of appInfo = %u",u_octet4_loop_appInfo);
        }

        for (i_appInfo=0; i_appInfo < u_octet4_loop_appInfo; i_appInfo++) {

            /*  Begin union "org_csapi_cc_TpCallAppInfo"  */

            
            decode_org_csapi_cc_TpCallAppInfo_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_cc_TpCallAppInfo"  */

        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

            

            decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/release:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCall_release(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/deassignCall:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCall_deassignCall(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/getInfoReq:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCall_getInfoReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callInfoRequested = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/setChargePlan:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCall_setChargePlan(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallChargePlan"  */

        

        decode_org_csapi_cc_TpCallChargePlan_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallChargePlan"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/setAdviceOfCharge:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCall_setAdviceOfCharge(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_TpAoCInfo"  */

        

        decode_org_csapi_TpAoCInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAoCInfo"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"tariffSwitch = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/superviseReq:1.0
 */

static void decode_org_csapi_cc_mpccs_IpMultiPartyCall_superviseReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"time = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"treatment = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager/reportNotification:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_callLegReferenceSet;
    guint32   i_callLegReferenceSet;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

        

        decode_org_csapi_cc_mpccs_TpMultiPartyCallIdentifier_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

        u_octet4_loop_callLegReferenceSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of callLegReferenceSet = %u",u_octet4_loop_callLegReferenceSet);
        }

        for (i_callLegReferenceSet=0; i_callLegReferenceSet < u_octet4_loop_callLegReferenceSet; i_callLegReferenceSet++) {

            /*  Begin struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

            

            decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

        }

        /*  Begin struct "org_csapi_cc_TpCallNotificationInfo"  */

        

        decode_org_csapi_cc_TpCallNotificationInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallNotificationInfo"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin union "org_csapi_cc_mpccs_TpAppMultiPartyCallBack"  */

            
            decode_org_csapi_cc_mpccs_TpAppMultiPartyCallBack_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_cc_mpccs_TpAppMultiPartyCallBack"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager/callAborted:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callAborted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callReference = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager/managerInterrupted:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_managerInterrupted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager/managerResumed:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_managerResumed(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager/callOverloadEncountered:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callOverloadEncountered(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager/callOverloadCeased:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callOverloadCeased(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager/abortMultipleCalls:1.0
 */

static void decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_abortMultipleCalls(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_callReferenceSet;
    guint32   i_callReferenceSet;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_callReferenceSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of callReferenceSet = %u",u_octet4_loop_callReferenceSet);
        }

        for (i_callReferenceSet=0; i_callReferenceSet < u_octet4_loop_callReferenceSet; i_callReferenceSet++) {

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"callReferenceSet = %i",s_octet4);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpAppMultiMediaCall/superviseVolumeRes:1.0
 */

static void decode_org_csapi_cc_mmccs_IpAppMultiMediaCall_superviseVolumeRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"report = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_mmccs_TpCallSuperviseVolume"  */

        

        decode_org_csapi_cc_mmccs_TpCallSuperviseVolume_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_mmccs_TpCallSuperviseVolume"  */

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpDataSessionQosClass,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpAppMultiMediaCall/superviseVolumeErr:1.0
 */

static void decode_org_csapi_cc_mmccs_IpAppMultiMediaCall_superviseVolumeErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpAppMultiMediaCallLeg/mediaStreamMonitorRes:1.0
 */

static void decode_org_csapi_cc_mmccs_IpAppMultiMediaCallLeg_mediaStreamMonitorRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_streams;
    guint32   i_streams;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        u_octet4_loop_streams = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of streams = %u",u_octet4_loop_streams);
        }

        for (i_streams=0; i_streams < u_octet4_loop_streams; i_streams++) {

            /*  Begin struct "org_csapi_cc_mmccs_TpMediaStream"  */

            

            decode_org_csapi_cc_mmccs_TpMediaStream_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_mmccs_TpMediaStream"  */

        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mmccs_TpMediaStreamEventType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaStream/subtract:1.0
 */

static void decode_org_csapi_cc_mmccs_IpMultiMediaStream_subtract(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mediaStreamSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCallLeg/mediaStreamAllow:1.0
 */

static void decode_org_csapi_cc_mmccs_IpMultiMediaCallLeg_mediaStreamAllow(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_mediaStreamList;
    guint32   i_mediaStreamList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        u_octet4_loop_mediaStreamList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of mediaStreamList = %u",u_octet4_loop_mediaStreamList);
        }

        for (i_mediaStreamList=0; i_mediaStreamList < u_octet4_loop_mediaStreamList; i_mediaStreamList++) {

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"mediaStreamList = %i",s_octet4);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCallLeg/mediaStreamMonitorReq:1.0
 */

static void decode_org_csapi_cc_mmccs_IpMultiMediaCallLeg_mediaStreamMonitorReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_mediaStreamEventCriteria;
    guint32   i_mediaStreamEventCriteria;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        u_octet4_loop_mediaStreamEventCriteria = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of mediaStreamEventCriteria = %u",u_octet4_loop_mediaStreamEventCriteria);
        }

        for (i_mediaStreamEventCriteria=0; i_mediaStreamEventCriteria < u_octet4_loop_mediaStreamEventCriteria; i_mediaStreamEventCriteria++) {

            /*  Begin struct "org_csapi_cc_mmccs_TpMediaStreamRequest"  */

            

            decode_org_csapi_cc_mmccs_TpMediaStreamRequest_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_mmccs_TpMediaStreamRequest"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCallLeg/getMediaStreams:1.0
 */

static void decode_org_csapi_cc_mmccs_IpMultiMediaCallLeg_getMediaStreams(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_TpMediaStreamSet;
    guint32   i_TpMediaStreamSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpMediaStreamSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMediaStreamSet = %u",u_octet4_loop_TpMediaStreamSet);
            }

            for (i_TpMediaStreamSet=0; i_TpMediaStreamSet < u_octet4_loop_TpMediaStreamSet; i_TpMediaStreamSet++) {

                /*  Begin struct "org_csapi_cc_mmccs_TpMediaStream"  */

                

                decode_org_csapi_cc_mmccs_TpMediaStream_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_cc_mmccs_TpMediaStream"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCall/superviseVolumeReq:1.0
 */

static void decode_org_csapi_cc_mmccs_IpMultiMediaCall_superviseVolumeReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_mmccs_TpCallSuperviseVolume"  */

        

        decode_org_csapi_cc_mmccs_TpCallSuperviseVolume_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_mmccs_TpCallSuperviseVolume"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"treatment = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpAppMultiMediaCallControlManager/reportMediaNotification:1.0
 */

static void decode_org_csapi_cc_mmccs_IpAppMultiMediaCallControlManager_reportMediaNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_callLegReferenceSet;
    guint32   i_callLegReferenceSet;
    guint32   u_octet4_loop_mediaStreams;
    guint32   i_mediaStreams;
    guint32   u_octet4;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cc_mmccs_TpMultiMediaCallIdentifier"  */

        

        decode_org_csapi_cc_mmccs_TpMultiMediaCallIdentifier_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_mmccs_TpMultiMediaCallIdentifier"  */

        u_octet4_loop_callLegReferenceSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of callLegReferenceSet = %u",u_octet4_loop_callLegReferenceSet);
        }

        for (i_callLegReferenceSet=0; i_callLegReferenceSet < u_octet4_loop_callLegReferenceSet; i_callLegReferenceSet++) {

            /*  Begin struct "org_csapi_cc_mmccs_TpMultiMediaCallLegIdentifier"  */

            

            decode_org_csapi_cc_mmccs_TpMultiMediaCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_mmccs_TpMultiMediaCallLegIdentifier"  */

        }

        u_octet4_loop_mediaStreams = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of mediaStreams = %u",u_octet4_loop_mediaStreams);
        }

        for (i_mediaStreams=0; i_mediaStreams < u_octet4_loop_mediaStreams; i_mediaStreams++) {

            /*  Begin struct "org_csapi_cc_mmccs_TpMediaStream"  */

            

            decode_org_csapi_cc_mmccs_TpMediaStream_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_mmccs_TpMediaStream"  */

        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mmccs_TpMediaStreamEventType,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpDataSessionQosClass,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin union "org_csapi_cc_mmccs_TpAppMultiMediaCallBack"  */

            
            decode_org_csapi_cc_mmccs_TpAppMultiMediaCallBack_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_cc_mmccs_TpAppMultiMediaCallBack"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCallControlManager/createMediaNotification:1.0
 */

static void decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_createMediaNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_cc_mmccs_TpNotificationMediaRequest"  */

        

        decode_org_csapi_cc_mmccs_TpNotificationMediaRequest_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_mmccs_TpNotificationMediaRequest"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCallControlManager/destroyMediaNotification:1.0
 */

static void decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_destroyMediaNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCallControlManager/changeMediaNotification:1.0
 */

static void decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_changeMediaNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_mmccs_TpNotificationMediaRequest"  */

        

        decode_org_csapi_cc_mmccs_TpNotificationMediaRequest_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_mmccs_TpNotificationMediaRequest"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCallControlManager/getMediaNotification:1.0
 */

static void decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_getMediaNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpMediaNotificationRequestedSet;
    guint32   i_TpMediaNotificationRequestedSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpMediaNotificationRequestedSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMediaNotificationRequestedSet = %u",u_octet4_loop_TpMediaNotificationRequestedSet);
            }

            for (i_TpMediaNotificationRequestedSet=0; i_TpMediaNotificationRequestedSet < u_octet4_loop_TpMediaNotificationRequestedSet; i_TpMediaNotificationRequestedSet++) {

                /*  Begin struct "org_csapi_cc_mmccs_TpMediaNotificationRequested"  */

                

                decode_org_csapi_cc_mmccs_TpMediaNotificationRequested_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_cc_mmccs_TpMediaNotificationRequested"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpAppSubConfCall/chairSelection:1.0
 */

static void decode_org_csapi_cc_cccs_IpAppSubConfCall_chairSelection(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpAppSubConfCall/floorRequest:1.0
 */

static void decode_org_csapi_cc_cccs_IpAppSubConfCall_floorRequest(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpAppConfCall/partyJoined:1.0
 */

static void decode_org_csapi_cc_cccs_IpAppConfCall_partyJoined(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"conferenceSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

        

        decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

        /*  Begin struct "org_csapi_cc_cccs_TpJoinEventInfo"  */

        

        decode_org_csapi_cc_cccs_TpJoinEventInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_cccs_TpJoinEventInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpAppConfCall/leaveMonitorRes:1.0
 */

static void decode_org_csapi_cc_cccs_IpAppConfCall_leaveMonitorRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"conferenceSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLeg = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCallControlManager/createConference:1.0
 */

static void decode_org_csapi_cc_cccs_IpConfCallControlManager_createConference(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"numberOfSubConferences = %i",s_octet4);
        }

        /*  Begin union "org_csapi_cc_cccs_TpConfPolicy"  */

        
        decode_org_csapi_cc_cccs_TpConfPolicy_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_cc_cccs_TpConfPolicy"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"numberOfParticipants = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"duration = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_cccs_TpConfCallIdentifier"  */

            

            decode_org_csapi_cc_cccs_TpConfCallIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_cccs_TpConfCallIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCallControlManager/checkResources:1.0
 */

static void decode_org_csapi_cc_cccs_IpConfCallControlManager_checkResources(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cc_cccs_TpConfSearchCriteria"  */

        

        decode_org_csapi_cc_cccs_TpConfSearchCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_cccs_TpConfSearchCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_cccs_TpConfSearchResult"  */

            

            decode_org_csapi_cc_cccs_TpConfSearchResult_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_cccs_TpConfSearchResult"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCallControlManager/reserveResources:1.0
 */

static void decode_org_csapi_cc_cccs_IpConfCallControlManager_reserveResources(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"startTime (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"numberOfParticipants = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"duration = %i",s_octet4);
        }

        /*  Begin union "org_csapi_cc_cccs_TpConfPolicy"  */

        
        decode_org_csapi_cc_cccs_TpConfPolicy_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_cc_cccs_TpConfPolicy"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_cccs_TpResourceReservation"  */

            

            decode_org_csapi_cc_cccs_TpResourceReservation_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_cccs_TpResourceReservation"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCallControlManager/freeResources:1.0
 */

static void decode_org_csapi_cc_cccs_IpConfCallControlManager_freeResources(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cc_cccs_TpResourceReservation"  */

        

        decode_org_csapi_cc_cccs_TpResourceReservation_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_cccs_TpResourceReservation"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpAppConfCallControlManager/conferenceCreated:1.0
 */

static void decode_org_csapi_cc_cccs_IpAppConfCallControlManager_conferenceCreated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cc_cccs_TpConfCallIdentifier"  */

        

        decode_org_csapi_cc_cccs_TpConfCallIdentifier_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_cccs_TpConfCallIdentifier"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/splitSubConference:1.0
 */

static void decode_org_csapi_cc_cccs_IpSubConfCall_splitSubConference(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_callLegList;
    guint32   i_callLegList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",s_octet4);
        }

        u_octet4_loop_callLegList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of callLegList = %u",u_octet4_loop_callLegList);
        }

        for (i_callLegList=0; i_callLegList < u_octet4_loop_callLegList; i_callLegList++) {

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"callLegList = %i",s_octet4);
            }

        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_cccs_TpSubConfCallIdentifier"  */

            

            decode_org_csapi_cc_cccs_TpSubConfCallIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_cccs_TpSubConfCallIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/mergeSubConference:1.0
 */

static void decode_org_csapi_cc_cccs_IpSubConfCall_mergeSubConference(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceCallSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"targetSubConferenceCall = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/moveCallLeg:1.0
 */

static void decode_org_csapi_cc_cccs_IpSubConfCall_moveCallLeg(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceCallSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"targetSubConferenceCall = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLeg = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/inspectVideo:1.0
 */

static void decode_org_csapi_cc_cccs_IpSubConfCall_inspectVideo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"inspectedCallLeg = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/inspectVideoCancel:1.0
 */

static void decode_org_csapi_cc_cccs_IpSubConfCall_inspectVideoCancel(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/appointSpeaker:1.0
 */

static void decode_org_csapi_cc_cccs_IpSubConfCall_appointSpeaker(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"speakerCallLeg = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/chairSelection:1.0
 */

static void decode_org_csapi_cc_cccs_IpSubConfCall_chairSelection(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"chairCallLeg = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/changeConferencePolicy:1.0
 */

static void decode_org_csapi_cc_cccs_IpSubConfCall_changeConferencePolicy(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",s_octet4);
        }

        /*  Begin union "org_csapi_cc_cccs_TpConfPolicy"  */

        
        decode_org_csapi_cc_cccs_TpConfPolicy_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_cc_cccs_TpConfPolicy"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCall/getSubConferences:1.0
 */

static void decode_org_csapi_cc_cccs_IpConfCall_getSubConferences(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_TpSubConfCallIdentifierSet;
    guint32   i_TpSubConfCallIdentifierSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"conferenceSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpSubConfCallIdentifierSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpSubConfCallIdentifierSet = %u",u_octet4_loop_TpSubConfCallIdentifierSet);
            }

            for (i_TpSubConfCallIdentifierSet=0; i_TpSubConfCallIdentifierSet < u_octet4_loop_TpSubConfCallIdentifierSet; i_TpSubConfCallIdentifierSet++) {

                /*  Begin struct "org_csapi_cc_cccs_TpSubConfCallIdentifier"  */

                

                decode_org_csapi_cc_cccs_TpSubConfCallIdentifier_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_cc_cccs_TpSubConfCallIdentifier"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCall/createSubConference:1.0
 */

static void decode_org_csapi_cc_cccs_IpConfCall_createSubConference(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"conferenceSessionID = %i",s_octet4);
        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin union "org_csapi_cc_cccs_TpConfPolicy"  */

        
        decode_org_csapi_cc_cccs_TpConfPolicy_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_cc_cccs_TpConfPolicy"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_cccs_TpSubConfCallIdentifier"  */

            

            decode_org_csapi_cc_cccs_TpSubConfCallIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_cccs_TpSubConfCallIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCall/leaveMonitorReq:1.0
 */

static void decode_org_csapi_cc_cccs_IpConfCall_leaveMonitorReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"conferenceSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCall/getConferenceAddress:1.0
 */

static void decode_org_csapi_cc_cccs_IpConfCall_getConferenceAddress(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"conferenceSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUI/sendInfoRes:1.0
 */

static void decode_org_csapi_ui_IpAppUI_sendInfoRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIReport,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUI/sendInfoErr:1.0
 */

static void decode_org_csapi_ui_IpAppUI_sendInfoErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUI/sendInfoAndCollectRes:1.0
 */

static void decode_org_csapi_ui_IpAppUI_sendInfoAndCollectRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIReport,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"collectedInfo (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUI/sendInfoAndCollectErr:1.0
 */

static void decode_org_csapi_ui_IpAppUI_sendInfoAndCollectErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUI/userInteractionFaultDetected:1.0
 */

static void decode_org_csapi_ui_IpAppUI_userInteractionFaultDetected(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/recordMessageRes:1.0
 */

static void decode_org_csapi_ui_IpAppUICall_recordMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIReport,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"messageID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/recordMessageErr:1.0
 */

static void decode_org_csapi_ui_IpAppUICall_recordMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/deleteMessageRes:1.0
 */

static void decode_org_csapi_ui_IpAppUICall_deleteMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIReport,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/deleteMessageErr:1.0
 */

static void decode_org_csapi_ui_IpAppUICall_deleteMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/abortActionRes:1.0
 */

static void decode_org_csapi_ui_IpAppUICall_abortActionRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/abortActionErr:1.0
 */

static void decode_org_csapi_ui_IpAppUICall_abortActionErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/getMessageRes:1.0
 */

static void decode_org_csapi_ui_IpAppUICall_getMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        /*  Begin union "org_csapi_ui_TpUIInfo"  */

        
        decode_org_csapi_ui_TpUIInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_ui_TpUIInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/getMessageErr:1.0
 */

static void decode_org_csapi_ui_IpAppUICall_getMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIManager/userInteractionAborted:1.0
 */

static void decode_org_csapi_ui_IpAppUIManager_userInteractionAborted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_ui_TpUIIdentifier"  */

        

        decode_org_csapi_ui_TpUIIdentifier_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_ui_TpUIIdentifier"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIManager/userInteractionNotificationInterrupted:1.0
 */

static void decode_org_csapi_ui_IpAppUIManager_userInteractionNotificationInterrupted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIManager/userInteractionNotificationContinued:1.0
 */

static void decode_org_csapi_ui_IpAppUIManager_userInteractionNotificationContinued(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIManager/reportEventNotification:1.0
 */

static void decode_org_csapi_ui_IpAppUIManager_reportEventNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_ui_TpUIIdentifier"  */

        

        decode_org_csapi_ui_TpUIIdentifier_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_ui_TpUIIdentifier"  */

        /*  Begin struct "org_csapi_ui_TpUIEventNotificationInfo"  */

        

        decode_org_csapi_ui_TpUIEventNotificationInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_ui_TpUIEventNotificationInfo"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIManager/abortMultipleUserInteractions:1.0
 */

static void decode_org_csapi_ui_IpAppUIManager_abortMultipleUserInteractions(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_userInteractionSet;
    guint32   i_userInteractionSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_userInteractionSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of userInteractionSet = %u",u_octet4_loop_userInteractionSet);
        }

        for (i_userInteractionSet=0; i_userInteractionSet < u_octet4_loop_userInteractionSet; i_userInteractionSet++) {

            /*  Begin struct "org_csapi_ui_TpUIIdentifier"  */

            

            decode_org_csapi_ui_TpUIIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_ui_TpUIIdentifier"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUI/sendInfoReq:1.0
 */

static void decode_org_csapi_ui_IpUI_sendInfoReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_variableInfo;
    guint32   i_variableInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        /*  Begin union "org_csapi_ui_TpUIInfo"  */

        
        decode_org_csapi_ui_TpUIInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_ui_TpUIInfo"  */

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"language (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_variableInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of variableInfo = %u",u_octet4_loop_variableInfo);
        }

        for (i_variableInfo=0; i_variableInfo < u_octet4_loop_variableInfo; i_variableInfo++) {

            /*  Begin union "org_csapi_ui_TpUIVariableInfo"  */

            
            decode_org_csapi_ui_TpUIVariableInfo_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_ui_TpUIVariableInfo"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"repeatIndicator = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"responseRequested = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUI/sendInfoAndCollectReq:1.0
 */

static void decode_org_csapi_ui_IpUI_sendInfoAndCollectReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_variableInfo;
    guint32   i_variableInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        /*  Begin union "org_csapi_ui_TpUIInfo"  */

        
        decode_org_csapi_ui_TpUIInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_ui_TpUIInfo"  */

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"language (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_variableInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of variableInfo = %u",u_octet4_loop_variableInfo);
        }

        for (i_variableInfo=0; i_variableInfo < u_octet4_loop_variableInfo; i_variableInfo++) {

            /*  Begin union "org_csapi_ui_TpUIVariableInfo"  */

            
            decode_org_csapi_ui_TpUIVariableInfo_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_ui_TpUIVariableInfo"  */

        }

        /*  Begin struct "org_csapi_ui_TpUICollectCriteria"  */

        

        decode_org_csapi_ui_TpUICollectCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_ui_TpUICollectCriteria"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"responseRequested = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUI/release:1.0
 */

static void decode_org_csapi_ui_IpUI_release(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUI/setOriginatingAddress:1.0
 */

static void decode_org_csapi_ui_IpUI_setOriginatingAddress(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"origin (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUI/getOriginatingAddress:1.0
 */

static void decode_org_csapi_ui_IpUI_getOriginatingAddress(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpString (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUICall/recordMessageReq:1.0
 */

static void decode_org_csapi_ui_IpUICall_recordMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        /*  Begin union "org_csapi_ui_TpUIInfo"  */

        
        decode_org_csapi_ui_TpUIInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_ui_TpUIInfo"  */

        /*  Begin struct "org_csapi_ui_TpUIMessageCriteria"  */

        

        decode_org_csapi_ui_TpUIMessageCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_ui_TpUIMessageCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUICall/deleteMessageReq:1.0
 */

static void decode_org_csapi_ui_IpUICall_deleteMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"messageID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUICall/abortActionReq:1.0
 */

static void decode_org_csapi_ui_IpUICall_abortActionReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUICall/getMessageReq:1.0
 */

static void decode_org_csapi_ui_IpUICall_getMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"messageID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/createUI:1.0
 */

static void decode_org_csapi_ui_IpUIManager_createUI(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_ui_TpUIIdentifier"  */

            

            decode_org_csapi_ui_TpUIIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_ui_TpUIIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/createUICall:1.0
 */

static void decode_org_csapi_ui_IpUIManager_createUICall(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin union "org_csapi_ui_TpUITargetObject"  */

        
        decode_org_csapi_ui_TpUITargetObject_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_ui_TpUITargetObject"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_ui_TpUICallIdentifier"  */

            

            decode_org_csapi_ui_TpUICallIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_ui_TpUICallIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/createNotification:1.0
 */

static void decode_org_csapi_ui_IpUIManager_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_ui_TpUIEventCriteria"  */

        

        decode_org_csapi_ui_TpUIEventCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_ui_TpUIEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/destroyNotification:1.0
 */

static void decode_org_csapi_ui_IpUIManager_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/changeNotification:1.0
 */

static void decode_org_csapi_ui_IpUIManager_changeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_ui_TpUIEventCriteria"  */

        

        decode_org_csapi_ui_TpUIEventCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_ui_TpUIEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/getNotification:1.0
 */

static void decode_org_csapi_ui_IpUIManager_getNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpUIEventCriteriaResultSet;
    guint32   i_TpUIEventCriteriaResultSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpUIEventCriteriaResultSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpUIEventCriteriaResultSet = %u",u_octet4_loop_TpUIEventCriteriaResultSet);
            }

            for (i_TpUIEventCriteriaResultSet=0; i_TpUIEventCriteriaResultSet < u_octet4_loop_TpUIEventCriteriaResultSet; i_TpUIEventCriteriaResultSet++) {

                /*  Begin struct "org_csapi_ui_TpUIEventCriteriaResult"  */

                

                decode_org_csapi_ui_TpUIEventCriteriaResult_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_ui_TpUIEventCriteriaResult"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/enableNotifications:1.0
 */

static void decode_org_csapi_ui_IpUIManager_enableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/disableNotifications:1.0
 */

static void decode_org_csapi_ui_IpUIManager_disableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/getMessageRes:1.0
 */

static void decode_org_csapi_ui_IpAppUIAdminManager_getMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        /*  Begin union "org_csapi_ui_TpUIInfo"  */

        
        decode_org_csapi_ui_TpUIInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_ui_TpUIInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/getMessageErr:1.0
 */

static void decode_org_csapi_ui_IpAppUIAdminManager_getMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/deleteMessageRes:1.0
 */

static void decode_org_csapi_ui_IpAppUIAdminManager_deleteMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIReport,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/deleteMessageErr:1.0
 */

static void decode_org_csapi_ui_IpAppUIAdminManager_deleteMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/putMessageRes:1.0
 */

static void decode_org_csapi_ui_IpAppUIAdminManager_putMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"messageID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/putMessageErr:1.0
 */

static void decode_org_csapi_ui_IpAppUIAdminManager_putMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/getMessageListRes:1.0
 */

static void decode_org_csapi_ui_IpAppUIAdminManager_getMessageListRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_messageIDList;
    guint32   i_messageIDList;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        u_octet4_loop_messageIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of messageIDList = %u",u_octet4_loop_messageIDList);
        }

        for (i_messageIDList=0; i_messageIDList < u_octet4_loop_messageIDList; i_messageIDList++) {

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"messageIDList = %i",s_octet4);
            }

        }

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"final = %u",u_octet1);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/getMessageListErr:1.0
 */

static void decode_org_csapi_ui_IpAppUIAdminManager_getMessageListErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIAdminManager/getMessageReq:1.0
 */

static void decode_org_csapi_ui_IpUIAdminManager_getMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"messageID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIAdminManager/putMessageReq:1.0
 */

static void decode_org_csapi_ui_IpUIAdminManager_putMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        /*  Begin union "org_csapi_ui_TpUIInfo"  */

        
        decode_org_csapi_ui_TpUIInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_ui_TpUIInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIAdminManager/deleteMessageReq:1.0
 */

static void decode_org_csapi_ui_IpUIAdminManager_deleteMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"messageID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIAdminManager/getMessageListReq:1.0
 */

static void decode_org_csapi_ui_IpUIAdminManager_getMessageListReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",s_octet4);
        }

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",u_octet1);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppUserLocation/locationReportRes:1.0
 */

static void decode_org_csapi_mm_ul_IpAppUserLocation_locationReportRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_locations;
    guint32   i_locations;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        u_octet4_loop_locations = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of locations = %u",u_octet4_loop_locations);
        }

        for (i_locations=0; i_locations < u_octet4_loop_locations; i_locations++) {

            /*  Begin struct "org_csapi_mm_TpUserLocation"  */

            

            decode_org_csapi_mm_TpUserLocation_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mm_TpUserLocation"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppUserLocation/locationReportErr:1.0
 */

static void decode_org_csapi_mm_ul_IpAppUserLocation_locationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppUserLocation/extendedLocationReportRes:1.0
 */

static void decode_org_csapi_mm_ul_IpAppUserLocation_extendedLocationReportRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_locations;
    guint32   i_locations;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        u_octet4_loop_locations = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of locations = %u",u_octet4_loop_locations);
        }

        for (i_locations=0; i_locations < u_octet4_loop_locations; i_locations++) {

            /*  Begin struct "org_csapi_mm_TpUserLocationExtended"  */

            

            decode_org_csapi_mm_TpUserLocationExtended_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mm_TpUserLocationExtended"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppUserLocation/extendedLocationReportErr:1.0
 */

static void decode_org_csapi_mm_ul_IpAppUserLocation_extendedLocationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppUserLocation/periodicLocationReport:1.0
 */

static void decode_org_csapi_mm_ul_IpAppUserLocation_periodicLocationReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_locations;
    guint32   i_locations;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        u_octet4_loop_locations = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of locations = %u",u_octet4_loop_locations);
        }

        for (i_locations=0; i_locations < u_octet4_loop_locations; i_locations++) {

            /*  Begin struct "org_csapi_mm_TpUserLocationExtended"  */

            

            decode_org_csapi_mm_TpUserLocationExtended_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mm_TpUserLocationExtended"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppUserLocation/periodicLocationReportErr:1.0
 */

static void decode_org_csapi_mm_ul_IpAppUserLocation_periodicLocationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpUserLocation/locationReportReq:1.0
 */

static void decode_org_csapi_mm_ul_IpUserLocation_locationReportReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpUserLocation/extendedLocationReportReq:1.0
 */

static void decode_org_csapi_mm_ul_IpUserLocation_extendedLocationReportReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        /*  Begin struct "org_csapi_mm_TpLocationRequest"  */

        

        decode_org_csapi_mm_TpLocationRequest_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpLocationRequest"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpUserLocation/periodicLocationReportingStartReq:1.0
 */

static void decode_org_csapi_mm_ul_IpUserLocation_periodicLocationReportingStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        /*  Begin struct "org_csapi_mm_TpLocationRequest"  */

        

        decode_org_csapi_mm_TpLocationRequest_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpLocationRequest"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"reportingInterval = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpUserLocation/periodicLocationReportingStop:1.0
 */

static void decode_org_csapi_mm_ul_IpUserLocation_periodicLocationReportingStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        

        decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpUserLocation/getNextPeriodicLocationRequest:1.0
 */

static void decode_org_csapi_mm_ul_IpUserLocation_getNextPeriodicLocationRequest(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",u_octet1);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mm_TpPeriodicLocationRequestSetEntry"  */

            

            decode_org_csapi_mm_TpPeriodicLocationRequestSetEntry_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mm_TpPeriodicLocationRequestSetEntry"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppTriggeredUserLocation/triggeredLocationReport:1.0
 */

static void decode_org_csapi_mm_ul_IpAppTriggeredUserLocation_triggeredLocationReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_mm_TpUserLocationExtended"  */

        

        decode_org_csapi_mm_TpUserLocationExtended_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpUserLocationExtended"  */

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpLocationTriggerCriteria,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppTriggeredUserLocation/triggeredLocationReportErr:1.0
 */

static void decode_org_csapi_mm_ul_IpAppTriggeredUserLocation_triggeredLocationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpTriggeredUserLocation/triggeredLocationReportingStartReq:1.0
 */

static void decode_org_csapi_mm_ul_IpTriggeredUserLocation_triggeredLocationReportingStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    guint32   u_octet4_loop_triggers;
    guint32   i_triggers;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        /*  Begin struct "org_csapi_mm_TpLocationRequest"  */

        

        decode_org_csapi_mm_TpLocationRequest_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpLocationRequest"  */

        u_octet4_loop_triggers = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of triggers = %u",u_octet4_loop_triggers);
        }

        for (i_triggers=0; i_triggers < u_octet4_loop_triggers; i_triggers++) {

            /*  Begin struct "org_csapi_mm_TpLocationTrigger"  */

            

            decode_org_csapi_mm_TpLocationTrigger_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mm_TpLocationTrigger"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpTriggeredUserLocation/triggeredLocationReportingStop:1.0
 */

static void decode_org_csapi_mm_ul_IpTriggeredUserLocation_triggeredLocationReportingStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        

        decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpTriggeredUserLocation/getNextTriggeredLocationRequest:1.0
 */

static void decode_org_csapi_mm_ul_IpTriggeredUserLocation_getNextTriggeredLocationRequest(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",u_octet1);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mm_TpTriggeredLocationRequestSetEntry"  */

            

            decode_org_csapi_mm_TpTriggeredLocationRequestSetEntry_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mm_TpTriggeredLocationRequestSetEntry"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpAppUserLocationCamel/locationReportRes:1.0
 */

static void decode_org_csapi_mm_ulc_IpAppUserLocationCamel_locationReportRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_locations;
    guint32   i_locations;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        u_octet4_loop_locations = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of locations = %u",u_octet4_loop_locations);
        }

        for (i_locations=0; i_locations < u_octet4_loop_locations; i_locations++) {

            /*  Begin struct "org_csapi_mm_TpUserLocationCamel"  */

            

            decode_org_csapi_mm_TpUserLocationCamel_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mm_TpUserLocationCamel"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpAppUserLocationCamel/locationReportErr:1.0
 */

static void decode_org_csapi_mm_ulc_IpAppUserLocationCamel_locationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpAppUserLocationCamel/periodicLocationReport:1.0
 */

static void decode_org_csapi_mm_ulc_IpAppUserLocationCamel_periodicLocationReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_locations;
    guint32   i_locations;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        u_octet4_loop_locations = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of locations = %u",u_octet4_loop_locations);
        }

        for (i_locations=0; i_locations < u_octet4_loop_locations; i_locations++) {

            /*  Begin struct "org_csapi_mm_TpUserLocationCamel"  */

            

            decode_org_csapi_mm_TpUserLocationCamel_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mm_TpUserLocationCamel"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpAppUserLocationCamel/periodicLocationReportErr:1.0
 */

static void decode_org_csapi_mm_ulc_IpAppUserLocationCamel_periodicLocationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpAppUserLocationCamel/triggeredLocationReport:1.0
 */

static void decode_org_csapi_mm_ulc_IpAppUserLocationCamel_triggeredLocationReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_mm_TpUserLocationCamel"  */

        

        decode_org_csapi_mm_TpUserLocationCamel_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpUserLocationCamel"  */

        /*  Begin struct "org_csapi_mm_TpLocationTriggerCamel"  */

        

        decode_org_csapi_mm_TpLocationTriggerCamel_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpLocationTriggerCamel"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpAppUserLocationCamel/triggeredLocationReportErr:1.0
 */

static void decode_org_csapi_mm_ulc_IpAppUserLocationCamel_triggeredLocationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpUserLocationCamel/locationReportReq:1.0
 */

static void decode_org_csapi_mm_ulc_IpUserLocationCamel_locationReportReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpUserLocationCamel/periodicLocationReportingStartReq:1.0
 */

static void decode_org_csapi_mm_ulc_IpUserLocationCamel_periodicLocationReportingStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"reportingInterval = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpUserLocationCamel/periodicLocationReportingStop:1.0
 */

static void decode_org_csapi_mm_ulc_IpUserLocationCamel_periodicLocationReportingStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        

        decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpUserLocationCamel/triggeredLocationReportingStartReq:1.0
 */

static void decode_org_csapi_mm_ulc_IpUserLocationCamel_triggeredLocationReportingStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        /*  Begin struct "org_csapi_mm_TpLocationTriggerCamel"  */

        

        decode_org_csapi_mm_TpLocationTriggerCamel_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpLocationTriggerCamel"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpUserLocationCamel/triggeredLocationReportingStop:1.0
 */

static void decode_org_csapi_mm_ulc_IpUserLocationCamel_triggeredLocationReportingStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        

        decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpUserLocationCamel/getNextPeriodicLocationRequest:1.0
 */

static void decode_org_csapi_mm_ulc_IpUserLocationCamel_getNextPeriodicLocationRequest(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",u_octet1);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mm_TpPeriodicLocationRequestSetEntry"  */

            

            decode_org_csapi_mm_TpPeriodicLocationRequestSetEntry_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mm_TpPeriodicLocationRequestSetEntry"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpUserLocationCamel/getNextTriggeredLocationRequest:1.0
 */

static void decode_org_csapi_mm_ulc_IpUserLocationCamel_getNextTriggeredLocationRequest(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",u_octet1);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mm_TpTriggeredLocationRequestSetEntry"  */

            

            decode_org_csapi_mm_TpTriggeredLocationRequestSetEntry_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mm_TpTriggeredLocationRequestSetEntry"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ule/IpAppUserLocationEmergency/emergencyLocationReport:1.0
 */

static void decode_org_csapi_mm_ule_IpAppUserLocationEmergency_emergencyLocationReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_mm_TpUserLocationEmergency"  */

        

        decode_org_csapi_mm_TpUserLocationEmergency_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpUserLocationEmergency"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ule/IpAppUserLocationEmergency/emergencyLocationReportErr:1.0
 */

static void decode_org_csapi_mm_ule_IpAppUserLocationEmergency_emergencyLocationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ule/IpUserLocationEmergency/emergencyLocationReportReq:1.0
 */

static void decode_org_csapi_mm_ule_IpUserLocationEmergency_emergencyLocationReportReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_mm_TpUserLocationEmergencyRequest"  */

        

        decode_org_csapi_mm_TpUserLocationEmergencyRequest_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpUserLocationEmergencyRequest"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ule/IpUserLocationEmergency/subscribeEmergencyLocationReports:1.0
 */

static void decode_org_csapi_mm_ule_IpUserLocationEmergency_subscribeEmergencyLocationReports(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ule/IpUserLocationEmergency/unSubscribeEmergencyLocationReports:1.0
 */

static void decode_org_csapi_mm_ule_IpUserLocationEmergency_unSubscribeEmergencyLocationReports(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/statusReportRes:1.0
 */

static void decode_org_csapi_mm_us_IpAppUserStatus_statusReportRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_status;
    guint32   i_status;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        u_octet4_loop_status = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of status = %u",u_octet4_loop_status);
        }

        for (i_status=0; i_status < u_octet4_loop_status; i_status++) {

            /*  Begin struct "org_csapi_mm_TpUserStatus"  */

            

            decode_org_csapi_mm_TpUserStatus_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mm_TpUserStatus"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/statusReportErr:1.0
 */

static void decode_org_csapi_mm_us_IpAppUserStatus_statusReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/triggeredStatusReport:1.0
 */

static void decode_org_csapi_mm_us_IpAppUserStatus_triggeredStatusReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_mm_TpUserStatus"  */

        

        decode_org_csapi_mm_TpUserStatus_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpUserStatus"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/triggeredStatusReportErr:1.0
 */

static void decode_org_csapi_mm_us_IpAppUserStatus_triggeredStatusReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/extendedStatusReportRes:1.0
 */

static void decode_org_csapi_mm_us_IpAppUserStatus_extendedStatusReportRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_status;
    guint32   i_status;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        u_octet4_loop_status = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of status = %u",u_octet4_loop_status);
        }

        for (i_status=0; i_status < u_octet4_loop_status; i_status++) {

            /*  Begin struct "org_csapi_mm_TpUserStatusExtended"  */

            

            decode_org_csapi_mm_TpUserStatusExtended_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mm_TpUserStatusExtended"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/extendedStatusReportErr:1.0
 */

static void decode_org_csapi_mm_us_IpAppUserStatus_extendedStatusReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/extTriggeredStatusReport:1.0
 */

static void decode_org_csapi_mm_us_IpAppUserStatus_extTriggeredStatusReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_mm_TpUserStatusExtended"  */

        

        decode_org_csapi_mm_TpUserStatusExtended_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpUserStatusExtended"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/extTriggeredStatusReportErr:1.0
 */

static void decode_org_csapi_mm_us_IpAppUserStatus_extTriggeredStatusReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpUserStatus/statusReportReq:1.0
 */

static void decode_org_csapi_mm_us_IpUserStatus_statusReportReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpUserStatus/triggeredStatusReportingStartReq:1.0
 */

static void decode_org_csapi_mm_us_IpUserStatus_triggeredStatusReportingStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpUserStatus/triggeredStatusReportingStop:1.0
 */

static void decode_org_csapi_mm_us_IpUserStatus_triggeredStatusReportingStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        

        decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpUserStatus/getNextTriggeredStatusRequest:1.0
 */

static void decode_org_csapi_mm_us_IpUserStatus_getNextTriggeredStatusRequest(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",u_octet1);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mm_TpTriggeredStatusRequestSetEntry"  */

            

            decode_org_csapi_mm_TpTriggeredStatusRequestSetEntry_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mm_TpTriggeredStatusRequestSetEntry"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpUserStatus/extendedStatusReportReq:1.0
 */

static void decode_org_csapi_mm_us_IpUserStatus_extendedStatusReportReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpUserStatus/extTriggeredStatusReportingStartReq:1.0
 */

static void decode_org_csapi_mm_us_IpUserStatus_extTriggeredStatusReportingStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpUserStatus/extTriggeredStatusReportingStop:1.0
 */

static void decode_org_csapi_mm_us_IpUserStatus_extTriggeredStatusReportingStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        

        decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ub/IpAppUserBinding/triggeredBindingRequestNotification:1.0
 */

static void decode_org_csapi_mm_ub_IpAppUserBinding_triggeredBindingRequestNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_contactInformation;
    guint32   i_contactInformation;
    guint32   u_octet4_loop_TpBindingSet;
    guint32   i_TpBindingSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        u_octet4_loop_contactInformation = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of contactInformation = %u",u_octet4_loop_contactInformation);
        }

        for (i_contactInformation=0; i_contactInformation < u_octet4_loop_contactInformation; i_contactInformation++) {

            u_octet4_loop_contactInformation = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of contactInformation = %u",u_octet4_loop_contactInformation);
            }

            for (i_contactInformation=0; i_contactInformation < u_octet4_loop_contactInformation; i_contactInformation++) {

                /*  Begin union "org_csapi_mm_TpBindingEntry"  */

                
                decode_org_csapi_mm_TpBindingEntry_un(tvb, pinfo, tree, offset, header, operation);

                /*  End union "org_csapi_mm_TpBindingEntry"  */

            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpBindingSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpBindingSet = %u",u_octet4_loop_TpBindingSet);
            }

            for (i_TpBindingSet=0; i_TpBindingSet < u_octet4_loop_TpBindingSet; i_TpBindingSet++) {

                u_octet4_loop_TpBindingSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpBindingSet = %u",u_octet4_loop_TpBindingSet);
                }

                for (i_TpBindingSet=0; i_TpBindingSet < u_octet4_loop_TpBindingSet; i_TpBindingSet++) {

                    /*  Begin union "org_csapi_mm_TpBindingEntry"  */

                    
                    decode_org_csapi_mm_TpBindingEntry_un(tvb, pinfo, tree, offset, header, operation);

                    /*  End union "org_csapi_mm_TpBindingEntry"  */

                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ub/IpAppUserBinding/triggeredBindingRequestNotificationStartErr:1.0
 */

static void decode_org_csapi_mm_ub_IpAppUserBinding_triggeredBindingRequestNotificationStartErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ub/IpUserBinding/triggeredBindingRequestNotificationStartReq:1.0
 */

static void decode_org_csapi_mm_ub_IpUserBinding_triggeredBindingRequestNotificationStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    guint32   u_octet4_loop_criteria;
    guint32   i_criteria;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        u_octet4_loop_criteria = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of criteria = %u",u_octet4_loop_criteria);
        }

        for (i_criteria=0; i_criteria < u_octet4_loop_criteria; i_criteria++) {

            /*  Begin struct "org_csapi_mm_TpBindingNotificationCriteria"  */

            

            decode_org_csapi_mm_TpBindingNotificationCriteria_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mm_TpBindingNotificationCriteria"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ub/IpUserBinding/triggeredBindingRequestNotificationStop:1.0
 */

static void decode_org_csapi_mm_ub_IpUserBinding_triggeredBindingRequestNotificationStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/termcap/IpTerminalCapabilities/getTerminalCapabilities:1.0
 */

static void decode_org_csapi_termcap_IpTerminalCapabilities_getTerminalCapabilities(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"terminalIdentity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_termcap_TpTerminalCapabilities"  */

            

            decode_org_csapi_termcap_TpTerminalCapabilities_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_termcap_TpTerminalCapabilities"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/termcap/IpAppExtendedTerminalCapabilities/triggeredTerminalCapabilityReport:1.0
 */

static void decode_org_csapi_termcap_IpAppExtendedTerminalCapabilities_triggeredTerminalCapabilityReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_terminals;
    guint32   i_terminals;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        u_octet4_loop_terminals = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of terminals = %u",u_octet4_loop_terminals);
        }

        for (i_terminals=0; i_terminals < u_octet4_loop_terminals; i_terminals++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"criteria = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_termcap_TpTerminalCapabilities"  */

        

        decode_org_csapi_termcap_TpTerminalCapabilities_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_termcap_TpTerminalCapabilities"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/termcap/IpAppExtendedTerminalCapabilities/triggeredTerminalCapabilityReportErr:1.0
 */

static void decode_org_csapi_termcap_IpAppExtendedTerminalCapabilities_triggeredTerminalCapabilityReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_terminals;
    guint32   i_terminals;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        u_octet4_loop_terminals = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of terminals = %u",u_octet4_loop_terminals);
        }

        for (i_terminals=0; i_terminals < u_octet4_loop_terminals; i_terminals++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_termcap_TpTerminalCapabilitiesError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/termcap/IpExtendedTerminalCapabilities/triggeredTerminalCapabilityStartReq:1.0
 */

static void decode_org_csapi_termcap_IpExtendedTerminalCapabilities_triggeredTerminalCapabilityStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_terminals;
    guint32   i_terminals;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_terminals = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of terminals = %u",u_octet4_loop_terminals);
        }

        for (i_terminals=0; i_terminals < u_octet4_loop_terminals; i_terminals++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        /*  Begin struct "org_csapi_termcap_TpTerminalCapabilityScope"  */

        

        decode_org_csapi_termcap_TpTerminalCapabilityScope_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_termcap_TpTerminalCapabilityScope"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"criteria = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/termcap/IpExtendedTerminalCapabilities/triggeredTerminalCapabilityStop:1.0
 */

static void decode_org_csapi_termcap_IpExtendedTerminalCapabilities_triggeredTerminalCapabilityStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSession/connectRes:1.0
 */

static void decode_org_csapi_dsc_IpAppDataSession_connectRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionReport"  */

        

        decode_org_csapi_dsc_TpDataSessionReport_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_dsc_TpDataSessionReport"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSession/connectErr:1.0
 */

static void decode_org_csapi_dsc_IpAppDataSession_connectErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionError"  */

        

        decode_org_csapi_dsc_TpDataSessionError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_dsc_TpDataSessionError"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSession/superviseDataSessionRes:1.0
 */

static void decode_org_csapi_dsc_IpAppDataSession_superviseDataSessionRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"report = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionSuperviseVolume"  */

        

        decode_org_csapi_dsc_TpDataSessionSuperviseVolume_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_dsc_TpDataSessionSuperviseVolume"  */

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpDataSessionQosClass,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSession/superviseDataSessionErr:1.0
 */

static void decode_org_csapi_dsc_IpAppDataSession_superviseDataSessionErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionError"  */

        

        decode_org_csapi_dsc_TpDataSessionError_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_dsc_TpDataSessionError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSession/dataSessionFaultDetected:1.0
 */

static void decode_org_csapi_dsc_IpAppDataSession_dataSessionFaultDetected(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSessionControlManager/dataSessionAborted:1.0
 */

static void decode_org_csapi_dsc_IpAppDataSessionControlManager_dataSessionAborted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSession = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSessionControlManager/reportNotification:1.0
 */

static void decode_org_csapi_dsc_IpAppDataSessionControlManager_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_dsc_TpDataSessionIdentifier"  */

        

        decode_org_csapi_dsc_TpDataSessionIdentifier_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_dsc_TpDataSessionIdentifier"  */

        /*  Begin struct "org_csapi_dsc_TpDataSessionEventInfo"  */

        

        decode_org_csapi_dsc_TpDataSessionEventInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_dsc_TpDataSessionEventInfo"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSessionControlManager/dataSessionNotificationContinued:1.0
 */

static void decode_org_csapi_dsc_IpAppDataSessionControlManager_dataSessionNotificationContinued(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSessionControlManager/dataSessionNotificationInterrupted:1.0
 */

static void decode_org_csapi_dsc_IpAppDataSessionControlManager_dataSessionNotificationInterrupted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSessionControlManager/abortMultipleDataSessions:1.0
 */

static void decode_org_csapi_dsc_IpAppDataSessionControlManager_abortMultipleDataSessions(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_dataSessionSet;
    guint32   i_dataSessionSet;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_dataSessionSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of dataSessionSet = %u",u_octet4_loop_dataSessionSet);
        }

        for (i_dataSessionSet=0; i_dataSessionSet < u_octet4_loop_dataSessionSet; i_dataSessionSet++) {

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionSet = %i",s_octet4);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSession/connectReq:1.0
 */

static void decode_org_csapi_dsc_IpDataSession_connectReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_responseRequested;
    guint32   i_responseRequested;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",s_octet4);
        }

        u_octet4_loop_responseRequested = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of responseRequested = %u",u_octet4_loop_responseRequested);
        }

        for (i_responseRequested=0; i_responseRequested < u_octet4_loop_responseRequested; i_responseRequested++) {

            /*  Begin struct "org_csapi_dsc_TpDataSessionReportRequest"  */

            

            decode_org_csapi_dsc_TpDataSessionReportRequest_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_dsc_TpDataSessionReportRequest"  */

        }

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSession/release:1.0
 */

static void decode_org_csapi_dsc_IpDataSession_release(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionReleaseCause"  */

        

        decode_org_csapi_dsc_TpDataSessionReleaseCause_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_dsc_TpDataSessionReleaseCause"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSession/superviseDataSessionReq:1.0
 */

static void decode_org_csapi_dsc_IpDataSession_superviseDataSessionReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"treatment = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionSuperviseVolume"  */

        

        decode_org_csapi_dsc_TpDataSessionSuperviseVolume_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_dsc_TpDataSessionSuperviseVolume"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSession/setDataSessionChargePlan:1.0
 */

static void decode_org_csapi_dsc_IpDataSession_setDataSessionChargePlan(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionChargePlan"  */

        

        decode_org_csapi_dsc_TpDataSessionChargePlan_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_dsc_TpDataSessionChargePlan"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSession/setAdviceOfCharge:1.0
 */

static void decode_org_csapi_dsc_IpDataSession_setAdviceOfCharge(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_TpAoCInfo"  */

        

        decode_org_csapi_TpAoCInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAoCInfo"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"tariffSwitch = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSession/deassignDataSession:1.0
 */

static void decode_org_csapi_dsc_IpDataSession_deassignDataSession(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSession/continueProcessing:1.0
 */

static void decode_org_csapi_dsc_IpDataSession_continueProcessing(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSessionControlManager/createNotification:1.0
 */

static void decode_org_csapi_dsc_IpDataSessionControlManager_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

        

        decode_org_csapi_dsc_TpDataSessionEventCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSessionControlManager/destroyNotification:1.0
 */

static void decode_org_csapi_dsc_IpDataSessionControlManager_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSessionControlManager/changeNotification:1.0
 */

static void decode_org_csapi_dsc_IpDataSessionControlManager_changeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

        

        decode_org_csapi_dsc_TpDataSessionEventCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSessionControlManager/enableNotifications:1.0
 */

static void decode_org_csapi_dsc_IpDataSessionControlManager_enableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSessionControlManager/disableNotifications:1.0
 */

static void decode_org_csapi_dsc_IpDataSessionControlManager_disableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSessionControlManager/getNotifications:1.0
 */

static void decode_org_csapi_dsc_IpDataSessionControlManager_getNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpDataSessionEventCriteriaResultSet;
    guint32   i_TpDataSessionEventCriteriaResultSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpDataSessionEventCriteriaResultSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpDataSessionEventCriteriaResultSet = %u",u_octet4_loop_TpDataSessionEventCriteriaResultSet);
            }

            for (i_TpDataSessionEventCriteriaResultSet=0; i_TpDataSessionEventCriteriaResultSet < u_octet4_loop_TpDataSessionEventCriteriaResultSet; i_TpDataSessionEventCriteriaResultSet++) {

                /*  Begin struct "org_csapi_dsc_TpDataSessionEventCriteriaResult"  */

                

                decode_org_csapi_dsc_TpDataSessionEventCriteriaResult_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_dsc_TpDataSessionEventCriteriaResult"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSessionControlManager/createNotifications:1.0
 */

static void decode_org_csapi_dsc_IpDataSessionControlManager_createNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

        

        decode_org_csapi_dsc_TpDataSessionEventCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessagingManager/openMailbox:1.0
 */

static void decode_org_csapi_gms_IpMessagingManager_openMailbox(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"authenticationInfo (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_gms_TpMailboxIdentifier"  */

            

            decode_org_csapi_gms_TpMailboxIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_gms_TpMailboxIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessagingManager/enableMessagingNotification:1.0
 */

static void decode_org_csapi_gms_IpMessagingManager_enableMessagingNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin union "org_csapi_gms_TpMessagingEventCriteria"  */

        
        decode_org_csapi_gms_TpMessagingEventCriteria_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_gms_TpMessagingEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessagingManager/disableMessagingNotification:1.0
 */

static void decode_org_csapi_gms_IpMessagingManager_disableMessagingNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpAppMessagingManager/mailboxTerminated:1.0
 */

static void decode_org_csapi_gms_IpAppMessagingManager_mailboxTerminated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpAppMessagingManager/mailboxFaultDetected:1.0
 */

static void decode_org_csapi_gms_IpAppMessagingManager_mailboxFaultDetected(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMessagingFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpAppMessagingManager/messagingEventNotify:1.0
 */

static void decode_org_csapi_gms_IpAppMessagingManager_messagingEventNotify(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin union "org_csapi_gms_TpMessagingEventInfo"  */

        
        decode_org_csapi_gms_TpMessagingEventInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_gms_TpMessagingEventInfo"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpAppMessagingManager/messagingNotificationTerminated:1.0
 */

static void decode_org_csapi_gms_IpAppMessagingManager_messagingNotificationTerminated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/close:1.0
 */

static void decode_org_csapi_gms_IpMailbox_close(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/lock:1.0
 */

static void decode_org_csapi_gms_IpMailbox_lock(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/unlock:1.0
 */

static void decode_org_csapi_gms_IpMailbox_unlock(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/getInfoAmount:1.0
 */

static void decode_org_csapi_gms_IpMailbox_getInfoAmount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/getInfoProperties:1.0
 */

static void decode_org_csapi_gms_IpMailbox_getInfoProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_TpMailboxInfoPropertySet;
    guint32   i_TpMailboxInfoPropertySet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"firstProperty = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"numberOfProperties = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpMailboxInfoPropertySet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMailboxInfoPropertySet = %u",u_octet4_loop_TpMailboxInfoPropertySet);
            }

            for (i_TpMailboxInfoPropertySet=0; i_TpMailboxInfoPropertySet < u_octet4_loop_TpMailboxInfoPropertySet; i_TpMailboxInfoPropertySet++) {

                /*  Begin union "org_csapi_gms_TpMailboxInfoProperty"  */

                
                decode_org_csapi_gms_TpMailboxInfoProperty_un(tvb, pinfo, tree, offset, header, operation);

                /*  End union "org_csapi_gms_TpMailboxInfoProperty"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/setInfoProperties:1.0
 */

static void decode_org_csapi_gms_IpMailbox_setInfoProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_mailboxInfoProperties;
    guint32   i_mailboxInfoProperties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"firstProperty = %i",s_octet4);
        }

        u_octet4_loop_mailboxInfoProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of mailboxInfoProperties = %u",u_octet4_loop_mailboxInfoProperties);
        }

        for (i_mailboxInfoProperties=0; i_mailboxInfoProperties < u_octet4_loop_mailboxInfoProperties; i_mailboxInfoProperties++) {

            /*  Begin union "org_csapi_gms_TpMailboxInfoProperty"  */

            
            decode_org_csapi_gms_TpMailboxInfoProperty_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_gms_TpMailboxInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/openFolder:1.0
 */

static void decode_org_csapi_gms_IpMailbox_openFolder(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_gms_TpMailboxFolderIdentifier"  */

            

            decode_org_csapi_gms_TpMailboxFolderIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_gms_TpMailboxFolderIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/createFolder:1.0
 */

static void decode_org_csapi_gms_IpMailbox_createFolder(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/remove:1.0
 */

static void decode_org_csapi_gms_IpMailbox_remove(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"authenticationInfo (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessage/getInfoAmount:1.0
 */

static void decode_org_csapi_gms_IpMessage_getInfoAmount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessage/getInfoProperties:1.0
 */

static void decode_org_csapi_gms_IpMessage_getInfoProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpMessageInfoPropertySet;
    guint32   i_TpMessageInfoPropertySet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"firstProperty = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"numberOfProperties = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpMessageInfoPropertySet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMessageInfoPropertySet = %u",u_octet4_loop_TpMessageInfoPropertySet);
            }

            for (i_TpMessageInfoPropertySet=0; i_TpMessageInfoPropertySet < u_octet4_loop_TpMessageInfoPropertySet; i_TpMessageInfoPropertySet++) {

                /*  Begin union "org_csapi_gms_TpMessageInfoProperty"  */

                
                decode_org_csapi_gms_TpMessageInfoProperty_un(tvb, pinfo, tree, offset, header, operation);

                /*  End union "org_csapi_gms_TpMessageInfoProperty"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessage/setInfoProperties:1.0
 */

static void decode_org_csapi_gms_IpMessage_setInfoProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_messageInfoProperties;
    guint32   i_messageInfoProperties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"firstProperty = %i",s_octet4);
        }

        u_octet4_loop_messageInfoProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of messageInfoProperties = %u",u_octet4_loop_messageInfoProperties);
        }

        for (i_messageInfoProperties=0; i_messageInfoProperties < u_octet4_loop_messageInfoProperties; i_messageInfoProperties++) {

            /*  Begin union "org_csapi_gms_TpMessageInfoProperty"  */

            
            decode_org_csapi_gms_TpMessageInfoProperty_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_gms_TpMessageInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessage/remove:1.0
 */

static void decode_org_csapi_gms_IpMessage_remove(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessage/getContent:1.0
 */

static void decode_org_csapi_gms_IpMessage_getContent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpMessage (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailboxFolder/getInfoAmount:1.0
 */

static void decode_org_csapi_gms_IpMailboxFolder_getInfoAmount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailboxFolder/getInfoProperties:1.0
 */

static void decode_org_csapi_gms_IpMailboxFolder_getInfoProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_TpFolderInfoPropertySet;
    guint32   i_TpFolderInfoPropertySet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"firstProperty = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"numberOfProperties = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpFolderInfoPropertySet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpFolderInfoPropertySet = %u",u_octet4_loop_TpFolderInfoPropertySet);
            }

            for (i_TpFolderInfoPropertySet=0; i_TpFolderInfoPropertySet < u_octet4_loop_TpFolderInfoPropertySet; i_TpFolderInfoPropertySet++) {

                /*  Begin union "org_csapi_gms_TpFolderInfoProperty"  */

                
                decode_org_csapi_gms_TpFolderInfoProperty_un(tvb, pinfo, tree, offset, header, operation);

                /*  End union "org_csapi_gms_TpFolderInfoProperty"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailboxFolder/setInfoProperties:1.0
 */

static void decode_org_csapi_gms_IpMailboxFolder_setInfoProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_folderInfoProperties;
    guint32   i_folderInfoProperties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"firstProperty = %i",s_octet4);
        }

        u_octet4_loop_folderInfoProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of folderInfoProperties = %u",u_octet4_loop_folderInfoProperties);
        }

        for (i_folderInfoProperties=0; i_folderInfoProperties < u_octet4_loop_folderInfoProperties; i_folderInfoProperties++) {

            /*  Begin union "org_csapi_gms_TpFolderInfoProperty"  */

            
            decode_org_csapi_gms_TpFolderInfoProperty_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_gms_TpFolderInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailboxFolder/putMessage:1.0
 */

static void decode_org_csapi_gms_IpMailboxFolder_putMessage(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_messageInfoProperties;
    guint32   i_messageInfoProperties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"message (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_messageInfoProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of messageInfoProperties = %u",u_octet4_loop_messageInfoProperties);
        }

        for (i_messageInfoProperties=0; i_messageInfoProperties < u_octet4_loop_messageInfoProperties; i_messageInfoProperties++) {

            /*  Begin union "org_csapi_gms_TpMessageInfoProperty"  */

            
            decode_org_csapi_gms_TpMessageInfoProperty_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_gms_TpMessageInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailboxFolder/getMessage:1.0
 */

static void decode_org_csapi_gms_IpMailboxFolder_getMessage(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailboxFolder/close:1.0
 */

static void decode_org_csapi_gms_IpMailboxFolder_close(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailboxFolder/remove:1.0
 */

static void decode_org_csapi_gms_IpMailboxFolder_remove(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrP/getVPrPID:1.0
 */

static void decode_org_csapi_cm_IpVPrP_getVPrPID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpString (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrP/getSlaID:1.0
 */

static void decode_org_csapi_cm_IpVPrP_getSlaID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpString (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrP/getStatus:1.0
 */

static void decode_org_csapi_cm_IpVPrP_getStatus(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            
            u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpVprpStatus,"Unknown Enum Value"));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrP/getProvisionedQoSInfo:1.0
 */

static void decode_org_csapi_cm_IpVPrP_getProvisionedQoSInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpProvisionedQoSInfo"  */

            

            decode_org_csapi_cm_TpProvisionedQoSInfo_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cm_TpProvisionedQoSInfo"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrP/getValidityInfo:1.0
 */

static void decode_org_csapi_cm_IpVPrP_getValidityInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpValidityInfo"  */

            

            decode_org_csapi_cm_TpValidityInfo_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cm_TpValidityInfo"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrP/getPipeQoSInfo:1.0
 */

static void decode_org_csapi_cm_IpVPrP_getPipeQoSInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpPipeQoSInfo"  */

            

            decode_org_csapi_cm_TpPipeQoSInfo_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cm_TpPipeQoSInfo"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrP/getDsCodepoint:1.0
 */

static void decode_org_csapi_cm_IpVPrP_getDsCodepoint(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpDsCodepoint"  */

            

            decode_org_csapi_cm_TpDsCodepoint_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cm_TpDsCodepoint"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrN/getVPrPList:1.0
 */

static void decode_org_csapi_cm_IpVPrN_getVPrPList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrN/getVPrP:1.0
 */

static void decode_org_csapi_cm_IpVPrN_getVPrP(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"vPrPID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrN/createVPrP:1.0
 */

static void decode_org_csapi_cm_IpVPrN_createVPrP(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrN/deleteVPrP:1.0
 */

static void decode_org_csapi_cm_IpVPrN_deleteVPrP(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"vPrPID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSMenu/getTemplate:1.0
 */

static void decode_org_csapi_cm_IpQoSMenu_getTemplate(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"templateType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSMenu/getTemplateList:1.0
 */

static void decode_org_csapi_cm_IpQoSMenu_getTemplateList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpConnectivityManager/getQoSMenu:1.0
 */

static void decode_org_csapi_cm_IpConnectivityManager_getQoSMenu(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpConnectivityManager/getEnterpriseNetwork:1.0
 */

static void decode_org_csapi_cm_IpConnectivityManager_getEnterpriseNetwork(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/getTemplateType:1.0
 */

static void decode_org_csapi_cm_IpQoSTemplate_getTemplateType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpString (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/getDescription:1.0
 */

static void decode_org_csapi_cm_IpQoSTemplate_getDescription(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpString (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/setSlaID:1.0
 */

static void decode_org_csapi_cm_IpQoSTemplate_setSlaID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"slaID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/getPipeQoSInfo:1.0
 */

static void decode_org_csapi_cm_IpQoSTemplate_getPipeQoSInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpPipeQoSInfo"  */

            

            decode_org_csapi_cm_TpPipeQoSInfo_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cm_TpPipeQoSInfo"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/setPipeQoSInfo:1.0
 */

static void decode_org_csapi_cm_IpQoSTemplate_setPipeQoSInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cm_TpPipeQoSInfo"  */

        

        decode_org_csapi_cm_TpPipeQoSInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cm_TpPipeQoSInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/getValidityInfo:1.0
 */

static void decode_org_csapi_cm_IpQoSTemplate_getValidityInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpValidityInfo"  */

            

            decode_org_csapi_cm_TpValidityInfo_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cm_TpValidityInfo"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/setValidityInfo:1.0
 */

static void decode_org_csapi_cm_IpQoSTemplate_setValidityInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cm_TpValidityInfo"  */

        

        decode_org_csapi_cm_TpValidityInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cm_TpValidityInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/setProvisionedQoSInfo:1.0
 */

static void decode_org_csapi_cm_IpQoSTemplate_setProvisionedQoSInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cm_TpProvisionedQoSInfo"  */

        

        decode_org_csapi_cm_TpProvisionedQoSInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cm_TpProvisionedQoSInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/getProvisionedQoSInfo:1.0
 */

static void decode_org_csapi_cm_IpQoSTemplate_getProvisionedQoSInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpProvisionedQoSInfo"  */

            

            decode_org_csapi_cm_TpProvisionedQoSInfo_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cm_TpProvisionedQoSInfo"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/getDsCodepoint:1.0
 */

static void decode_org_csapi_cm_IpQoSTemplate_getDsCodepoint(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpDsCodepoint"  */

            

            decode_org_csapi_cm_TpDsCodepoint_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cm_TpDsCodepoint"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetwork/getSiteList:1.0
 */

static void decode_org_csapi_cm_IpEnterpriseNetwork_getSiteList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetwork/getVPrN:1.0
 */

static void decode_org_csapi_cm_IpEnterpriseNetwork_getVPrN(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetwork/getSite:1.0
 */

static void decode_org_csapi_cm_IpEnterpriseNetwork_getSite(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"siteID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetworkSite/getSAPList:1.0
 */

static void decode_org_csapi_cm_IpEnterpriseNetworkSite_getSAPList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetworkSite/getSiteID:1.0
 */

static void decode_org_csapi_cm_IpEnterpriseNetworkSite_getSiteID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpString (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetworkSite/getSiteLocation:1.0
 */

static void decode_org_csapi_cm_IpEnterpriseNetworkSite_getSiteLocation(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpString (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetworkSite/getSiteDescription:1.0
 */

static void decode_org_csapi_cm_IpEnterpriseNetworkSite_getSiteDescription(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpString (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetworkSite/getIPSubnet:1.0
 */

static void decode_org_csapi_cm_IpEnterpriseNetworkSite_getIPSubnet(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpIPSubnet"  */

            

            decode_org_csapi_cm_TpIPSubnet_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cm_TpIPSubnet"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetworkSite/getSAPIPSubnet:1.0
 */

static void decode_org_csapi_cm_IpEnterpriseNetworkSite_getSAPIPSubnet(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"sapID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpIPSubnet"  */

            

            decode_org_csapi_cm_TpIPSubnet_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cm_TpIPSubnet"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/reportNotification:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_am_TpChargingEventInfo"  */

        

        decode_org_csapi_am_TpChargingEventInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_am_TpChargingEventInfo"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryBalanceRes:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_queryBalanceRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_balances;
    guint32   i_balances;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",s_octet4);
        }

        u_octet4_loop_balances = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of balances = %u",u_octet4_loop_balances);
        }

        for (i_balances=0; i_balances < u_octet4_loop_balances; i_balances++) {

            /*  Begin struct "org_csapi_am_TpBalance"  */

            

            decode_org_csapi_am_TpBalance_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_am_TpBalance"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryBalanceErr:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_queryBalanceErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpBalanceQueryError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/retrieveTransactionHistoryRes:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_retrieveTransactionHistoryRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_transactionHistory;
    guint32   i_transactionHistory;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"retrievalID = %i",s_octet4);
        }

        u_octet4_loop_transactionHistory = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of transactionHistory = %u",u_octet4_loop_transactionHistory);
        }

        for (i_transactionHistory=0; i_transactionHistory < u_octet4_loop_transactionHistory; i_transactionHistory++) {

            /*  Begin struct "org_csapi_am_TpTransactionHistory"  */

            

            decode_org_csapi_am_TpTransactionHistory_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_am_TpTransactionHistory"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/retrieveTransactionHistoryErr:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_retrieveTransactionHistoryErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"retrievalID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpTransactionHistoryStatus,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryBalanceExpiryDateRes:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_queryBalanceExpiryDateRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_dates;
    guint32   i_dates;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",s_octet4);
        }

        u_octet4_loop_dates = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of dates = %u",u_octet4_loop_dates);
        }

        for (i_dates=0; i_dates < u_octet4_loop_dates; i_dates++) {

            /*  Begin struct "org_csapi_am_TpBalanceExpiryDate"  */

            

            decode_org_csapi_am_TpBalanceExpiryDate_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_am_TpBalanceExpiryDate"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryBalanceExpiryDateErr:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_queryBalanceExpiryDateErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpBalanceQueryError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/updateBalanceRes:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_updateBalanceRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestId = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_am_TpBalance"  */

        

        decode_org_csapi_am_TpBalance_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_am_TpBalance"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/updateBalanceErr:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_updateBalanceErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpBalanceQueryError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/createVoucherRes:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_createVoucherRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestId = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"voucherId = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/createVoucherErr:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_createVoucherErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpVoucherError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/destroyVoucherRes:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_destroyVoucherRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestId = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"voucherId = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/destroyVoucherErr:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_destroyVoucherErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestId = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"voucherId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpVoucherError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryVoucherRes:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_queryVoucherRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_am_TpVoucher"  */

        

        decode_org_csapi_am_TpVoucher_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_am_TpVoucher"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryVoucherErr:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_queryVoucherErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"voucherId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpVoucherError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryUserVouchersRes:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_queryUserVouchersRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_vouchers;
    guint32   i_vouchers;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",s_octet4);
        }

        u_octet4_loop_vouchers = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of vouchers = %u",u_octet4_loop_vouchers);
        }

        for (i_vouchers=0; i_vouchers < u_octet4_loop_vouchers; i_vouchers++) {

            /*  Begin struct "org_csapi_am_TpVoucher"  */

            

            decode_org_csapi_am_TpVoucher_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_am_TpVoucher"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryUserVouchersErr:1.0
 */

static void decode_org_csapi_am_IpAppAccountManager_queryUserVouchersErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpVoucherError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/createNotification:1.0
 */

static void decode_org_csapi_am_IpAccountManager_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_am_TpChargingEventCriteria"  */

        

        decode_org_csapi_am_TpChargingEventCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_am_TpChargingEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/destroyNotification:1.0
 */

static void decode_org_csapi_am_IpAccountManager_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/queryBalanceReq:1.0
 */

static void decode_org_csapi_am_IpAccountManager_queryBalanceReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/changeNotification:1.0
 */

static void decode_org_csapi_am_IpAccountManager_changeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_am_TpChargingEventCriteria"  */

        

        decode_org_csapi_am_TpChargingEventCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_am_TpChargingEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/getNotification:1.0
 */

static void decode_org_csapi_am_IpAccountManager_getNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpChargingEventCriteriaResultSet;
    guint32   i_TpChargingEventCriteriaResultSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpChargingEventCriteriaResultSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpChargingEventCriteriaResultSet = %u",u_octet4_loop_TpChargingEventCriteriaResultSet);
            }

            for (i_TpChargingEventCriteriaResultSet=0; i_TpChargingEventCriteriaResultSet < u_octet4_loop_TpChargingEventCriteriaResultSet; i_TpChargingEventCriteriaResultSet++) {

                /*  Begin struct "org_csapi_am_TpChargingEventCriteriaResult"  */

                

                decode_org_csapi_am_TpChargingEventCriteriaResult_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_am_TpChargingEventCriteriaResult"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/retrieveTransactionHistoryReq:1.0
 */

static void decode_org_csapi_am_IpAccountManager_retrieveTransactionHistoryReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/enableNotifications:1.0
 */

static void decode_org_csapi_am_IpAccountManager_enableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/disableNotifications:1.0
 */

static void decode_org_csapi_am_IpAccountManager_disableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/queryBalanceExpiryDateReq:1.0
 */

static void decode_org_csapi_am_IpAccountManager_queryBalanceExpiryDateReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/updateBalanceReq:1.0
 */

static void decode_org_csapi_am_IpAccountManager_updateBalanceReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"debit = %u",u_octet1);
        }

        /*  Begin struct "org_csapi_am_TpBalanceInfo"  */

        

        decode_org_csapi_am_TpBalanceInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_am_TpBalanceInfo"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"period = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/createVoucherReq:1.0
 */

static void decode_org_csapi_am_IpAccountManager_createVoucherReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_am_TpBalanceInfo"  */

        

        decode_org_csapi_am_TpBalanceInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_am_TpBalanceInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/destroyVoucherReq:1.0
 */

static void decode_org_csapi_am_IpAccountManager_destroyVoucherReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"voucherId = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/queryVoucherReq:1.0
 */

static void decode_org_csapi_am_IpAccountManager_queryVoucherReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"voucherId = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/queryUserVouchersReq:1.0
 */

static void decode_org_csapi_am_IpAccountManager_queryUserVouchersReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/creditAmountErr:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_creditAmountErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/creditAmountRes:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_creditAmountRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/creditUnitErr:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_creditUnitErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/creditUnitRes:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_creditUnitRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_creditedVolumes;
    guint32   i_creditedVolumes;
    guint32   u_octet4_loop_reservedUnitsLeft;
    guint32   i_reservedUnitsLeft;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        u_octet4_loop_creditedVolumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of creditedVolumes = %u",u_octet4_loop_creditedVolumes);
        }

        for (i_creditedVolumes=0; i_creditedVolumes < u_octet4_loop_creditedVolumes; i_creditedVolumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        u_octet4_loop_reservedUnitsLeft = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of reservedUnitsLeft = %u",u_octet4_loop_reservedUnitsLeft);
        }

        for (i_reservedUnitsLeft=0; i_reservedUnitsLeft < u_octet4_loop_reservedUnitsLeft; i_reservedUnitsLeft++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/debitAmountErr:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_debitAmountErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/debitAmountRes:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_debitAmountRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/debitUnitErr:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_debitUnitErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/debitUnitRes:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_debitUnitRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_debitedVolumes;
    guint32   i_debitedVolumes;
    guint32   u_octet4_loop_reservedUnitsLeft;
    guint32   i_reservedUnitsLeft;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        u_octet4_loop_debitedVolumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of debitedVolumes = %u",u_octet4_loop_debitedVolumes);
        }

        for (i_debitedVolumes=0; i_debitedVolumes < u_octet4_loop_debitedVolumes; i_debitedVolumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        u_octet4_loop_reservedUnitsLeft = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of reservedUnitsLeft = %u",u_octet4_loop_reservedUnitsLeft);
        }

        for (i_reservedUnitsLeft=0; i_reservedUnitsLeft < u_octet4_loop_reservedUnitsLeft; i_reservedUnitsLeft++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directCreditAmountErr:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_directCreditAmountErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directCreditAmountRes:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_directCreditAmountRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directCreditUnitErr:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_directCreditUnitErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directCreditUnitRes:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_directCreditUnitRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_creditedVolumes;
    guint32   i_creditedVolumes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        u_octet4_loop_creditedVolumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of creditedVolumes = %u",u_octet4_loop_creditedVolumes);
        }

        for (i_creditedVolumes=0; i_creditedVolumes < u_octet4_loop_creditedVolumes; i_creditedVolumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directDebitAmountErr:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_directDebitAmountErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directDebitAmountRes:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_directDebitAmountRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directDebitUnitErr:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_directDebitUnitErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directDebitUnitRes:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_directDebitUnitRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_debitedVolumes;
    guint32   i_debitedVolumes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        u_octet4_loop_debitedVolumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of debitedVolumes = %u",u_octet4_loop_debitedVolumes);
        }

        for (i_debitedVolumes=0; i_debitedVolumes < u_octet4_loop_debitedVolumes; i_debitedVolumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/extendLifeTimeErr:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_extendLifeTimeErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/extendLifeTimeRes:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_extendLifeTimeRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionTimeLeft = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/rateErr:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_rateErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/rateRes:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_rateRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_rates;
    guint32   i_rates;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        u_octet4_loop_rates = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of rates = %u",u_octet4_loop_rates);
        }

        for (i_rates=0; i_rates < u_octet4_loop_rates; i_rates++) {

            /*  Begin struct "org_csapi_cs_TpPriceVolume"  */

            

            decode_org_csapi_cs_TpPriceVolume_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpPriceVolume"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"validityTimeLeft = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/reserveAmountErr:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_reserveAmountErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/reserveAmountRes:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_reserveAmountRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionTimeLeft = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/reserveUnitErr:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_reserveUnitErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/reserveUnitRes:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_reserveUnitRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_reservedUnits;
    guint32   i_reservedUnits;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        u_octet4_loop_reservedUnits = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of reservedUnits = %u",u_octet4_loop_reservedUnits);
        }

        for (i_reservedUnits=0; i_reservedUnits < u_octet4_loop_reservedUnits; i_reservedUnits++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionTimeLeft = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/sessionEnded:1.0
 */

static void decode_org_csapi_cs_IpAppChargingSession_sessionEnded(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpSessionEndedCause,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/creditAmountReq:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_creditAmountReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"closeReservation = %u",u_octet1);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/creditUnitReq:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_creditUnitReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_volumes;
    guint32   i_volumes;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_volumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of volumes = %u",u_octet4_loop_volumes);
        }

        for (i_volumes=0; i_volumes < u_octet4_loop_volumes; i_volumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"closeReservation = %u",u_octet1);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/debitAmountReq:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_debitAmountReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"closeReservation = %u",u_octet1);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/debitUnitReq:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_debitUnitReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_volumes;
    guint32   i_volumes;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_volumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of volumes = %u",u_octet4_loop_volumes);
        }

        for (i_volumes=0; i_volumes < u_octet4_loop_volumes; i_volumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"closeReservation = %u",u_octet1);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/directCreditAmountReq:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_directCreditAmountReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_chargingParameters;
    guint32   i_chargingParameters;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_chargingParameters = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingParameters = %u",u_octet4_loop_chargingParameters);
        }

        for (i_chargingParameters=0; i_chargingParameters < u_octet4_loop_chargingParameters; i_chargingParameters++) {

            /*  Begin struct "org_csapi_cs_TpChargingParameter"  */

            

            decode_org_csapi_cs_TpChargingParameter_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpChargingParameter"  */

        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/directCreditUnitReq:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_directCreditUnitReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_chargingParameters;
    guint32   i_chargingParameters;
    guint32   u_octet4_loop_volumes;
    guint32   i_volumes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_chargingParameters = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingParameters = %u",u_octet4_loop_chargingParameters);
        }

        for (i_chargingParameters=0; i_chargingParameters < u_octet4_loop_chargingParameters; i_chargingParameters++) {

            /*  Begin struct "org_csapi_cs_TpChargingParameter"  */

            

            decode_org_csapi_cs_TpChargingParameter_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpChargingParameter"  */

        }

        u_octet4_loop_volumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of volumes = %u",u_octet4_loop_volumes);
        }

        for (i_volumes=0; i_volumes < u_octet4_loop_volumes; i_volumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/directDebitAmountReq:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_directDebitAmountReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_chargingParameters;
    guint32   i_chargingParameters;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_chargingParameters = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingParameters = %u",u_octet4_loop_chargingParameters);
        }

        for (i_chargingParameters=0; i_chargingParameters < u_octet4_loop_chargingParameters; i_chargingParameters++) {

            /*  Begin struct "org_csapi_cs_TpChargingParameter"  */

            

            decode_org_csapi_cs_TpChargingParameter_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpChargingParameter"  */

        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/directDebitUnitReq:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_directDebitUnitReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_chargingParameters;
    guint32   i_chargingParameters;
    guint32   u_octet4_loop_volumes;
    guint32   i_volumes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_chargingParameters = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingParameters = %u",u_octet4_loop_chargingParameters);
        }

        for (i_chargingParameters=0; i_chargingParameters < u_octet4_loop_chargingParameters; i_chargingParameters++) {

            /*  Begin struct "org_csapi_cs_TpChargingParameter"  */

            

            decode_org_csapi_cs_TpChargingParameter_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpChargingParameter"  */

        }

        u_octet4_loop_volumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of volumes = %u",u_octet4_loop_volumes);
        }

        for (i_volumes=0; i_volumes < u_octet4_loop_volumes; i_volumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/extendLifeTimeReq:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_extendLifeTimeReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/getAmountLeft:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_getAmountLeft(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

            

            decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpChargingPrice"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/getLifeTimeLeft:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_getLifeTimeLeft(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/getUnitLeft:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_getUnitLeft(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_TpVolumeSet;
    guint32   i_TpVolumeSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpVolumeSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpVolumeSet = %u",u_octet4_loop_TpVolumeSet);
            }

            for (i_TpVolumeSet=0; i_TpVolumeSet < u_octet4_loop_TpVolumeSet; i_TpVolumeSet++) {

                /*  Begin struct "org_csapi_cs_TpVolume"  */

                

                decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_cs_TpVolume"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/rateReq:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_rateReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_chargingParameters;
    guint32   i_chargingParameters;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        u_octet4_loop_chargingParameters = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingParameters = %u",u_octet4_loop_chargingParameters);
        }

        for (i_chargingParameters=0; i_chargingParameters < u_octet4_loop_chargingParameters; i_chargingParameters++) {

            /*  Begin struct "org_csapi_cs_TpChargingParameter"  */

            

            decode_org_csapi_cs_TpChargingParameter_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpChargingParameter"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/release:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_release(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/reserveAmountReq:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_reserveAmountReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_chargingParameters;
    guint32   i_chargingParameters;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_chargingParameters = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingParameters = %u",u_octet4_loop_chargingParameters);
        }

        for (i_chargingParameters=0; i_chargingParameters < u_octet4_loop_chargingParameters; i_chargingParameters++) {

            /*  Begin struct "org_csapi_cs_TpChargingParameter"  */

            

            decode_org_csapi_cs_TpChargingParameter_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpChargingParameter"  */

        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/reserveUnitReq:1.0
 */

static void decode_org_csapi_cs_IpChargingSession_reserveUnitReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_chargingParameters;
    guint32   i_chargingParameters;
    guint32   u_octet4_loop_volumes;
    guint32   i_volumes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_chargingParameters = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingParameters = %u",u_octet4_loop_chargingParameters);
        }

        for (i_chargingParameters=0; i_chargingParameters < u_octet4_loop_chargingParameters; i_chargingParameters++) {

            /*  Begin struct "org_csapi_cs_TpChargingParameter"  */

            

            decode_org_csapi_cs_TpChargingParameter_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpChargingParameter"  */

        }

        u_octet4_loop_volumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of volumes = %u",u_octet4_loop_volumes);
        }

        for (i_volumes=0; i_volumes < u_octet4_loop_volumes; i_volumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingManager/sessionAborted:1.0
 */

static void decode_org_csapi_cs_IpAppChargingManager_sessionAborted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingManager/abortMultipleChargingSessions:1.0
 */

static void decode_org_csapi_cs_IpAppChargingManager_abortMultipleChargingSessions(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_chargingSessionSet;
    guint32   i_chargingSessionSet;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_chargingSessionSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingSessionSet = %u",u_octet4_loop_chargingSessionSet);
        }

        for (i_chargingSessionSet=0; i_chargingSessionSet < u_octet4_loop_chargingSessionSet; i_chargingSessionSet++) {

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"chargingSessionSet = %i",s_octet4);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingManager/createChargingSession:1.0
 */

static void decode_org_csapi_cs_IpChargingManager_createChargingSession(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"sessionDescription (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        /*  Begin struct "org_csapi_cs_TpMerchantAccountID"  */

        

        decode_org_csapi_cs_TpMerchantAccountID_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpMerchantAccountID"  */

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_cs_TpCorrelationID"  */

        

        decode_org_csapi_cs_TpCorrelationID_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpCorrelationID"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cs_TpChargingSessionID"  */

            

            decode_org_csapi_cs_TpChargingSessionID_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpChargingSessionID"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingManager/createSplitChargingSession:1.0
 */

static void decode_org_csapi_cs_IpChargingManager_createSplitChargingSession(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_users;
    guint32   i_users;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"sessionDescription (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        /*  Begin struct "org_csapi_cs_TpMerchantAccountID"  */

        

        decode_org_csapi_cs_TpMerchantAccountID_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpMerchantAccountID"  */

        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        /*  Begin struct "org_csapi_cs_TpCorrelationID"  */

        

        decode_org_csapi_cs_TpCorrelationID_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cs_TpCorrelationID"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cs_TpChargingSessionID"  */

            

            decode_org_csapi_cs_TpChargingSessionID_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cs_TpChargingSessionID"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpAppPolicyDomain/reportNotification:1.0
 */

static void decode_org_csapi_policy_evaluation_IpAppPolicyDomain_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_policy_TpPolicyEvent"  */

        

        decode_org_csapi_policy_TpPolicyEvent_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_policy_TpPolicyEvent"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpAppPolicyDomain/evalPolicyRes:1.0
 */

static void decode_org_csapi_policy_evaluation_IpAppPolicyDomain_evalPolicyRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_outputVariables;
    guint32   i_outputVariables;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        u_octet4_loop_outputVariables = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of outputVariables = %u",u_octet4_loop_outputVariables);
        }

        for (i_outputVariables=0; i_outputVariables < u_octet4_loop_outputVariables; i_outputVariables++) {

            /*  Begin struct "org_csapi_policy_TpPolicyNameValue"  */

            

            decode_org_csapi_policy_TpPolicyNameValue_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_policy_TpPolicyNameValue"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpAppPolicyDomain/evalPolicyErr:1.0
 */

static void decode_org_csapi_policy_evaluation_IpAppPolicyDomain_evalPolicyErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpPolicyEvalManager/evalPolicy:1.0
 */

static void decode_org_csapi_policy_evaluation_IpPolicyEvalManager_evalPolicy(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_inputVariables;
    guint32   i_inputVariables;
    guint32   u_octet4_loop_TpPolicyNameValueList;
    guint32   i_TpPolicyNameValueList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"domainName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"signatureName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_inputVariables = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of inputVariables = %u",u_octet4_loop_inputVariables);
        }

        for (i_inputVariables=0; i_inputVariables < u_octet4_loop_inputVariables; i_inputVariables++) {

            /*  Begin struct "org_csapi_policy_TpPolicyNameValue"  */

            

            decode_org_csapi_policy_TpPolicyNameValue_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_policy_TpPolicyNameValue"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPolicyNameValueList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyNameValueList = %u",u_octet4_loop_TpPolicyNameValueList);
            }

            for (i_TpPolicyNameValueList=0; i_TpPolicyNameValueList < u_octet4_loop_TpPolicyNameValueList; i_TpPolicyNameValueList++) {

                /*  Begin struct "org_csapi_policy_TpPolicyNameValue"  */

                

                decode_org_csapi_policy_TpPolicyNameValue_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_policy_TpPolicyNameValue"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpPolicyEvalManager/evalPolicyReq:1.0
 */

static void decode_org_csapi_policy_evaluation_IpPolicyEvalManager_evalPolicyReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_inputVariables;
    guint32   i_inputVariables;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"domainName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"signatureName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_inputVariables = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of inputVariables = %u",u_octet4_loop_inputVariables);
        }

        for (i_inputVariables=0; i_inputVariables < u_octet4_loop_inputVariables; i_inputVariables++) {

            /*  Begin struct "org_csapi_policy_TpPolicyNameValue"  */

            

            decode_org_csapi_policy_TpPolicyNameValue_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_policy_TpPolicyNameValue"  */

        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpPolicyEvalManager/abortEvalPolicyReq:1.0
 */

static void decode_org_csapi_policy_evaluation_IpPolicyEvalManager_abortEvalPolicyReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"domainName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpPolicyEvalManager/generateEvent:1.0
 */

static void decode_org_csapi_policy_evaluation_IpPolicyEvalManager_generateEvent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributes;
    guint32   i_attributes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"domainName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"eventDefinitionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributes = %u",u_octet4_loop_attributes);
        }

        for (i_attributes=0; i_attributes < u_octet4_loop_attributes; i_attributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpPolicyEvalManager/createNotification:1.0
 */

static void decode_org_csapi_policy_evaluation_IpPolicyEvalManager_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_events;
    guint32   i_events;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"domainName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_events = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of events = %u",u_octet4_loop_events);
        }

        for (i_events=0; i_events < u_octet4_loop_events; i_events++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"events (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpPolicyEvalManager/destroyNotification:1.0
 */

static void decode_org_csapi_policy_evaluation_IpPolicyEvalManager_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_events;
    guint32   i_events;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        u_octet4_loop_events = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of events = %u",u_octet4_loop_events);
        }

        for (i_events=0; i_events < u_octet4_loop_events; i_events++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"events (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicy/getAttribute:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicy_getAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAttribute"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicy/setAttribute:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicy_setAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpAttribute"  */

        

        decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAttribute"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicy/getAttributes:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicy_getAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpAttributeSet;
    guint32   i_TpAttributeSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpAttributeSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpAttributeSet = %u",u_octet4_loop_TpAttributeSet);
            }

            for (i_TpAttributeSet=0; i_TpAttributeSet < u_octet4_loop_TpAttributeSet; i_TpAttributeSet++) {

                /*  Begin struct "org_csapi_TpAttribute"  */

                

                decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_TpAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicy/setAttributes:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicy_setAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_targetAttributes;
    guint32   i_targetAttributes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_targetAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of targetAttributes = %u",u_octet4_loop_targetAttributes);
        }

        for (i_targetAttributes=0; i_targetAttributes < u_octet4_loop_targetAttributes; i_targetAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyIterator/getList:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyIterator_getList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_TpStringSet;
    guint32   i_TpStringSet;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"startIndex = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"numberRequested = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringSet = %u",u_octet4_loop_TpStringSet);
            }

            for (i_TpStringSet=0; i_TpStringSet < u_octet4_loop_TpStringSet; i_TpStringSet++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringSet (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getParentRepository:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_getParentRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/createRepository:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_createRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"repositoryName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getRepository:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_getRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"repositoryName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/removeRepository:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_removeRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"repositoryName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getRepositoryCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_getRepositoryCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getRepositoryIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_getRepositoryIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/createCondition:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_createCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_conditionAttributes;
    guint32   i_conditionAttributes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"conditionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_policy_TpPolicyConditionType,"Unknown Enum Value"));
        }

        u_octet4_loop_conditionAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of conditionAttributes = %u",u_octet4_loop_conditionAttributes);
        }

        for (i_conditionAttributes=0; i_conditionAttributes < u_octet4_loop_conditionAttributes; i_conditionAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getCondition:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_getCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"conditionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/removeCondition:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_removeCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"conditionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getConditionCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_getConditionCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getConditionIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_getConditionIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/createAction:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_createAction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_actionAttributes;
    guint32   i_actionAttributes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"actionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_policy_TpPolicyActionType,"Unknown Enum Value"));
        }

        u_octet4_loop_actionAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of actionAttributes = %u",u_octet4_loop_actionAttributes);
        }

        for (i_actionAttributes=0; i_actionAttributes < u_octet4_loop_actionAttributes; i_actionAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getAction:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_getAction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"actionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/removeAction:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_removeAction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"actionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getActionCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_getActionCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getActionIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRepository_getActionIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getParentGroup:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_getParentGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getParentDomain:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_getParentDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/createCondition:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_createCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_conditionAttributes;
    guint32   i_conditionAttributes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"conditionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_policy_TpPolicyConditionType,"Unknown Enum Value"));
        }

        u_octet4_loop_conditionAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of conditionAttributes = %u",u_octet4_loop_conditionAttributes);
        }

        for (i_conditionAttributes=0; i_conditionAttributes < u_octet4_loop_conditionAttributes; i_conditionAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getCondition:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_getCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"conditionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/removeCondition:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_removeCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"conditionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getConditionCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_getConditionCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getConditionIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_getConditionIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/createAction:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_createAction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_actionAttributes;
    guint32   i_actionAttributes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"actionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_policy_TpPolicyActionType,"Unknown Enum Value"));
        }

        u_octet4_loop_actionAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of actionAttributes = %u",u_octet4_loop_actionAttributes);
        }

        for (i_actionAttributes=0; i_actionAttributes < u_octet4_loop_actionAttributes; i_actionAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getAction:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_getAction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"actionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/removeAction:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_removeAction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"actionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getActionCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_getActionCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getActionIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_getActionIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/setValidityPeriodConditionByName:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_setValidityPeriodConditionByName(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"conditionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/setValidityPeriodCondition:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_setValidityPeriodCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getValidityPeriodCondition:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_getValidityPeriodCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/unsetValidityPeriodCondition:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_unsetValidityPeriodCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/setConditionList:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_setConditionList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_conditionList;
    guint32   i_conditionList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_conditionList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of conditionList = %u",u_octet4_loop_conditionList);
        }

        for (i_conditionList=0; i_conditionList < u_octet4_loop_conditionList; i_conditionList++) {

            /*  Begin struct "org_csapi_policy_TpPolicyConditionListElement"  */

            

            decode_org_csapi_policy_TpPolicyConditionListElement_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_policy_TpPolicyConditionListElement"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getConditionList:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_getConditionList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPolicyConditionList;
    guint32   i_TpPolicyConditionList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPolicyConditionList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyConditionList = %u",u_octet4_loop_TpPolicyConditionList);
            }

            for (i_TpPolicyConditionList=0; i_TpPolicyConditionList < u_octet4_loop_TpPolicyConditionList; i_TpPolicyConditionList++) {

                /*  Begin struct "org_csapi_policy_TpPolicyConditionListElement"  */

                

                decode_org_csapi_policy_TpPolicyConditionListElement_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_policy_TpPolicyConditionListElement"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/setActionList:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_setActionList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_actionList;
    guint32   i_actionList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_actionList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of actionList = %u",u_octet4_loop_actionList);
        }

        for (i_actionList=0; i_actionList < u_octet4_loop_actionList; i_actionList++) {

            /*  Begin struct "org_csapi_policy_TpPolicyActionListElement"  */

            

            decode_org_csapi_policy_TpPolicyActionListElement_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_policy_TpPolicyActionListElement"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getActionList:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyRule_getActionList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPolicyActionList;
    guint32   i_TpPolicyActionList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPolicyActionList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyActionList = %u",u_octet4_loop_TpPolicyActionList);
            }

            for (i_TpPolicyActionList=0; i_TpPolicyActionList < u_octet4_loop_TpPolicyActionList; i_TpPolicyActionList++) {

                /*  Begin struct "org_csapi_policy_TpPolicyActionListElement"  */

                

                decode_org_csapi_policy_TpPolicyActionListElement_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_policy_TpPolicyActionListElement"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/createDomain:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyManager_createDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"domainName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/getDomain:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyManager_getDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"domainName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/removeDomain:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyManager_removeDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"domainName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/getDomainCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyManager_getDomainCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/getDomainIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyManager_getDomainIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/findMatchingDomains:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyManager_findMatchingDomains(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_matchingAttributes;
    guint32   i_matchingAttributes;
    guint32   u_octet4_loop_TpStringSet;
    guint32   i_TpStringSet;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_matchingAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of matchingAttributes = %u",u_octet4_loop_matchingAttributes);
        }

        for (i_matchingAttributes=0; i_matchingAttributes < u_octet4_loop_matchingAttributes; i_matchingAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringSet = %u",u_octet4_loop_TpStringSet);
            }

            for (i_TpStringSet=0; i_TpStringSet < u_octet4_loop_TpStringSet; i_TpStringSet++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringSet (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/createRepository:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyManager_createRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"repositoryName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/getRepository:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyManager_getRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"repositoryName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/removeRepository:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyManager_removeRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"repositoryName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/getRepositoryCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyManager_getRepositoryCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/getRepositoryIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyManager_getRepositoryIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/startTransaction:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyManager_startTransaction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/commitTransaction:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyManager_commitTransaction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet1 = get_CDR_boolean(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",u_octet1);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/abortTransaction:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyManager_abortTransaction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getParentDomain:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyGroup_getParentDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getParentGroup:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyGroup_getParentGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/createGroup:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyGroup_createGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"groupName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getGroup:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyGroup_getGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"groupName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/removeGroup:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyGroup_removeGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"groupName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getGroupCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyGroup_getGroupCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getGroupIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyGroup_getGroupIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/createRule:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyGroup_createRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"ruleName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getRule:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyGroup_getRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"ruleName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/removeRule:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyGroup_removeRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"ruleName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getRuleCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyGroup_getRuleCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getRuleIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyGroup_getRuleIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyEventDefinition/setRequiredAttributes:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_setRequiredAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_requiredAttributes;
    guint32   i_requiredAttributes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_requiredAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of requiredAttributes = %u",u_octet4_loop_requiredAttributes);
        }

        for (i_requiredAttributes=0; i_requiredAttributes < u_octet4_loop_requiredAttributes; i_requiredAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyEventDefinition/setOptionalAttributes:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_setOptionalAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_optionalAttributes;
    guint32   i_optionalAttributes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_optionalAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of optionalAttributes = %u",u_octet4_loop_optionalAttributes);
        }

        for (i_optionalAttributes=0; i_optionalAttributes < u_octet4_loop_optionalAttributes; i_optionalAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyEventDefinition/getRequiredAttributes:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_getRequiredAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpAttributeSet;
    guint32   i_TpAttributeSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpAttributeSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpAttributeSet = %u",u_octet4_loop_TpAttributeSet);
            }

            for (i_TpAttributeSet=0; i_TpAttributeSet < u_octet4_loop_TpAttributeSet; i_TpAttributeSet++) {

                /*  Begin struct "org_csapi_TpAttribute"  */

                

                decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_TpAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyEventDefinition/getOptionalAttributes:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_getOptionalAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpAttributeSet;
    guint32   i_TpAttributeSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpAttributeSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpAttributeSet = %u",u_octet4_loop_TpAttributeSet);
            }

            for (i_TpAttributeSet=0; i_TpAttributeSet < u_octet4_loop_TpAttributeSet; i_TpAttributeSet++) {

                /*  Begin struct "org_csapi_TpAttribute"  */

                

                decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_TpAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyEventDefinition/getParentDomain:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_getParentDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyCondition/getParentRepository:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyCondition_getParentRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyCondition/getParentRule:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyCondition_getParentRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyAction/getParentRepository:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyAction_getParentRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyAction/getParentRule:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyAction_getParentRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/setInputVariables:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicySignature_setInputVariables(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_inputVariables;
    guint32   i_inputVariables;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_inputVariables = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of inputVariables = %u",u_octet4_loop_inputVariables);
        }

        for (i_inputVariables=0; i_inputVariables < u_octet4_loop_inputVariables; i_inputVariables++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"inputVariables (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/setOutputVariables:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicySignature_setOutputVariables(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_outputVariables;
    guint32   i_outputVariables;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_outputVariables = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of outputVariables = %u",u_octet4_loop_outputVariables);
        }

        for (i_outputVariables=0; i_outputVariables < u_octet4_loop_outputVariables; i_outputVariables++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"outputVariables (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/getInputVariables:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicySignature_getInputVariables(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringSet;
    guint32   i_TpStringSet;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringSet = %u",u_octet4_loop_TpStringSet);
            }

            for (i_TpStringSet=0; i_TpStringSet < u_octet4_loop_TpStringSet; i_TpStringSet++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringSet (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/getOutputVariables:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicySignature_getOutputVariables(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringSet;
    guint32   i_TpStringSet;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringSet = %u",u_octet4_loop_TpStringSet);
            }

            for (i_TpStringSet=0; i_TpStringSet < u_octet4_loop_TpStringSet; i_TpStringSet++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringSet (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/setGroupNames:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicySignature_setGroupNames(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_groupNames;
    guint32   i_groupNames;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_groupNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of groupNames = %u",u_octet4_loop_groupNames);
        }

        for (i_groupNames=0; i_groupNames < u_octet4_loop_groupNames; i_groupNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"groupNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/setPolicyRoles:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicySignature_setPolicyRoles(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_roleNames;
    guint32   i_roleNames;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_roleNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of roleNames = %u",u_octet4_loop_roleNames);
        }

        for (i_roleNames=0; i_roleNames < u_octet4_loop_roleNames; i_roleNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"roleNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/getGroupNames:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicySignature_getGroupNames(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringSet;
    guint32   i_TpStringSet;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringSet = %u",u_octet4_loop_TpStringSet);
            }

            for (i_TpStringSet=0; i_TpStringSet < u_octet4_loop_TpStringSet; i_TpStringSet++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringSet (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/getPolicyRoles:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicySignature_getPolicyRoles(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringSet;
    guint32   i_TpStringSet;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringSet = %u",u_octet4_loop_TpStringSet);
            }

            for (i_TpStringSet=0; i_TpStringSet < u_octet4_loop_TpStringSet; i_TpStringSet++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringSet (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/getParentDomain:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicySignature_getParentDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getParentDomain:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getParentDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/createDomain:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_createDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"domainName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getDomain:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"domainName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/removeDomain:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_removeDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"domainName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getDomainCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getDomainCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getDomainIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getDomainIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/createGroup:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_createGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"groupName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getGroup:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"groupName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/removeGroup:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_removeGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"groupName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getGroupCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getGroupCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getGroupIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getGroupIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/createRule:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_createRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"ruleName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getRule:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"ruleName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/removeRule:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_removeRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"ruleName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getRuleCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getRuleCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getRuleIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getRuleIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/createEventDefinition:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_createEventDefinition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_requiredAttributes;
    guint32   i_requiredAttributes;
    guint32   u_octet4_loop_optionalAttributes;
    guint32   i_optionalAttributes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"eventDefinitionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_requiredAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of requiredAttributes = %u",u_octet4_loop_requiredAttributes);
        }

        for (i_requiredAttributes=0; i_requiredAttributes < u_octet4_loop_requiredAttributes; i_requiredAttributes++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"requiredAttributes (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_optionalAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of optionalAttributes = %u",u_octet4_loop_optionalAttributes);
        }

        for (i_optionalAttributes=0; i_optionalAttributes < u_octet4_loop_optionalAttributes; i_optionalAttributes++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"optionalAttributes (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getEventDefinition:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"eventDefinitionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/removeEventDefinition:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_removeEventDefinition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"eventDefinitionName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getEventDefinitionCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinitionCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getEventDefinitionIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinitionIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/createVariableSet:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_createVariableSet(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variableSetName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getVariableSet:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableSet(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPolicyVarSet;
    guint32   i_TpPolicyVarSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variableSetName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPolicyVarSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyVarSet = %u",u_octet4_loop_TpPolicyVarSet);
            }

            for (i_TpPolicyVarSet=0; i_TpPolicyVarSet < u_octet4_loop_TpPolicyVarSet; i_TpPolicyVarSet++) {

                /*  Begin struct "org_csapi_policy_TpPolicyVar"  */

                

                decode_org_csapi_policy_TpPolicyVar_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_policy_TpPolicyVar"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/removeVariableSet:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_removeVariableSet(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variableSetName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getVariableSetCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableSetCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getVariableSetIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableSetIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/createVariable:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_createVariable(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variableSetName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variableName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        /*  Begin union "org_csapi_policy_TpPolicyType"  */

        
        decode_org_csapi_policy_TpPolicyType_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_policy_TpPolicyType"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/setVariableValue:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_setVariableValue(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variableSetName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variableName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        get_CDR_any(tvb,tree,offset,stream_is_big_endian, boundary, header);

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getVariableType:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variableSetName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variableName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin union "org_csapi_policy_TpPolicyType"  */

            
            decode_org_csapi_policy_TpPolicyType_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_policy_TpPolicyType"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getVariableValue:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableValue(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variableSetName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variableName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_any(tvb,tree,offset,stream_is_big_endian, boundary, header);

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getVariable:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariable(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variableSetName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variableName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_policy_TpPolicyVar"  */

            

            decode_org_csapi_policy_TpPolicyVar_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_policy_TpPolicyVar"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/removeVariable:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_removeVariable(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variablSetName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"variableName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/createSignature:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_createSignature(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"signatureName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getSignature:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getSignature(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"signatureName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/removeSignature:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_removeSignature(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"signatureName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getSignatureCount:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getSignatureCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getSignatureIterator:1.0
 */

static void decode_org_csapi_policy_provisioning_IpPolicyDomain_getSignatureIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/createIdentity:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_createIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_identityTypes;
    guint32   i_identityTypes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_identityTypes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of identityTypes = %u",u_octet4_loop_identityTypes);
        }

        for (i_identityTypes=0; i_identityTypes < u_octet4_loop_identityTypes; i_identityTypes++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identityTypes (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/deleteIdentity:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_deleteIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/isIdentity:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_isIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet1 = get_CDR_boolean(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",u_octet1);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/createGroupIdentity:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_createGroupIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_identityTypes;
    guint32   i_identityTypes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_identityTypes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of identityTypes = %u",u_octet4_loop_identityTypes);
        }

        for (i_identityTypes=0; i_identityTypes < u_octet4_loop_identityTypes; i_identityTypes++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identityTypes (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/deleteGroupIdentity:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_deleteGroupIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/addToGroup:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_addToGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"group (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"member (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/removeFromGroup:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_removeFromGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"group (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/listMembers:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listMembers(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMFQNameList;
    guint32   i_TpPAMFQNameList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMFQNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMFQNameList = %u",u_octet4_loop_TpPAMFQNameList);
            }

            for (i_TpPAMFQNameList=0; i_TpPAMFQNameList < u_octet4_loop_TpPAMFQNameList; i_TpPAMFQNameList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMFQNameList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/isGroupIdentity:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_isGroupIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet1 = get_CDR_boolean(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",u_octet1);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/listGroupMembership:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listGroupMembership(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMFQNameList;
    guint32   i_TpPAMFQNameList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMFQNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMFQNameList = %u",u_octet4_loop_TpPAMFQNameList);
            }

            for (i_TpPAMFQNameList=0; i_TpPAMFQNameList < u_octet4_loop_TpPAMFQNameList; i_TpPAMFQNameList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMFQNameList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/addAlias:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_addAlias(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"alias (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/removeAliases:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_removeAliases(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"alias (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/listAliases:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listAliases(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMFQNameList;
    guint32   i_TpPAMFQNameList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMFQNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMFQNameList = %u",u_octet4_loop_TpPAMFQNameList);
            }

            for (i_TpPAMFQNameList=0; i_TpPAMFQNameList < u_octet4_loop_TpPAMFQNameList; i_TpPAMFQNameList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMFQNameList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/lookupByAlias:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_lookupByAlias(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"alias (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMFQName (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/associateTypes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_associateTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_identityTypes;
    guint32   i_identityTypes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_identityTypes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of identityTypes = %u",u_octet4_loop_identityTypes);
        }

        for (i_identityTypes=0; i_identityTypes < u_octet4_loop_identityTypes; i_identityTypes++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identityTypes (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/disassociateTypes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_disassociateTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_identityTypes;
    guint32   i_identityTypes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_identityTypes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of identityTypes = %u",u_octet4_loop_identityTypes);
        }

        for (i_identityTypes=0; i_identityTypes < u_octet4_loop_identityTypes; i_identityTypes++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identityTypes (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/listTypesOfIdentity:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listTypesOfIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMFQNameList;
    guint32   i_TpPAMFQNameList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMFQNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMFQNameList = %u",u_octet4_loop_TpPAMFQNameList);
            }

            for (i_TpPAMFQNameList=0; i_TpPAMFQNameList < u_octet4_loop_TpPAMFQNameList; i_TpPAMFQNameList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMFQNameList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/hasType:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_hasType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"typeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet1 = get_CDR_boolean(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",u_octet1);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/getIdentityAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_getIdentityAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMAttributeList;
    guint32   i_TpPAMAttributeList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identityType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMAttributeList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAttributeList = %u",u_octet4_loop_TpPAMAttributeList);
            }

            for (i_TpPAMAttributeList=0; i_TpPAMAttributeList < u_octet4_loop_TpPAMAttributeList; i_TpPAMAttributeList++) {

                /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

                

                decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_pam_TpPAMAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/setIdentityAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_setIdentityAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributes;
    guint32   i_attributes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identityType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributes = %u",u_octet4_loop_attributes);
        }

        for (i_attributes=0; i_attributes < u_octet4_loop_attributes; i_attributes++) {

            /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

            

            decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_pam_TpPAMAttribute"  */

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/createAgent:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentManagement_createAgent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_agentTypes;
    guint32   i_agentTypes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_agentTypes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of agentTypes = %u",u_octet4_loop_agentTypes);
        }

        for (i_agentTypes=0; i_agentTypes < u_octet4_loop_agentTypes; i_agentTypes++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentTypes (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/deleteAgent:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentManagement_deleteAgent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/isAgent:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentManagement_isAgent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet1 = get_CDR_boolean(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",u_octet1);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/enableCapabilities:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentManagement_enableCapabilities(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_capabilities;
    guint32   i_capabilities;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_capabilities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of capabilities = %u",u_octet4_loop_capabilities);
        }

        for (i_capabilities=0; i_capabilities < u_octet4_loop_capabilities; i_capabilities++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capabilities (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/disableCapabilities:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentManagement_disableCapabilities(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_capabilities;
    guint32   i_capabilities;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_capabilities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of capabilities = %u",u_octet4_loop_capabilities);
        }

        for (i_capabilities=0; i_capabilities < u_octet4_loop_capabilities; i_capabilities++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capabilities (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/listEnabledCapabilities:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentManagement_listEnabledCapabilities(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMCapabilityList;
    guint32   i_TpPAMCapabilityList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCapabilityList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCapabilityList = %u",u_octet4_loop_TpPAMCapabilityList);
            }

            for (i_TpPAMCapabilityList=0; i_TpPAMCapabilityList < u_octet4_loop_TpPAMCapabilityList; i_TpPAMCapabilityList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMCapabilityList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/listAllCapabilities:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentManagement_listAllCapabilities(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMCapabilityList;
    guint32   i_TpPAMCapabilityList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCapabilityList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCapabilityList = %u",u_octet4_loop_TpPAMCapabilityList);
            }

            for (i_TpPAMCapabilityList=0; i_TpPAMCapabilityList < u_octet4_loop_TpPAMCapabilityList; i_TpPAMCapabilityList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMCapabilityList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/isCapableOf:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentManagement_isCapableOf(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capability (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet1 = get_CDR_boolean(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",u_octet1);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/associateTypes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentManagement_associateTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_agentTypes;
    guint32   i_agentTypes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_agentTypes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of agentTypes = %u",u_octet4_loop_agentTypes);
        }

        for (i_agentTypes=0; i_agentTypes < u_octet4_loop_agentTypes; i_agentTypes++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentTypes (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/disassociateTypes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentManagement_disassociateTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_agentTypes;
    guint32   i_agentTypes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_agentTypes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of agentTypes = %u",u_octet4_loop_agentTypes);
        }

        for (i_agentTypes=0; i_agentTypes < u_octet4_loop_agentTypes; i_agentTypes++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentTypes (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/listTypesOfAgent:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentManagement_listTypesOfAgent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/hasType:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentManagement_hasType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"typeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet1 = get_CDR_boolean(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",u_octet1);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/getAgentAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentManagement_getAgentAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMAttributeList;
    guint32   i_TpPAMAttributeList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMAttributeList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAttributeList = %u",u_octet4_loop_TpPAMAttributeList);
            }

            for (i_TpPAMAttributeList=0; i_TpPAMAttributeList < u_octet4_loop_TpPAMAttributeList; i_TpPAMAttributeList++) {

                /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

                

                decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_pam_TpPAMAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/setAgentAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentManagement_setAgentAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributes;
    guint32   i_attributes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributes = %u",u_octet4_loop_attributes);
        }

        for (i_attributes=0; i_attributes < u_octet4_loop_attributes; i_attributes++) {

            /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

            

            decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_pam_TpPAMAttribute"  */

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentAssignment/assignAgent:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_assignAgent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentAssignment/unassignAgent:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_unassignAgent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentAssignment/listAssignedAgents:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssignedAgents(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMFQNameList;
    guint32   i_TpPAMFQNameList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMFQNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMFQNameList = %u",u_octet4_loop_TpPAMFQNameList);
            }

            for (i_TpPAMFQNameList=0; i_TpPAMFQNameList < u_octet4_loop_TpPAMFQNameList; i_TpPAMFQNameList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMFQNameList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentAssignment/listAssociatedIdentitiesOfAgent:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssociatedIdentitiesOfAgent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMFQNameList;
    guint32   i_TpPAMFQNameList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMFQNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMFQNameList = %u",u_octet4_loop_TpPAMFQNameList);
            }

            for (i_TpPAMFQNameList=0; i_TpPAMFQNameList < u_octet4_loop_TpPAMFQNameList; i_TpPAMFQNameList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMFQNameList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentAssignment/listAssignedAgentsByCapability:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssignedAgentsByCapability(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMFQNameList;
    guint32   i_TpPAMFQNameList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capability (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMFQNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMFQNameList = %u",u_octet4_loop_TpPAMFQNameList);
            }

            for (i_TpPAMFQNameList=0; i_TpPAMFQNameList < u_octet4_loop_TpPAMFQNameList; i_TpPAMFQNameList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMFQNameList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentAssignment/listCapabilitiesOfIdentity:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listCapabilitiesOfIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMCapabilityList;
    guint32   i_TpPAMCapabilityList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCapabilityList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCapabilityList = %u",u_octet4_loop_TpPAMCapabilityList);
            }

            for (i_TpPAMCapabilityList=0; i_TpPAMCapabilityList < u_octet4_loop_TpPAMCapabilityList; i_TpPAMCapabilityList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMCapabilityList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentAssignment/isIdentityCapableOf:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_isIdentityCapableOf(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capability (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet1 = get_CDR_boolean(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",u_octet1);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/createIdentityAttribute:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_createIdentityAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_pam_TpPAMAttributeDef"  */

        

        decode_org_csapi_pam_TpPAMAttributeDef_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAttributeDef"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/deleteIdentityAttribute:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_deleteIdentityAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/getIdentityAttributeDefinition:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_getIdentityAttributeDefinition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_pam_TpPAMAttributeDef"  */

            

            decode_org_csapi_pam_TpPAMAttributeDef_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_pam_TpPAMAttributeDef"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/listAllIdentityAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listAllIdentityAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/createIdentityType:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_createIdentityType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"typeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/deleteIdentityType:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_deleteIdentityType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"typeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/listIdentityTypes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listIdentityTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/addIdentityTypeAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_addIdentityTypeAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"typeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/removeIdentityTypeAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_removeIdentityTypeAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"typeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/listIdentityTypeAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listIdentityTypeAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"typeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/createAgentAttribute:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_createAgentAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_pam_TpPAMAttributeDef"  */

        

        decode_org_csapi_pam_TpPAMAttributeDef_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAttributeDef"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/deleteAgentAttribute:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_deleteAgentAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/getAgentAttributeDefinition:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_getAgentAttributeDefinition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_pam_TpPAMAttributeDef"  */

            

            decode_org_csapi_pam_TpPAMAttributeDef_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_pam_TpPAMAttributeDef"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/listAllAgentAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAllAgentAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/createAgentType:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_createAgentType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"typeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/deleteAgentType:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_deleteAgentType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"typeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/listAgentTypes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAgentTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/addAgentTypeAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_addAgentTypeAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"typeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/removeAgentTypeAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_removeAgentTypeAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"typeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/listAgentTypeAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAgentTypeAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"typeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/createCapabilityAttribute:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_createCapabilityAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_pam_TpPAMAttributeDef"  */

        

        decode_org_csapi_pam_TpPAMAttributeDef_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAttributeDef"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/deleteCapabilityAttribute:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_deleteCapabilityAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/getCapabilityAttributeDefinition:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_getCapabilityAttributeDefinition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_pam_TpPAMAttributeDef"  */

            

            decode_org_csapi_pam_TpPAMAttributeDef_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_pam_TpPAMAttributeDef"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/listAllCapabilityAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listAllCapabilityAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/createCapability:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_createCapability(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capabilityName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/deleteCapability:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_deleteCapability(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capabilityName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/listCapabilities:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilities(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMCapabilityList;
    guint32   i_TpPAMCapabilityList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCapabilityList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCapabilityList = %u",u_octet4_loop_TpPAMCapabilityList);
            }

            for (i_TpPAMCapabilityList=0; i_TpPAMCapabilityList < u_octet4_loop_TpPAMCapabilityList; i_TpPAMCapabilityList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMCapabilityList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/addCapabilityAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_addCapabilityAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capabilityName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/removeCapabilityAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_removeCapabilityAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capabilityName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/listCapabilityAttributes:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilityAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capabilityName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStringList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/assignCapabilitiesToType:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_assignCapabilitiesToType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_capabilities;
    guint32   i_capabilities;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_capabilities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of capabilities = %u",u_octet4_loop_capabilities);
        }

        for (i_capabilities=0; i_capabilities < u_octet4_loop_capabilities; i_capabilities++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capabilities (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/unassignCapabilitiesFromType:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_unassignCapabilitiesFromType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_capabilities;
    guint32   i_capabilities;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_capabilities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of capabilities = %u",u_octet4_loop_capabilities);
        }

        for (i_capabilities=0; i_capabilities < u_octet4_loop_capabilities; i_capabilities++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capabilities (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/listCapabilitiesOfType:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilitiesOfType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMCapabilityList;
    guint32   i_TpPAMCapabilityList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCapabilityList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCapabilityList = %u",u_octet4_loop_TpPAMCapabilityList);
            }

            for (i_TpPAMCapabilityList=0; i_TpPAMCapabilityList < u_octet4_loop_TpPAMCapabilityList; i_TpPAMCapabilityList++) {

                u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMCapabilityList (%u) = %s",
                      u_octet4, (u_octet4 > 0) ? seq : "");
                }

                g_free(seq);          /*  free buffer  */
                seq = NULL;

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMProvisioningManager/getAuthToken:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_getAuthToken(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_askerData;
    guint32   i_askerData;
    guint32   u_octet4_loop_TpPAMCredential;
    guint32   i_TpPAMCredential;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_askerData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of askerData = %u",u_octet4_loop_askerData);
        }

        for (i_askerData=0; i_askerData < u_octet4_loop_askerData; i_askerData++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCredential = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCredential = %u",u_octet4_loop_TpPAMCredential);
            }

            for (i_TpPAMCredential=0; i_TpPAMCredential < u_octet4_loop_TpPAMCredential; i_TpPAMCredential++) {

                u_octet1 = get_CDR_octet(tvb,offset);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpPAMCredential = %u",u_octet1);
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMProvisioningManager/obtainInterface:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_obtainInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"interfaceName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMProvisioningManager/getAccessControl:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_getAccessControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_pam_TpPAMAccessControlData"  */

            

            decode_org_csapi_pam_TpPAMAccessControlData_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_pam_TpPAMAccessControlData"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMProvisioningManager/setAccessControl:1.0
 */

static void decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_setAccessControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"operation (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        /*  Begin struct "org_csapi_pam_TpPAMAccessControlData"  */

        

        decode_org_csapi_pam_TpPAMAccessControlData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAccessControlData"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMIdentityPresence/setIdentityPresence:1.0
 */

static void decode_org_csapi_pam_access_IpPAMIdentityPresence_setIdentityPresence(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributes;
    guint32   i_attributes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identityType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributes = %u",u_octet4_loop_attributes);
        }

        for (i_attributes=0; i_attributes < u_octet4_loop_attributes; i_attributes++) {

            /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

            

            decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_pam_TpPAMAttribute"  */

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMIdentityPresence/setIdentityPresenceExpiration:1.0
 */

static void decode_org_csapi_pam_access_IpPAMIdentityPresence_setIdentityPresenceExpiration(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    gint64    s_octet8;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identityType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        s_octet8 = get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-8,8,"expiresIn = PRIo64",s_octet8);
        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMIdentityPresence/getIdentityPresence:1.0
 */

static void decode_org_csapi_pam_access_IpPAMIdentityPresence_getIdentityPresence(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMAttributeList;
    guint32   i_TpPAMAttributeList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identityType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMAttributeList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAttributeList = %u",u_octet4_loop_TpPAMAttributeList);
            }

            for (i_TpPAMAttributeList=0; i_TpPAMAttributeList < u_octet4_loop_TpPAMAttributeList; i_TpPAMAttributeList++) {

                /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

                

                decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_pam_TpPAMAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAgentPresence/setAgentPresence:1.0
 */

static void decode_org_csapi_pam_access_IpPAMAgentPresence_setAgentPresence(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributes;
    guint32   i_attributes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agent (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributes = %u",u_octet4_loop_attributes);
        }

        for (i_attributes=0; i_attributes < u_octet4_loop_attributes; i_attributes++) {

            /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

            

            decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_pam_TpPAMAttribute"  */

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAgentPresence/setCapabilityPresence:1.0
 */

static void decode_org_csapi_pam_access_IpPAMAgentPresence_setCapabilityPresence(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributes;
    guint32   i_attributes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agent (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capability (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributes = %u",u_octet4_loop_attributes);
        }

        for (i_attributes=0; i_attributes < u_octet4_loop_attributes; i_attributes++) {

            /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

            

            decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_pam_TpPAMAttribute"  */

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAgentPresence/setAgentPresenceExpiration:1.0
 */

static void decode_org_csapi_pam_access_IpPAMAgentPresence_setAgentPresenceExpiration(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    gint64    s_octet8;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agent (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        s_octet8 = get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-8,8,"expiresIn = PRIo64",s_octet8);
        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAgentPresence/setCapabilityPresenceExpiration:1.0
 */

static void decode_org_csapi_pam_access_IpPAMAgentPresence_setCapabilityPresenceExpiration(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    gint64    s_octet8;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agent (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capability (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        s_octet8 = get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-8,8,"expiresIn = PRIo64",s_octet8);
        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAgentPresence/getAgentPresence:1.0
 */

static void decode_org_csapi_pam_access_IpPAMAgentPresence_getAgentPresence(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMAttributeList;
    guint32   i_TpPAMAttributeList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agent (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMAttributeList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAttributeList = %u",u_octet4_loop_TpPAMAttributeList);
            }

            for (i_TpPAMAttributeList=0; i_TpPAMAttributeList < u_octet4_loop_TpPAMAttributeList; i_TpPAMAttributeList++) {

                /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

                

                decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_pam_TpPAMAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAgentPresence/getCapabilityPresence:1.0
 */

static void decode_org_csapi_pam_access_IpPAMAgentPresence_getCapabilityPresence(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMAttributeList;
    guint32   i_TpPAMAttributeList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"agent (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"capability (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMAttributeList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAttributeList = %u",u_octet4_loop_TpPAMAttributeList);
            }

            for (i_TpPAMAttributeList=0; i_TpPAMAttributeList < u_octet4_loop_TpPAMAttributeList; i_TpPAMAttributeList++) {

                /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

                

                decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_pam_TpPAMAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpAppPAMPreferenceCheck/computeAvailability:1.0
 */

static void decode_org_csapi_pam_access_IpAppPAMPreferenceCheck_computeAvailability(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMAvailabilityProfileList;
    guint32   i_TpPAMAvailabilityProfileList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        /*  Begin struct "org_csapi_pam_TpPAMContext"  */

        

        decode_org_csapi_pam_TpPAMContext_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMContext"  */

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMAvailabilityProfileList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAvailabilityProfileList = %u",u_octet4_loop_TpPAMAvailabilityProfileList);
            }

            for (i_TpPAMAvailabilityProfileList=0; i_TpPAMAvailabilityProfileList < u_octet4_loop_TpPAMAvailabilityProfileList; i_TpPAMAvailabilityProfileList++) {

                /*  Begin struct "org_csapi_pam_TpPAMAvailabilityProfile"  */

                

                decode_org_csapi_pam_TpPAMAvailabilityProfile_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_pam_TpPAMAvailabilityProfile"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAvailability/getAvailability:1.0
 */

static void decode_org_csapi_pam_access_IpPAMAvailability_getAvailability(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpPAMAvailabilityProfileList;
    guint32   i_TpPAMAvailabilityProfileList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        /*  Begin struct "org_csapi_pam_TpPAMContext"  */

        

        decode_org_csapi_pam_TpPAMContext_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMContext"  */

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"attributeNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMAvailabilityProfileList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAvailabilityProfileList = %u",u_octet4_loop_TpPAMAvailabilityProfileList);
            }

            for (i_TpPAMAvailabilityProfileList=0; i_TpPAMAvailabilityProfileList < u_octet4_loop_TpPAMAvailabilityProfileList; i_TpPAMAvailabilityProfileList++) {

                /*  Begin struct "org_csapi_pam_TpPAMAvailabilityProfile"  */

                

                decode_org_csapi_pam_TpPAMAvailabilityProfile_st(tvb, pinfo, tree, offset, header, operation);

                /*  End struct "org_csapi_pam_TpPAMAvailabilityProfile"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAvailability/getPreference:1.0
 */

static void decode_org_csapi_pam_access_IpPAMAvailability_getPreference(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        /*  Begin struct "org_csapi_pam_TpPAMContext"  */

        

        decode_org_csapi_pam_TpPAMContext_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMContext"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin union "org_csapi_pam_TpPAMPreferenceData"  */

            
            decode_org_csapi_pam_TpPAMPreferenceData_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_pam_TpPAMPreferenceData"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAvailability/setPreference:1.0
 */

static void decode_org_csapi_pam_access_IpPAMAvailability_setPreference(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        /*  Begin struct "org_csapi_pam_TpPAMContext"  */

        

        decode_org_csapi_pam_TpPAMContext_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMContext"  */

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"operation (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        /*  Begin union "org_csapi_pam_TpPAMPreferenceData"  */

        
        decode_org_csapi_pam_TpPAMPreferenceData_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_pam_TpPAMPreferenceData"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMPresenceAvailabilityManager/getAuthToken:1.0
 */

static void decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_getAuthToken(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_askerData;
    guint32   i_askerData;
    guint32   u_octet4_loop_TpPAMCredential;
    guint32   i_TpPAMCredential;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_askerData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of askerData = %u",u_octet4_loop_askerData);
        }

        for (i_askerData=0; i_askerData < u_octet4_loop_askerData; i_askerData++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCredential = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCredential = %u",u_octet4_loop_TpPAMCredential);
            }

            for (i_TpPAMCredential=0; i_TpPAMCredential < u_octet4_loop_TpPAMCredential; i_TpPAMCredential++) {

                u_octet1 = get_CDR_octet(tvb,offset);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpPAMCredential = %u",u_octet1);
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMPresenceAvailabilityManager/obtainInterface:1.0
 */

static void decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_obtainInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"interfaceName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMPresenceAvailabilityManager/getAccessControl:1.0
 */

static void decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_getAccessControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_pam_TpPAMAccessControlData"  */

            

            decode_org_csapi_pam_TpPAMAccessControlData_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_pam_TpPAMAccessControlData"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMPresenceAvailabilityManager/setAccessControl:1.0
 */

static void decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_setAccessControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"operation (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        /*  Begin struct "org_csapi_pam_TpPAMAccessControlData"  */

        

        decode_org_csapi_pam_TpPAMAccessControlData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAccessControlData"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMPresenceAvailabilityManager/activateService:1.0
 */

static void decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_activateService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMPresenceAvailabilityManager/deactivateService:1.0
 */

static void decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_deactivateService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMPresenceAvailabilityManager/isActiveIdentity:1.0
 */

static void decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_isActiveIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet1 = get_CDR_boolean(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",u_octet1);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpAppPAMEventHandler/eventNotify:1.0
 */

static void decode_org_csapi_pam_event_IpAppPAMEventHandler_eventNotify(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_eventInfo;
    guint32   i_eventInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"eventID = %i",s_octet4);
        }

        u_octet4_loop_eventInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of eventInfo = %u",u_octet4_loop_eventInfo);
        }

        for (i_eventInfo=0; i_eventInfo < u_octet4_loop_eventInfo; i_eventInfo++) {

            /*  Begin union "org_csapi_pam_TpPAMNotificationInfo"  */

            
            decode_org_csapi_pam_TpPAMNotificationInfo_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_pam_TpPAMNotificationInfo"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpAppPAMEventHandler/eventNotifyErr:1.0
 */

static void decode_org_csapi_pam_event_IpAppPAMEventHandler_eventNotifyErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"eventID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_pam_TpPAMErrorInfo"  */

        

        decode_org_csapi_pam_TpPAMErrorInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMErrorInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventHandler/isRegistered:1.0
 */

static void decode_org_csapi_pam_event_IpPAMEventHandler_isRegistered(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"clientID = %i",s_octet4);
        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet1 = get_CDR_boolean(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",u_octet1);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventHandler/registerAppInterface:1.0
 */

static void decode_org_csapi_pam_event_IpPAMEventHandler_registerAppInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMClientID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventHandler/registerForEvent:1.0
 */

static void decode_org_csapi_pam_event_IpPAMEventHandler_registerForEvent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_eventList;
    guint32   i_eventList;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"clientID = %i",s_octet4);
        }

        u_octet4_loop_eventList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of eventList = %u",u_octet4_loop_eventList);
        }

        for (i_eventList=0; i_eventList < u_octet4_loop_eventList; i_eventList++) {

            /*  Begin union "org_csapi_pam_TpPAMEventInfo"  */

            
            decode_org_csapi_pam_TpPAMEventInfo_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_pam_TpPAMEventInfo"  */

        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"validFor = %i",s_octet4);
        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMEventID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventHandler/deregisterAppInterface:1.0
 */

static void decode_org_csapi_pam_event_IpPAMEventHandler_deregisterAppInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"clientID = %i",s_octet4);
        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventHandler/deregisterFromEvent:1.0
 */

static void decode_org_csapi_pam_event_IpPAMEventHandler_deregisterFromEvent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"eventID = %i",s_octet4);
        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventManager/getAuthToken:1.0
 */

static void decode_org_csapi_pam_event_IpPAMEventManager_getAuthToken(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_askerData;
    guint32   i_askerData;
    guint32   u_octet4_loop_TpPAMCredential;
    guint32   i_TpPAMCredential;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_askerData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of askerData = %u",u_octet4_loop_askerData);
        }

        for (i_askerData=0; i_askerData < u_octet4_loop_askerData; i_askerData++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCredential = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCredential = %u",u_octet4_loop_TpPAMCredential);
            }

            for (i_TpPAMCredential=0; i_TpPAMCredential < u_octet4_loop_TpPAMCredential; i_TpPAMCredential++) {

                u_octet1 = get_CDR_octet(tvb,offset);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpPAMCredential = %u",u_octet1);
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventManager/obtainInterface:1.0
 */

static void decode_org_csapi_pam_event_IpPAMEventManager_obtainInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"interfaceName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventManager/getAccessControl:1.0
 */

static void decode_org_csapi_pam_event_IpPAMEventManager_getAccessControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_pam_TpPAMAccessControlData"  */

            

            decode_org_csapi_pam_TpPAMAccessControlData_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_pam_TpPAMAccessControlData"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventManager/setAccessControl:1.0
 */

static void decode_org_csapi_pam_event_IpPAMEventManager_setAccessControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"operation (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        /*  Begin struct "org_csapi_pam_TpPAMAccessControlData"  */

        

        decode_org_csapi_pam_TpPAMAccessControlData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAccessControlData"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventManager/activateService:1.0
 */

static void decode_org_csapi_pam_event_IpPAMEventManager_activateService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventManager/deactivateService:1.0
 */

static void decode_org_csapi_pam_event_IpPAMEventManager_deactivateService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventManager/isActiveIdentity:1.0
 */

static void decode_org_csapi_pam_event_IpPAMEventManager_isActiveIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"identity (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet1 = get_CDR_boolean(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",u_octet1);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessagingManager/mailboxTerminated:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_mailboxTerminated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mmm_TpMailboxIdentifier"  */

        

        decode_org_csapi_mmm_TpMailboxIdentifier_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpMailboxIdentifier"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessagingManager/reportNotification:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_eventInfo;
    guint32   i_eventInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        u_octet4_loop_eventInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of eventInfo = %u",u_octet4_loop_eventInfo);
        }

        for (i_eventInfo=0; i_eventInfo < u_octet4_loop_eventInfo; i_eventInfo++) {

            /*  Begin union "org_csapi_mmm_TpMessagingEventInfo"  */

            
            decode_org_csapi_mmm_TpMessagingEventInfo_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_mmm_TpMessagingEventInfo"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessagingManager/notificationsInterrupted:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_notificationsInterrupted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessagingManager/notificationsResumed:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_notificationsResumed(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessagingManager/multiMediaMessagingTerminated:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_multiMediaMessagingTerminated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

        

        decode_org_csapi_mmm_TpMultiMediaMessagingIdentifier_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessagingManager/terminateMultipleMailboxes:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_terminateMultipleMailboxes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_mailboxSet;
    guint32   i_mailboxSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_mailboxSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of mailboxSet = %u",u_octet4_loop_mailboxSet);
        }

        for (i_mailboxSet=0; i_mailboxSet < u_octet4_loop_mailboxSet; i_mailboxSet++) {

            /*  Begin struct "org_csapi_mmm_TpMailboxIdentifier"  */

            

            decode_org_csapi_mmm_TpMailboxIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mmm_TpMailboxIdentifier"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessagingManager/terminateMultipleMultiMediaMessagingSessions:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_terminateMultipleMultiMediaMessagingSessions(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_multiMediaMessagingSet;
    guint32   i_multiMediaMessagingSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4_loop_multiMediaMessagingSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of multiMediaMessagingSet = %u",u_octet4_loop_multiMediaMessagingSet);
        }

        for (i_multiMediaMessagingSet=0; i_multiMediaMessagingSet < u_octet4_loop_multiMediaMessagingSet; i_multiMediaMessagingSet++) {

            /*  Begin struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

            

            decode_org_csapi_mmm_TpMultiMediaMessagingIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/openMailbox:1.0
 */

static void decode_org_csapi_mmm_IpMultiMediaMessagingManager_openMailbox(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"mailboxID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"authenticationInfo (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mmm_TpMailboxIdentifier"  */

            

            decode_org_csapi_mmm_TpMailboxIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mmm_TpMailboxIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/openMultiMediaMessaging:1.0
 */

static void decode_org_csapi_mmm_IpMultiMediaMessagingManager_openMultiMediaMessaging(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mmm_TpTerminatingAddressList"  */

        

        decode_org_csapi_mmm_TpTerminatingAddressList_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpTerminatingAddressList"  */

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

            

            decode_org_csapi_mmm_TpMultiMediaMessagingIdentifier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/createNotification:1.0
 */

static void decode_org_csapi_mmm_IpMultiMediaMessagingManager_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_eventCriteria;
    guint32   i_eventCriteria;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_eventCriteria = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of eventCriteria = %u",u_octet4_loop_eventCriteria);
        }

        for (i_eventCriteria=0; i_eventCriteria < u_octet4_loop_eventCriteria; i_eventCriteria++) {

            /*  Begin union "org_csapi_mmm_TpMessagingEventCriteria"  */

            
            decode_org_csapi_mmm_TpMessagingEventCriteria_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_mmm_TpMessagingEventCriteria"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/destroyNotification:1.0
 */

static void decode_org_csapi_mmm_IpMultiMediaMessagingManager_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/changeNotification:1.0
 */

static void decode_org_csapi_mmm_IpMultiMediaMessagingManager_changeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_eventCriteria;
    guint32   i_eventCriteria;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        u_octet4_loop_eventCriteria = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of eventCriteria = %u",u_octet4_loop_eventCriteria);
        }

        for (i_eventCriteria=0; i_eventCriteria < u_octet4_loop_eventCriteria; i_eventCriteria++) {

            /*  Begin union "org_csapi_mmm_TpMessagingEventCriteria"  */

            
            decode_org_csapi_mmm_TpMessagingEventCriteria_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_mmm_TpMessagingEventCriteria"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/getNextNotification:1.0
 */

static void decode_org_csapi_mmm_IpMultiMediaMessagingManager_getNextNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",u_octet1);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mmm_TpMessagingNotificationRequestedSetEntry"  */

            

            decode_org_csapi_mmm_TpMessagingNotificationRequestedSetEntry_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mmm_TpMessagingNotificationRequestedSetEntry"  */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/enableNotifications:1.0
 */

static void decode_org_csapi_mmm_IpMultiMediaMessagingManager_enableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/disableNotifications:1.0
 */

static void decode_org_csapi_mmm_IpMultiMediaMessagingManager_disableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/createFolderRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_createFolderRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/createFolderErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_createFolderErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getFoldersRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getFoldersRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_folderNames;
    guint32   i_folderNames;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_folderNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of folderNames = %u",u_octet4_loop_folderNames);
        }

        for (i_folderNames=0; i_folderNames < u_octet4_loop_folderNames; i_folderNames++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderNames (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getFoldersErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getFoldersErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/deleteFolderRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_deleteFolderRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/deleteFolderErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_deleteFolderErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/copyFolderRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_copyFolderRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/copyFolderErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_copyFolderErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/moveFolderRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_moveFolderRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/moveFolderErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_moveFolderErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/putMessageRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_putMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/putMessageErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_putMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/copyMessageRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_copyMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/copyMessageErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_copyMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/moveMessageRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_moveMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/moveMessageErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_moveMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/deleteMessageRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_deleteMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/deleteMessageErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_deleteMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/listMessagesRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_listMessagesRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_messageList;
    guint32   i_messageList;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4_loop_messageList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of messageList = %u",u_octet4_loop_messageList);
        }

        for (i_messageList=0; i_messageList < u_octet4_loop_messageList; i_messageList++) {

            /*  Begin struct "org_csapi_mmm_TpMessageDescription"  */

            

            decode_org_csapi_mmm_TpMessageDescription_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mmm_TpMessageDescription"  */

        }

        /*  Begin struct "org_csapi_mmm_TpMailboxFolderStatusInformation"  */

        

        decode_org_csapi_mmm_TpMailboxFolderStatusInformation_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpMailboxFolderStatusInformation"  */

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"final = %u",u_octet1);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/listMessagesErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_listMessagesErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/listMessageBodyPartsRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_listMessageBodyPartsRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_partsList;
    guint32   i_partsList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4_loop_partsList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of partsList = %u",u_octet4_loop_partsList);
        }

        for (i_partsList=0; i_partsList < u_octet4_loop_partsList; i_partsList++) {

            /*  Begin struct "org_csapi_mmm_TpBodyPartDescription"  */

            

            decode_org_csapi_mmm_TpBodyPartDescription_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mmm_TpBodyPartDescription"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/listMessageBodyPartsErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_listMessageBodyPartsErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageBodyPartsRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getMessageBodyPartsRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_bodyParts;
    guint32   i_bodyParts;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4_loop_bodyParts = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of bodyParts = %u",u_octet4_loop_bodyParts);
        }

        for (i_bodyParts=0; i_bodyParts < u_octet4_loop_bodyParts; i_bodyParts++) {

            /*  Begin struct "org_csapi_mmm_TpBodyPart"  */

            

            decode_org_csapi_mmm_TpBodyPart_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mmm_TpBodyPart"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageBodyPartsErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getMessageBodyPartsErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageHeadersRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getMessageHeadersRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_headers;
    guint32   i_headers;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4_loop_headers = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of headers = %u",u_octet4_loop_headers);
        }

        for (i_headers=0; i_headers < u_octet4_loop_headers; i_headers++) {

            /*  Begin union "org_csapi_mmm_TpMessageHeaderField"  */

            
            decode_org_csapi_mmm_TpMessageHeaderField_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_mmm_TpMessageHeaderField"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageHeadersErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getMessageHeadersErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageContentRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getMessageContentRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_content;
    guint32   i_content;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"contentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"contentTransferEncoding (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_content = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of content = %u",u_octet4_loop_content);
        }

        for (i_content=0; i_content < u_octet4_loop_content; i_content++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"content = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageContentErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getMessageContentErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getFullMessageRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getFullMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_message;
    guint32   i_message;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4_loop_message = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of message = %u",u_octet4_loop_message);
        }

        for (i_message=0; i_message < u_octet4_loop_message; i_message++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"message = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getFullMessageErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getFullMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMailboxInfoPropertiesRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getMailboxInfoPropertiesRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_returnedProperties;
    guint32   i_returnedProperties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4_loop_returnedProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of returnedProperties = %u",u_octet4_loop_returnedProperties);
        }

        for (i_returnedProperties=0; i_returnedProperties < u_octet4_loop_returnedProperties; i_returnedProperties++) {

            /*  Begin union "org_csapi_mmm_TpMailboxInfoProperty"  */

            
            decode_org_csapi_mmm_TpMailboxInfoProperty_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_mmm_TpMailboxInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getFolderInfoPropertiesRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getFolderInfoPropertiesRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_returnedProperties;
    guint32   i_returnedProperties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_returnedProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of returnedProperties = %u",u_octet4_loop_returnedProperties);
        }

        for (i_returnedProperties=0; i_returnedProperties < u_octet4_loop_returnedProperties; i_returnedProperties++) {

            /*  Begin union "org_csapi_mmm_TpFolderInfoProperty"  */

            
            decode_org_csapi_mmm_TpFolderInfoProperty_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_mmm_TpFolderInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageInfoPropertiesRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getMessageInfoPropertiesRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_returnedProperties;
    guint32   i_returnedProperties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_returnedProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of returnedProperties = %u",u_octet4_loop_returnedProperties);
        }

        for (i_returnedProperties=0; i_returnedProperties < u_octet4_loop_returnedProperties; i_returnedProperties++) {

            /*  Begin union "org_csapi_mmm_TpMessageInfoProperty"  */

            
            decode_org_csapi_mmm_TpMessageInfoProperty_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_mmm_TpMessageInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/setMessageInfoPropertiesRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_setMessageInfoPropertiesRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_propertiesUpdated;
    guint32   i_propertiesUpdated;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_propertiesUpdated = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of propertiesUpdated = %u",u_octet4_loop_propertiesUpdated);
        }

        for (i_propertiesUpdated=0; i_propertiesUpdated < u_octet4_loop_propertiesUpdated; i_propertiesUpdated++) {

            /*  Begin union "org_csapi_mmm_TpMessageInfoProperty"  */

            
            decode_org_csapi_mmm_TpMessageInfoProperty_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_mmm_TpMessageInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/setMessageInfoPropertiesErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_setMessageInfoPropertiesErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_propertiesNotUpdated;
    guint32   i_propertiesNotUpdated;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_propertiesNotUpdated = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of propertiesNotUpdated = %u",u_octet4_loop_propertiesNotUpdated);
        }

        for (i_propertiesNotUpdated=0; i_propertiesNotUpdated < u_octet4_loop_propertiesNotUpdated; i_propertiesNotUpdated++) {

            /*  Begin struct "org_csapi_mmm_TpMessageInfoPropertyError"  */

            

            decode_org_csapi_mmm_TpMessageInfoPropertyError_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mmm_TpMessageInfoPropertyError"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMailboxInfoPropertiesErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getMailboxInfoPropertiesErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getFolderInfoPropertiesErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getFolderInfoPropertiesErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageInfoPropertiesErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMailbox_getMessageInfoPropertiesErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/close:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_close(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/createFolderReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_createFolderReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getFoldersReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_getFoldersReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/deleteFolderReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_deleteFolderReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/copyFolderReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_copyFolderReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"sourceFolderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"destinationFolderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/moveFolderReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_moveFolderReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"sourceFolderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"destinationFolderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/putMessageReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_putMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_message;
    guint32   i_message;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_message = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of message = %u",u_octet4_loop_message);
        }

        for (i_message=0; i_message < u_octet4_loop_message; i_message++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"message = %u",u_octet1);
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/copyMessageReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_copyMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"fromFolderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"toFolderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/moveMessageReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_moveMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"fromFolderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"toFolderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/deleteMessageReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_deleteMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"fromFolderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/listMessagesReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_listMessagesReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        /*  Begin struct "org_csapi_mmm_TpListMessagesCriteria"  */

        

        decode_org_csapi_mmm_TpListMessagesCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpListMessagesCriteria"  */

        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",u_octet1);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/listMessageBodyPartsReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_listMessageBodyPartsReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"maxNestingLevel = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getMessageBodyPartsReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_getMessageBodyPartsReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_partIDs;
    guint32   i_partIDs;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_partIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of partIDs = %u",u_octet4_loop_partIDs);
        }

        for (i_partIDs=0; i_partIDs < u_octet4_loop_partIDs; i_partIDs++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"partIDs (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getMessageHeadersReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_getMessageHeadersReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getMessageContentReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_getMessageContentReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getFullMessageReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_getFullMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getMailboxInfoPropertiesReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_getMailboxInfoPropertiesReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getFolderInfoPropertiesReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_getFolderInfoPropertiesReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"folderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getMessageInfoPropertiesReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_getMessageInfoPropertiesReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/setMessageInfoPropertiesReq:1.0
 */

static void decode_org_csapi_mmm_IpMailbox_setMessageInfoPropertiesReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_properties;
    guint32   i_properties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"messageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_properties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of properties = %u",u_octet4_loop_properties);
        }

        for (i_properties=0; i_properties < u_octet4_loop_properties; i_properties++) {

            /*  Begin union "org_csapi_mmm_TpMessageInfoProperty"  */

            
            decode_org_csapi_mmm_TpMessageInfoProperty_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_mmm_TpMessageInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/sendMessageRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessaging_sendMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/sendMessageErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessaging_sendMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/cancelMessageRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessaging_cancelMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/cancelMessageErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessaging_cancelMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/queryStatusRes:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessaging_queryStatusRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_result;
    guint32   i_result;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        u_octet4_loop_result = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of result = %u",u_octet4_loop_result);
        }

        for (i_result=0; i_result < u_octet4_loop_result; i_result++) {

            /*  Begin struct "org_csapi_mmm_TpQueryStatusReport"  */

            

            decode_org_csapi_mmm_TpQueryStatusReport_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_mmm_TpQueryStatusReport"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/queryStatusErr:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessaging_queryStatusErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"errorDetails (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/messageStatusReport:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessaging_messageStatusReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"deliveryReportType = %i",s_octet4);
        }

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"deliveryReportInfo (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/messageReceived:1.0
 */

static void decode_org_csapi_mmm_IpAppMultiMediaMessaging_messageReceived(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_message;
    guint32   i_message;
    guint8    u_octet1;
    guint32   u_octet4_loop_headers;
    guint32   i_headers;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        u_octet4_loop_message = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of message = %u",u_octet4_loop_message);
        }

        for (i_message=0; i_message < u_octet4_loop_message; i_message++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"message = %u",u_octet1);
            }

        }

        u_octet4_loop_headers = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of headers = %u",u_octet4_loop_headers);
        }

        for (i_headers=0; i_headers < u_octet4_loop_headers; i_headers++) {

            /*  Begin union "org_csapi_mmm_TpMessageHeaderField"  */

            
            decode_org_csapi_mmm_TpMessageHeaderField_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_mmm_TpMessageHeaderField"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessaging/sendMessageReq:1.0
 */

static void decode_org_csapi_mmm_IpMultiMediaMessaging_sendMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_messageTreatment;
    guint32   i_messageTreatment;
    guint32   u_octet4_loop_message;
    guint32   i_message;
    guint8    u_octet1;
    guint32   u_octet4_loop_additionalHeaders;
    guint32   i_additionalHeaders;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_mmm_TpTerminatingAddressList"  */

        

        decode_org_csapi_mmm_TpTerminatingAddressList_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpTerminatingAddressList"  */

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"deliveryType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        u_octet4_loop_messageTreatment = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of messageTreatment = %u",u_octet4_loop_messageTreatment);
        }

        for (i_messageTreatment=0; i_messageTreatment < u_octet4_loop_messageTreatment; i_messageTreatment++) {

            /*  Begin union "org_csapi_mmm_TpMessageTreatment"  */

            
            decode_org_csapi_mmm_TpMessageTreatment_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_mmm_TpMessageTreatment"  */

        }

        u_octet4_loop_message = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of message = %u",u_octet4_loop_message);
        }

        for (i_message=0; i_message < u_octet4_loop_message; i_message++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"message = %u",u_octet1);
            }

        }

        u_octet4_loop_additionalHeaders = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of additionalHeaders = %u",u_octet4_loop_additionalHeaders);
        }

        for (i_additionalHeaders=0; i_additionalHeaders < u_octet4_loop_additionalHeaders; i_additionalHeaders++) {

            /*  Begin union "org_csapi_mmm_TpMessageHeaderField"  */

            
            decode_org_csapi_mmm_TpMessageHeaderField_un(tvb, pinfo, tree, offset, header, operation);

            /*  End union "org_csapi_mmm_TpMessageHeaderField"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",s_octet4);
            }

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessaging/cancelMessageReq:1.0
 */

static void decode_org_csapi_mmm_IpMultiMediaMessaging_cancelMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessaging/queryStatusReq:1.0
 */

static void decode_org_csapi_mmm_IpMultiMediaMessaging_queryStatusReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessaging/close:1.0
 */

static void decode_org_csapi_mmm_IpMultiMediaMessaging_close(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);

    switch(header->message_type) {

    case Request:

        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",s_octet4);
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:

            /* Unknown Exception */

            g_warning("Unknown Exception ");

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:

        /* Unknown GIOP Message */

        g_warning("Unknown GIOP Message");

        break;

    } /* switch(header->message_type) */

}

/* Struct = IDL:org/csapi/TpAddress:1.0 */

static void decode_org_csapi_TpAddress_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpAddressPlan,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpAddress_AddrString (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpAddress_Name (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpAddressPresentation,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpAddressScreening,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpAddress_SubAddressString (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/TpAddressRange:1.0 */

static void decode_org_csapi_TpAddressRange_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpAddressPlan,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpAddressRange_AddrString (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpAddressRange_Name (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpAddressRange_SubAddressString (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/TpCAIElements:1.0 */

static void decode_org_csapi_TpCAIElements_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCAIElements_UnitsPerInterval = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCAIElements_SecondsPerTimeInterval = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCAIElements_ScalingFactor = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCAIElements_UnitIncrement = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCAIElements_UnitsPerDataInterval = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCAIElements_SegmentsPerDataInterval = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCAIElements_InitialSecsPerTimeInterval = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/TpChargeAdviceInfo:1.0 */

static void decode_org_csapi_TpChargeAdviceInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpCAIElements"  */

    

    decode_org_csapi_TpCAIElements_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpCAIElements"  */

    /*  Begin struct "org_csapi_TpCAIElements"  */

    

    decode_org_csapi_TpCAIElements_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpCAIElements"  */

}

/* Struct = IDL:org/csapi/TpChargePerTime:1.0 */

static void decode_org_csapi_TpChargePerTime_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargePerTime_InitialCharge = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargePerTime_CurrentChargePerMinute = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargePerTime_NextChargePerMinute = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/TpAoCInfo:1.0 */

static void decode_org_csapi_TpAoCInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin union "org_csapi_TpAoCOrder"  */

    
    decode_org_csapi_TpAoCOrder_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_TpAoCOrder"  */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpAoCInfo_Currency (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/TpTimeInterval:1.0 */

static void decode_org_csapi_TpTimeInterval_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpTimeInterval_StartTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpTimeInterval_StopTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/TpStructuredAttributeValue:1.0 */

static void decode_org_csapi_TpStructuredAttributeValue_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpStructuredAttributeValue_Type (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    get_CDR_any(tvb,tree,offset,stream_is_big_endian, boundary, header);

}

/* Struct = IDL:org/csapi/TpAttribute:1.0 */

static void decode_org_csapi_TpAttribute_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpAttribute_AttributeName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin union "org_csapi_TpAttributeValue"  */

    
    decode_org_csapi_TpAttributeValue_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_TpAttributeValue"  */

}

/* Struct = IDL:org/csapi/fw/TpFaultStats:1.0 */

static void decode_org_csapi_fw_TpFaultStats_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpInterfaceFault,"Unknown Enum Value"));
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpFaultStats_Occurrences = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpFaultStats_MaxDuration = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpFaultStats_TotalDuration = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpFaultStats_NumberOfClientsAffected = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/fw/TpFaultStatsRecord:1.0 */

static void decode_org_csapi_fw_TpFaultStatsRecord_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpFaultStatsRecord_FaultStatsSet;
    guint32   i_TpFaultStatsRecord_FaultStatsSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpTimeInterval"  */

    

    decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpTimeInterval"  */

    u_octet4_loop_TpFaultStatsRecord_FaultStatsSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpFaultStatsRecord_FaultStatsSet = %u",u_octet4_loop_TpFaultStatsRecord_FaultStatsSet);
    }

    for (i_TpFaultStatsRecord_FaultStatsSet=0; i_TpFaultStatsRecord_FaultStatsSet < u_octet4_loop_TpFaultStatsRecord_FaultStatsSet; i_TpFaultStatsRecord_FaultStatsSet++) {

        /*  Begin struct "org_csapi_fw_TpFaultStats"  */

        

        decode_org_csapi_fw_TpFaultStats_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpFaultStats"  */

    }

}

/* Struct = IDL:org/csapi/fw/TpLoadPolicy:1.0 */

static void decode_org_csapi_fw_TpLoadPolicy_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpLoadPolicy_LoadPolicy (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/fw/TpLoadStatisticData:1.0 */

static void decode_org_csapi_fw_TpLoadStatisticData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gfloat    my_float;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLoadStatisticData_LoadValue = %.6e",my_float);
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadLevel,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/fw/TpLoadThreshold:1.0 */

static void decode_org_csapi_fw_TpLoadThreshold_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gfloat    my_float;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLoadThreshold_LoadThreshold = %.6e",my_float);
    }

}

/* Struct = IDL:org/csapi/fw/TpLoadInitVal:1.0 */

static void decode_org_csapi_fw_TpLoadInitVal_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadLevel,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_fw_TpLoadThreshold"  */

    

    decode_org_csapi_fw_TpLoadThreshold_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_fw_TpLoadThreshold"  */

}

/* Struct = IDL:org/csapi/fw/TpProperty:1.0 */

static void decode_org_csapi_fw_TpProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpProperty_PropertyName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpProperty_PropertyValue (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/fw/TpClientAppDescription:1.0 */

static void decode_org_csapi_fw_TpClientAppDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpClientAppDescription_ClientAppProperties;
    guint32   i_TpClientAppDescription_ClientAppProperties;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpClientAppDescription_ClientAppID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpClientAppDescription_ClientAppProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpClientAppDescription_ClientAppProperties = %u",u_octet4_loop_TpClientAppDescription_ClientAppProperties);
    }

    for (i_TpClientAppDescription_ClientAppProperties=0; i_TpClientAppDescription_ClientAppProperties < u_octet4_loop_TpClientAppDescription_ClientAppProperties; i_TpClientAppDescription_ClientAppProperties++) {

        /*  Begin struct "org_csapi_fw_TpProperty"  */

        

        decode_org_csapi_fw_TpProperty_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpProperty"  */

    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpClientAppDescription_HasAccessSession = %u",u_octet1);
    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpClientAppDescription_HasServiceInstances = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/fw/TpEntOp:1.0 */

static void decode_org_csapi_fw_TpEntOp_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpEntOp_EntOpProperties;
    guint32   i_TpEntOp_EntOpProperties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpEntOp_EntOpID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpEntOp_EntOpProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpEntOp_EntOpProperties = %u",u_octet4_loop_TpEntOp_EntOpProperties);
    }

    for (i_TpEntOp_EntOpProperties=0; i_TpEntOp_EntOpProperties < u_octet4_loop_TpEntOp_EntOpProperties; i_TpEntOp_EntOpProperties++) {

        /*  Begin struct "org_csapi_fw_TpProperty"  */

        

        decode_org_csapi_fw_TpProperty_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpProperty"  */

    }

}

/* Struct = IDL:org/csapi/fw/TpSag:1.0 */

static void decode_org_csapi_fw_TpSag_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpSag_SagID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpSag_SagDescription (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/fw/TpServiceProperty:1.0 */

static void decode_org_csapi_fw_TpServiceProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpServiceProperty_ServicePropertyValueList;
    guint32   i_TpServiceProperty_ServicePropertyValueList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceProperty_ServicePropertyName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpServiceProperty_ServicePropertyValueList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceProperty_ServicePropertyValueList = %u",u_octet4_loop_TpServiceProperty_ServicePropertyValueList);
    }

    for (i_TpServiceProperty_ServicePropertyValueList=0; i_TpServiceProperty_ServicePropertyValueList < u_octet4_loop_TpServiceProperty_ServicePropertyValueList; i_TpServiceProperty_ServicePropertyValueList++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceProperty_ServicePropertyValueList (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/fw/TpServiceDescription:1.0 */

static void decode_org_csapi_fw_TpServiceDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpServiceDescription_ServicePropertyList;
    guint32   i_TpServiceDescription_ServicePropertyList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceDescription_ServiceTypeName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpServiceDescription_ServicePropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceDescription_ServicePropertyList = %u",u_octet4_loop_TpServiceDescription_ServicePropertyList);
    }

    for (i_TpServiceDescription_ServicePropertyList=0; i_TpServiceDescription_ServicePropertyList < u_octet4_loop_TpServiceDescription_ServicePropertyList; i_TpServiceDescription_ServicePropertyList++) {

        /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

        

        decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpServiceProperty"  */

    }

}

/* Struct = IDL:org/csapi/fw/TpService:1.0 */

static void decode_org_csapi_fw_TpService_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpService_ServiceID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin struct "org_csapi_fw_TpServiceDescription"  */

    

    decode_org_csapi_fw_TpServiceDescription_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_fw_TpServiceDescription"  */

}

/* Struct = IDL:org/csapi/fw/TpServiceProfileDescription:1.0 */

static void decode_org_csapi_fw_TpServiceProfileDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpServiceProfileDescription_ServiceSubscriptionProperties;
    guint32   i_TpServiceProfileDescription_ServiceSubscriptionProperties;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceProfileDescription_ServiceContractID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceProfileDescription_ServiceStartDate (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceProfileDescription_ServiceEndDate (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceProfileDescription_ServiceTypeName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpServiceProfileDescription_ServiceSubscriptionProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceProfileDescription_ServiceSubscriptionProperties = %u",u_octet4_loop_TpServiceProfileDescription_ServiceSubscriptionProperties);
    }

    for (i_TpServiceProfileDescription_ServiceSubscriptionProperties=0; i_TpServiceProfileDescription_ServiceSubscriptionProperties < u_octet4_loop_TpServiceProfileDescription_ServiceSubscriptionProperties; i_TpServiceProfileDescription_ServiceSubscriptionProperties++) {

        /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

        

        decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpServiceProperty"  */

    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpServiceProfileDescription_InUse = %u",u_octet1);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceProfileDescription_ServiceID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/fw/TpServiceTypeProperty:1.0 */

static void decode_org_csapi_fw_TpServiceTypeProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceTypeProperty_ServicePropertyName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpServiceTypePropertyMode,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceTypeProperty_ServicePropertyTypeName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/fw/TpServiceTypeDescription:1.0 */

static void decode_org_csapi_fw_TpServiceTypeDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceTypeDescription_ServiceTypePropertyList;
    guint32   i_TpServiceTypeDescription_ServiceTypePropertyList;
    guint32   u_octet4_loop_TpServiceTypeDescription_ServiceTypeNameList;
    guint32   i_TpServiceTypeDescription_ServiceTypeNameList;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpServiceTypeDescription_ServiceTypePropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceTypeDescription_ServiceTypePropertyList = %u",u_octet4_loop_TpServiceTypeDescription_ServiceTypePropertyList);
    }

    for (i_TpServiceTypeDescription_ServiceTypePropertyList=0; i_TpServiceTypeDescription_ServiceTypePropertyList < u_octet4_loop_TpServiceTypeDescription_ServiceTypePropertyList; i_TpServiceTypeDescription_ServiceTypePropertyList++) {

        /*  Begin struct "org_csapi_fw_TpServiceTypeProperty"  */

        

        decode_org_csapi_fw_TpServiceTypeProperty_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpServiceTypeProperty"  */

    }

    u_octet4_loop_TpServiceTypeDescription_ServiceTypeNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceTypeDescription_ServiceTypeNameList = %u",u_octet4_loop_TpServiceTypeDescription_ServiceTypeNameList);
    }

    for (i_TpServiceTypeDescription_ServiceTypeNameList=0; i_TpServiceTypeDescription_ServiceTypeNameList < u_octet4_loop_TpServiceTypeDescription_ServiceTypeNameList; i_TpServiceTypeDescription_ServiceTypeNameList++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceTypeDescription_ServiceTypeNameList (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpServiceTypeDescription_AvailableOrUnavailable = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/fw/TpSignatureAndServiceMgr:1.0 */

static void decode_org_csapi_fw_TpSignatureAndServiceMgr_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpSignatureAndServiceMgr_DigitalSignature;
    guint32   i_TpSignatureAndServiceMgr_DigitalSignature;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpSignatureAndServiceMgr_DigitalSignature = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpSignatureAndServiceMgr_DigitalSignature = %u",u_octet4_loop_TpSignatureAndServiceMgr_DigitalSignature);
    }

    for (i_TpSignatureAndServiceMgr_DigitalSignature=0; i_TpSignatureAndServiceMgr_DigitalSignature < u_octet4_loop_TpSignatureAndServiceMgr_DigitalSignature; i_TpSignatureAndServiceMgr_DigitalSignature++) {

        u_octet1 = get_CDR_octet(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"TpSignatureAndServiceMgr_DigitalSignature = %u",u_octet1);
        }

    }

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


}

/* Struct = IDL:org/csapi/fw/TpPerson:1.0 */

static void decode_org_csapi_fw_TpPerson_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPerson_PersonProperties;
    guint32   i_TpPerson_PersonProperties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPerson_PersonName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPerson_PostalAddress (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPerson_TelephoneNumber (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPerson_Email (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPerson_HomePage (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpPerson_PersonProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPerson_PersonProperties = %u",u_octet4_loop_TpPerson_PersonProperties);
    }

    for (i_TpPerson_PersonProperties=0; i_TpPerson_PersonProperties < u_octet4_loop_TpPerson_PersonProperties; i_TpPerson_PersonProperties++) {

        /*  Begin struct "org_csapi_fw_TpProperty"  */

        

        decode_org_csapi_fw_TpProperty_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpProperty"  */

    }

}

/* Struct = IDL:org/csapi/fw/TpServiceContractDescription:1.0 */

static void decode_org_csapi_fw_TpServiceContractDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpServiceContractDescription_ServiceSubscriptionProperties;
    guint32   i_TpServiceContractDescription_ServiceSubscriptionProperties;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_fw_TpPerson"  */

    

    decode_org_csapi_fw_TpPerson_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_fw_TpPerson"  */

    /*  Begin struct "org_csapi_fw_TpPerson"  */

    

    decode_org_csapi_fw_TpPerson_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_fw_TpPerson"  */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceContractDescription_ServiceStartDate (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceContractDescription_ServiceEndDate (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceContractDescription_ServiceTypeName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceContractDescription_ServiceID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpServiceContractDescription_ServiceSubscriptionProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceContractDescription_ServiceSubscriptionProperties = %u",u_octet4_loop_TpServiceContractDescription_ServiceSubscriptionProperties);
    }

    for (i_TpServiceContractDescription_ServiceSubscriptionProperties=0; i_TpServiceContractDescription_ServiceSubscriptionProperties < u_octet4_loop_TpServiceContractDescription_ServiceSubscriptionProperties; i_TpServiceContractDescription_ServiceSubscriptionProperties++) {

        /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

        

        decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpServiceProperty"  */

    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpServiceContractDescription_InUse = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/fw/TpLoadStatistic:1.0 */

static void decode_org_csapi_fw_TpLoadStatistic_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin union "org_csapi_fw_TpLoadStatisticEntityID"  */

    
    decode_org_csapi_fw_TpLoadStatisticEntityID_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_fw_TpLoadStatisticEntityID"  */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpLoadStatistic_TimeStamp (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin union "org_csapi_fw_TpLoadStatisticInfo"  */

    
    decode_org_csapi_fw_TpLoadStatisticInfo_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_fw_TpLoadStatisticInfo"  */

}

/* Struct = IDL:org/csapi/fw/TpServiceContract:1.0 */

static void decode_org_csapi_fw_TpServiceContract_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceContract_ServiceContractID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin struct "org_csapi_fw_TpServiceContractDescription"  */

    

    decode_org_csapi_fw_TpServiceContractDescription_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_fw_TpServiceContractDescription"  */

}

/* Struct = IDL:org/csapi/fw/TpServiceProfile:1.0 */

static void decode_org_csapi_fw_TpServiceProfile_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceProfile_ServiceProfileID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin struct "org_csapi_fw_TpServiceProfileDescription"  */

    

    decode_org_csapi_fw_TpServiceProfileDescription_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_fw_TpServiceProfileDescription"  */

}

/* Struct = IDL:org/csapi/fw/TpAuthDomain:1.0 */

static void decode_org_csapi_fw_TpAuthDomain_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin union "org_csapi_fw_TpDomainID"  */

    
    decode_org_csapi_fw_TpDomainID_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_fw_TpDomainID"  */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


}

/* Struct = IDL:org/csapi/fw/TpSagProfilePair:1.0 */

static void decode_org_csapi_fw_TpSagProfilePair_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpSagProfilePair_Sag (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpSagProfilePair_ServiceProfile (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/fw/TpAddSagMembersConflict:1.0 */

static void decode_org_csapi_fw_TpAddSagMembersConflict_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpAddSagMembersConflict_ClientApplication (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin struct "org_csapi_fw_TpSagProfilePair"  */

    

    decode_org_csapi_fw_TpSagProfilePair_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_fw_TpSagProfilePair"  */

    /*  Begin struct "org_csapi_fw_TpSagProfilePair"  */

    

    decode_org_csapi_fw_TpSagProfilePair_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_fw_TpSagProfilePair"  */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpAddSagMembersConflict_Service (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/fw/TpAssignSagToServiceProfileConflict:1.0 */

static void decode_org_csapi_fw_TpAssignSagToServiceProfileConflict_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpAssignSagToServiceProfileConflict_ClientApplication (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin struct "org_csapi_fw_TpSagProfilePair"  */

    

    decode_org_csapi_fw_TpSagProfilePair_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_fw_TpSagProfilePair"  */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpAssignSagToServiceProfileConflict_Service (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/fw/TpServiceTypePropertyValue:1.0 */

static void decode_org_csapi_fw_TpServiceTypePropertyValue_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpServiceTypePropertyValue_ServicePropertyValueList;
    guint32   i_TpServiceTypePropertyValue_ServicePropertyValueList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceTypePropertyValue_ServicePropertyName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpServiceTypePropertyMode,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceTypePropertyValue_ServicePropertyTypeName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpServiceTypePropertyValue_ServicePropertyValueList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceTypePropertyValue_ServicePropertyValueList = %u",u_octet4_loop_TpServiceTypePropertyValue_ServicePropertyValueList);
    }

    for (i_TpServiceTypePropertyValue_ServicePropertyValueList=0; i_TpServiceTypePropertyValue_ServicePropertyValueList < u_octet4_loop_TpServiceTypePropertyValue_ServicePropertyValueList; i_TpServiceTypePropertyValue_ServicePropertyValueList++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpServiceTypePropertyValue_ServicePropertyValueList (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/fw/TpFwMigrationServiceAvailableInfo:1.0 */

static void decode_org_csapi_fw_TpFwMigrationServiceAvailableInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo;
    guint32   i_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpFwMigrationServiceAvailableInfo_ServiceType (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpFwMigrationServiceAvailableInfo_ServiceID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpFwMigrationServiceAvailableInfo_CompatibleServiceID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpFwMigrationServiceAvailableInfo_BackwardCompatibilityLevel = %u",u_octet1);
    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpFwMigrationServiceAvailableInfo_MigrationRequired = %u",u_octet1);
    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpFwMigrationServiceAvailableInfo_DataMigrated = %u",u_octet1);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpFwMigrationServiceAvailableInfo_MigrationDataAndTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo = %u",u_octet4_loop_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo);
    }

    for (i_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo=0; i_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo < u_octet4_loop_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo; i_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo++) {

        /*  Begin union "org_csapi_fw_TpMigrationAdditionalInfo"  */

        
        decode_org_csapi_fw_TpMigrationAdditionalInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_fw_TpMigrationAdditionalInfo"  */

    }

}

/* Struct = IDL:org/csapi/fw/TpFwAgreementInfo:1.0 */

static void decode_org_csapi_fw_TpFwAgreementInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpFwAgreementInfo_ClientApplicationID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpFwAgreementInfo_ServiceID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpFwAgreementInfo_ServiceContractID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpFwAgreementInfo_ServiceProfileID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/ui/TpUIMessageCriteria:1.0 */

static void decode_org_csapi_ui_TpUIMessageCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUIMessageCriteria_EndSequence (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUIMessageCriteria_MaxMessageTime = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUIMessageCriteria_MaxMessageSize = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/ui/TpUIEventCriteria:1.0 */

static void decode_org_csapi_ui_TpUIEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddressRange"  */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddressRange"  */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUIEventCriteria_ServiceCode (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/ui/TpUIEventCriteriaResult:1.0 */

static void decode_org_csapi_ui_TpUIEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_ui_TpUIEventCriteria"  */

    

    decode_org_csapi_ui_TpUIEventCriteria_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_ui_TpUIEventCriteria"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUIEventCriteriaResult_AssignmentID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/ui/TpUIEventNotificationInfo:1.0 */

static void decode_org_csapi_ui_TpUIEventNotificationInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpUIEventNotificationInfo_UIEventData;
    guint32   i_TpUIEventNotificationInfo_UIEventData;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUIEventNotificationInfo_ServiceCode (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIEventInfoDataType,"Unknown Enum Value"));
    }

    u_octet4_loop_TpUIEventNotificationInfo_UIEventData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpUIEventNotificationInfo_UIEventData = %u",u_octet4_loop_TpUIEventNotificationInfo_UIEventData);
    }

    for (i_TpUIEventNotificationInfo_UIEventData=0; i_TpUIEventNotificationInfo_UIEventData < u_octet4_loop_TpUIEventNotificationInfo_UIEventData; i_TpUIEventNotificationInfo_UIEventData++) {

        u_octet1 = get_CDR_octet(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"TpUIEventNotificationInfo_UIEventData = %u",u_octet1);
        }

    }

}

/* Struct = IDL:org/csapi/ui/TpUIRecognitionProperty:1.0 */

static void decode_org_csapi_ui_TpUIRecognitionProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUIRecognitionProperty_PropertyName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUIRecognitionProperty_PropertyValue (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/ui/TpUIRecognitionCriteria:1.0 */

static void decode_org_csapi_ui_TpUIRecognitionCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpUIRecognitionCriteria_Properties;
    guint32   i_TpUIRecognitionCriteria_Properties;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUIRecognitionCriteria_SpeakerID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpUIRecognitionCriteria_Properties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpUIRecognitionCriteria_Properties = %u",u_octet4_loop_TpUIRecognitionCriteria_Properties);
    }

    for (i_TpUIRecognitionCriteria_Properties=0; i_TpUIRecognitionCriteria_Properties < u_octet4_loop_TpUIRecognitionCriteria_Properties; i_TpUIRecognitionCriteria_Properties++) {

        /*  Begin struct "org_csapi_ui_TpUIRecognitionProperty"  */

        

        decode_org_csapi_ui_TpUIRecognitionProperty_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_ui_TpUIRecognitionProperty"  */

    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUIRecognitionCriteria_Grammar (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/ui/TpUICollectCriteria:1.0 */

static void decode_org_csapi_ui_TpUICollectCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUICollectCriteria_MinLength = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUICollectCriteria_MaxLength = %i",s_octet4);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUICollectCriteria_EndSequence (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUICollectCriteria_StartTimeout = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUICollectCriteria_InterCharTimeout = %i",s_octet4);
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUICollectMode,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_ui_TpUIRecognitionCriteria"  */

    

    decode_org_csapi_ui_TpUIRecognitionCriteria_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_ui_TpUIRecognitionCriteria"  */

}

/* Struct = IDL:org/csapi/ui/TpUIWordOverride:1.0 */

static void decode_org_csapi_ui_TpUIWordOverride_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUIWordOverride_Spelling (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIPronounceType,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUIWordOverride_PronounceAs (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/ui/TpUISynthesisInfoData:1.0 */

static void decode_org_csapi_ui_TpUISynthesisInfoData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpUISynthesisInfoData_WordOverrideSet;
    guint32   i_TpUISynthesisInfoData_WordOverrideSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUISynthesisGender,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUISynthesisAge,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUISynthesisRate,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUISynthesisRange,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUISynthesisInfoData_TextData (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpUISynthesisInfoData_WordOverrideSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpUISynthesisInfoData_WordOverrideSet = %u",u_octet4_loop_TpUISynthesisInfoData_WordOverrideSet);
    }

    for (i_TpUISynthesisInfoData_WordOverrideSet=0; i_TpUISynthesisInfoData_WordOverrideSet < u_octet4_loop_TpUISynthesisInfoData_WordOverrideSet; i_TpUISynthesisInfoData_WordOverrideSet++) {

        /*  Begin struct "org_csapi_ui_TpUIWordOverride"  */

        

        decode_org_csapi_ui_TpUIWordOverride_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_ui_TpUIWordOverride"  */

    }

}

/* Struct = IDL:org/csapi/cc/TpCallError:1.0 */

static void decode_org_csapi_cc_TpCallError_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallError_ErrorTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallErrorType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_TpCallAdditionalErrorInfo"  */

    
    decode_org_csapi_cc_TpCallAdditionalErrorInfo_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_cc_TpCallAdditionalErrorInfo"  */

}

/* Struct = IDL:org/csapi/cc/TpCallEndedReport:1.0 */

static void decode_org_csapi_cc_TpCallEndedReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEndedReport_CallLegSessionID = %i",s_octet4);
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/TpCallInfoReport:1.0 */

static void decode_org_csapi_cc_TpCallInfoReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallInfoReport_CallInfoType = %i",s_octet4);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallInfoReport_CallInitiationStartTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallInfoReport_CallConnectedToResourceTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallInfoReport_CallConnectedToDestinationTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallInfoReport_CallEndTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/TpCallServiceCode:1.0 */

static void decode_org_csapi_cc_TpCallServiceCode_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallServiceCodeType,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallServiceCode_ServiceCodeValue (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/cc/TpCallTreatment:1.0 */

static void decode_org_csapi_cc_TpCallTreatment_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallTreatmentType,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_TpCallAdditionalTreatmentInfo"  */

    
    decode_org_csapi_cc_TpCallAdditionalTreatmentInfo_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_cc_TpCallAdditionalTreatmentInfo"  */

}

/* Struct = IDL:org/csapi/cc/TpCallChargePlan:1.0 */

static void decode_org_csapi_cc_TpCallChargePlan_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_TpCallChargePlan_TransparentCharge;
    guint32   i_TpCallChargePlan_TransparentCharge;
    guint8    u_octet1;
    gint32    s_octet4;
    guint32   u_octet4_loop_TpCallChargePlan_AdditionalInfo;
    guint32   i_TpCallChargePlan_AdditionalInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallChargeOrderCategory,"Unknown Enum Value"));
    }

    u_octet4_loop_TpCallChargePlan_TransparentCharge = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallChargePlan_TransparentCharge = %u",u_octet4_loop_TpCallChargePlan_TransparentCharge);
    }

    for (i_TpCallChargePlan_TransparentCharge=0; i_TpCallChargePlan_TransparentCharge < u_octet4_loop_TpCallChargePlan_TransparentCharge; i_TpCallChargePlan_TransparentCharge++) {

        u_octet1 = get_CDR_octet(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"TpCallChargePlan_TransparentCharge = %u",u_octet1);
        }

    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallChargePlan_ChargePlan = %i",s_octet4);
    }

    u_octet4_loop_TpCallChargePlan_AdditionalInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallChargePlan_AdditionalInfo = %u",u_octet4_loop_TpCallChargePlan_AdditionalInfo);
    }

    for (i_TpCallChargePlan_AdditionalInfo=0; i_TpCallChargePlan_AdditionalInfo < u_octet4_loop_TpCallChargePlan_AdditionalInfo; i_TpCallChargePlan_AdditionalInfo++) {

        u_octet1 = get_CDR_octet(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"TpCallChargePlan_AdditionalInfo = %u",u_octet1);
        }

    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallPartyToChargeType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_TpCallPartyToChargeAdditionalInfo"  */

    
    decode_org_csapi_cc_TpCallPartyToChargeAdditionalInfo_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_cc_TpCallPartyToChargeAdditionalInfo"  */

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallEventCriteria:1.0 */

static void decode_org_csapi_cc_gccs_TpCallEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddressRange"  */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddressRange"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEventCriteria_CallEventName = %i",s_octet4);
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallNotificationType,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallMonitorMode,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallEventCriteriaResult:1.0 */

static void decode_org_csapi_cc_gccs_TpCallEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cc_gccs_TpCallEventCriteria"  */

    

    decode_org_csapi_cc_gccs_TpCallEventCriteria_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cc_gccs_TpCallEventCriteria"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEventCriteriaResult_AssignmentID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallReleaseCause:1.0 */

static void decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallReleaseCause_Value = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallReleaseCause_Location = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallReport:1.0 */

static void decode_org_csapi_cc_gccs_TpCallReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallMonitorMode,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallReport_CallEventTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallReportType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_gccs_TpCallAdditionalReportInfo"  */

    
    decode_org_csapi_cc_gccs_TpCallAdditionalReportInfo_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_cc_gccs_TpCallAdditionalReportInfo"  */

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallReportRequest:1.0 */

static void decode_org_csapi_cc_gccs_TpCallReportRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallMonitorMode,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallReportType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_gccs_TpCallAdditionalReportCriteria"  */

    
    decode_org_csapi_cc_gccs_TpCallAdditionalReportCriteria_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_cc_gccs_TpCallAdditionalReportCriteria"  */

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallEventInfo:1.0 */

static void decode_org_csapi_cc_gccs_TpCallEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpCallEventInfo_CallAppInfo;
    guint32   i_TpCallEventInfo_CallAppInfo;
    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet4_loop_TpCallEventInfo_CallAppInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallEventInfo_CallAppInfo = %u",u_octet4_loop_TpCallEventInfo_CallAppInfo);
    }

    for (i_TpCallEventInfo_CallAppInfo=0; i_TpCallEventInfo_CallAppInfo < u_octet4_loop_TpCallEventInfo_CallAppInfo; i_TpCallEventInfo_CallAppInfo++) {

        /*  Begin union "org_csapi_cc_gccs_TpCallAppInfo"  */

        
        decode_org_csapi_cc_gccs_TpCallAppInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_cc_gccs_TpCallAppInfo"  */

    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEventInfo_CallEventName = %i",s_octet4);
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallNotificationType,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallMonitorMode,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallEndedReport:1.0 */

static void decode_org_csapi_cc_gccs_TpCallEndedReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEndedReport_CallLegSessionID = %i",s_octet4);
    }

    /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

    

    decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallInfoReport:1.0 */

static void decode_org_csapi_cc_gccs_TpCallInfoReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallInfoReport_CallInfoType = %i",s_octet4);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallInfoReport_CallInitiationStartTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallInfoReport_CallConnectedToResourceTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallInfoReport_CallConnectedToDestinationTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallInfoReport_CallEndTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

    

    decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallTreatment:1.0 */

static void decode_org_csapi_cc_gccs_TpCallTreatment_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallTreatmentType,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

    

    decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

    /*  Begin union "org_csapi_cc_TpCallAdditionalTreatmentInfo"  */

    
    decode_org_csapi_cc_TpCallAdditionalTreatmentInfo_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_cc_TpCallAdditionalTreatmentInfo"  */

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallIdentifier:1.0 */

static void decode_org_csapi_cc_gccs_TpCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallIdentifier_CallSessionID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cc/TpCallNotificationScope:1.0 */

static void decode_org_csapi_cc_TpCallNotificationScope_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddressRange"  */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddressRange"  */

}

/* Struct = IDL:org/csapi/cc/TpCallNotificationReportScope:1.0 */

static void decode_org_csapi_cc_TpCallNotificationReportScope_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

}

/* Struct = IDL:org/csapi/cc/TpCallEventRequest:1.0 */

static void decode_org_csapi_cc_TpCallEventRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallEventType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_TpAdditionalCallEventCriteria"  */

    
    decode_org_csapi_cc_TpAdditionalCallEventCriteria_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_cc_TpAdditionalCallEventCriteria"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallMonitorMode,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/TpCallNotificationRequest:1.0 */

static void decode_org_csapi_cc_TpCallNotificationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpCallNotificationRequest_CallEventsRequested;
    guint32   i_TpCallNotificationRequest_CallEventsRequested;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cc_TpCallNotificationScope"  */

    

    decode_org_csapi_cc_TpCallNotificationScope_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cc_TpCallNotificationScope"  */

    u_octet4_loop_TpCallNotificationRequest_CallEventsRequested = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallNotificationRequest_CallEventsRequested = %u",u_octet4_loop_TpCallNotificationRequest_CallEventsRequested);
    }

    for (i_TpCallNotificationRequest_CallEventsRequested=0; i_TpCallNotificationRequest_CallEventsRequested < u_octet4_loop_TpCallNotificationRequest_CallEventsRequested; i_TpCallNotificationRequest_CallEventsRequested++) {

        /*  Begin struct "org_csapi_cc_TpCallEventRequest"  */

        

        decode_org_csapi_cc_TpCallEventRequest_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallEventRequest"  */

    }

}

/* Struct = IDL:org/csapi/cc/TpNotificationRequested:1.0 */

static void decode_org_csapi_cc_TpNotificationRequested_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cc_TpCallNotificationRequest"  */

    

    decode_org_csapi_cc_TpCallNotificationRequest_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cc_TpCallNotificationRequest"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNotificationRequested_AssignmentID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cc/TpCallLegConnectionProperties:1.0 */

static void decode_org_csapi_cc_TpCallLegConnectionProperties_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallLegAttachMechanism,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/TpCallEventInfo:1.0 */

static void decode_org_csapi_cc_TpCallEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallEventType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_TpCallAdditionalEventInfo"  */

    
    decode_org_csapi_cc_TpCallAdditionalEventInfo_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_cc_TpCallAdditionalEventInfo"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallMonitorMode,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallEventInfo_CallEventTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/cc/TpNotificationRequestedSetEntry:1.0 */

static void decode_org_csapi_cc_TpNotificationRequestedSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpNotificationRequestedSetEntry_NotificationRequestSet;
    guint32   i_TpNotificationRequestedSetEntry_NotificationRequestSet;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpNotificationRequestedSetEntry_NotificationRequestSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNotificationRequestedSetEntry_NotificationRequestSet = %u",u_octet4_loop_TpNotificationRequestedSetEntry_NotificationRequestSet);
    }

    for (i_TpNotificationRequestedSetEntry_NotificationRequestSet=0; i_TpNotificationRequestedSetEntry_NotificationRequestSet < u_octet4_loop_TpNotificationRequestedSetEntry_NotificationRequestSet; i_TpNotificationRequestedSetEntry_NotificationRequestSet++) {

        /*  Begin struct "org_csapi_cc_TpNotificationRequested"  */

        

        decode_org_csapi_cc_TpNotificationRequested_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpNotificationRequested"  */

    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpNotificationRequestedSetEntry_Final = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/cc/TpCarrier:1.0 */

static void decode_org_csapi_cc_TpCarrier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpCarrier_CarrierID;
    guint32   i_TpCarrier_CarrierID;
    guint8    u_octet1;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpCarrier_CarrierID = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCarrier_CarrierID = %u",u_octet4_loop_TpCarrier_CarrierID);
    }

    for (i_TpCarrier_CarrierID=0; i_TpCarrier_CarrierID < u_octet4_loop_TpCarrier_CarrierID; i_TpCarrier_CarrierID++) {

        u_octet1 = get_CDR_octet(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"TpCarrier_CarrierID = %u",u_octet1);
        }

    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCarrierSelectionField,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/TpCallNotificationInfo:1.0 */

static void decode_org_csapi_cc_TpCallNotificationInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpCallNotificationInfo_CallAppInfo;
    guint32   i_TpCallNotificationInfo_CallAppInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cc_TpCallNotificationReportScope"  */

    

    decode_org_csapi_cc_TpCallNotificationReportScope_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cc_TpCallNotificationReportScope"  */

    u_octet4_loop_TpCallNotificationInfo_CallAppInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallNotificationInfo_CallAppInfo = %u",u_octet4_loop_TpCallNotificationInfo_CallAppInfo);
    }

    for (i_TpCallNotificationInfo_CallAppInfo=0; i_TpCallNotificationInfo_CallAppInfo < u_octet4_loop_TpCallNotificationInfo_CallAppInfo; i_TpCallNotificationInfo_CallAppInfo++) {

        /*  Begin union "org_csapi_cc_TpCallAppInfo"  */

        
        decode_org_csapi_cc_TpCallAppInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_cc_TpCallAppInfo"  */

    }

    /*  Begin struct "org_csapi_cc_TpCallEventInfo"  */

    

    decode_org_csapi_cc_TpCallEventInfo_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cc_TpCallEventInfo"  */

}

/* Struct = IDL:org/csapi/cc/TpCallLegInfoReport:1.0 */

static void decode_org_csapi_cc_TpCallLegInfoReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpCallLegInfoReport_CallAppInfo;
    guint32   i_TpCallLegInfoReport_CallAppInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallLegInfoReport_CallLegInfoType = %i",s_octet4);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallLegInfoReport_CallLegStartTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallLegInfoReport_CallLegConnectedToResourceTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallLegInfoReport_CallLegConnectedToAddressTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallLegInfoReport_CallLegEndTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
    }

    u_octet4_loop_TpCallLegInfoReport_CallAppInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallLegInfoReport_CallAppInfo = %u",u_octet4_loop_TpCallLegInfoReport_CallAppInfo);
    }

    for (i_TpCallLegInfoReport_CallAppInfo=0; i_TpCallLegInfoReport_CallAppInfo < u_octet4_loop_TpCallLegInfoReport_CallAppInfo; i_TpCallLegInfoReport_CallAppInfo++) {

        /*  Begin union "org_csapi_cc_TpCallAppInfo"  */

        
        decode_org_csapi_cc_TpCallAppInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_cc_TpCallAppInfo"  */

    }

}

/* Struct = IDL:org/csapi/cc/TpCallLegProperty:1.0 */

static void decode_org_csapi_cc_TpCallLegProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallLegProperty_CallLegPropertyName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpCallLegProperty_CallLegPropertyValue (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/cc/mpccs/TpMultiPartyCallIdentifier:1.0 */

static void decode_org_csapi_cc_mpccs_TpMultiPartyCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMultiPartyCallIdentifier_CallSessionID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cc/mpccs/TpCallLegIdentifier:1.0 */

static void decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallLegIdentifier_CallLegSessionID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cc/mpccs/TpAppCallLegCallBack:1.0 */

static void decode_org_csapi_cc_mpccs_TpAppCallLegCallBack_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpAppCallLegCallBack_AppCallLegSet;
    guint32   i_TpAppCallLegCallBack_AppCallLegSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    u_octet4_loop_TpAppCallLegCallBack_AppCallLegSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpAppCallLegCallBack_AppCallLegSet = %u",u_octet4_loop_TpAppCallLegCallBack_AppCallLegSet);
    }

    for (i_TpAppCallLegCallBack_AppCallLegSet=0; i_TpAppCallLegCallBack_AppCallLegSet < u_octet4_loop_TpAppCallLegCallBack_AppCallLegSet; i_TpAppCallLegCallBack_AppCallLegSet++) {

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    }

}

/* Struct = IDL:org/csapi/cc/mmccs/TpCallSuperviseVolume:1.0 */

static void decode_org_csapi_cc_mmccs_TpCallSuperviseVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallSuperviseVolume_VolumeQuantity = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallSuperviseVolume_VolumeUnit = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cc/mmccs/TpMediaStreamRequest:1.0 */

static void decode_org_csapi_cc_mmccs_TpMediaStreamRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mmccs_TpMediaStreamDirection,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest"  */

    
    decode_org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallMonitorMode,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mmccs_TpMediaStreamEventType,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/mmccs/TpMediaStream:1.0 */

static void decode_org_csapi_cc_mmccs_TpMediaStream_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mmccs_TpMediaStreamDirection,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest"  */

    
    decode_org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMediaStream_ChannelSessionID = %i",s_octet4);
    }

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


}

/* Struct = IDL:org/csapi/cc/mmccs/TpNotificationMediaRequest:1.0 */

static void decode_org_csapi_cc_mmccs_TpNotificationMediaRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpNotificationMediaRequest_MediaStreamsRequested;
    guint32   i_TpNotificationMediaRequest_MediaStreamsRequested;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cc_TpCallNotificationScope"  */

    

    decode_org_csapi_cc_TpCallNotificationScope_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cc_TpCallNotificationScope"  */

    u_octet4_loop_TpNotificationMediaRequest_MediaStreamsRequested = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNotificationMediaRequest_MediaStreamsRequested = %u",u_octet4_loop_TpNotificationMediaRequest_MediaStreamsRequested);
    }

    for (i_TpNotificationMediaRequest_MediaStreamsRequested=0; i_TpNotificationMediaRequest_MediaStreamsRequested < u_octet4_loop_TpNotificationMediaRequest_MediaStreamsRequested; i_TpNotificationMediaRequest_MediaStreamsRequested++) {

        /*  Begin struct "org_csapi_cc_mmccs_TpMediaStreamRequest"  */

        

        decode_org_csapi_cc_mmccs_TpMediaStreamRequest_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_mmccs_TpMediaStreamRequest"  */

    }

}

/* Struct = IDL:org/csapi/cc/mmccs/TpMediaNotificationRequested:1.0 */

static void decode_org_csapi_cc_mmccs_TpMediaNotificationRequested_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cc_mmccs_TpNotificationMediaRequest"  */

    

    decode_org_csapi_cc_mmccs_TpNotificationMediaRequest_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cc_mmccs_TpNotificationMediaRequest"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMediaNotificationRequested_AssignmentID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cc/mmccs/TpMultiMediaCallIdentifier:1.0 */

static void decode_org_csapi_cc_mmccs_TpMultiMediaCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMultiMediaCallIdentifier_MMCallSessionID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cc/mmccs/TpMultiMediaCallLegIdentifier:1.0 */

static void decode_org_csapi_cc_mmccs_TpMultiMediaCallLegIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMultiMediaCallLegIdentifier_MMCallLegSessionID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cc/mmccs/TpAppMultiMediaCallLegCallBack:1.0 */

static void decode_org_csapi_cc_mmccs_TpAppMultiMediaCallLegCallBack_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpAppMultiMediaCallLegCallBack_AppCallLegSet;
    guint32   i_TpAppMultiMediaCallLegCallBack_AppCallLegSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    u_octet4_loop_TpAppMultiMediaCallLegCallBack_AppCallLegSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpAppMultiMediaCallLegCallBack_AppCallLegSet = %u",u_octet4_loop_TpAppMultiMediaCallLegCallBack_AppCallLegSet);
    }

    for (i_TpAppMultiMediaCallLegCallBack_AppCallLegSet=0; i_TpAppMultiMediaCallLegCallBack_AppCallLegSet < u_octet4_loop_TpAppMultiMediaCallLegCallBack_AppCallLegSet; i_TpAppMultiMediaCallLegCallBack_AppCallLegSet++) {

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpMonoMediaConfPolicy:1.0 */

static void decode_org_csapi_cc_cccs_TpMonoMediaConfPolicy_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpMonoMediaConfPolicy_JoinAllowed = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpJoinEventInfo:1.0 */

static void decode_org_csapi_cc_cccs_TpJoinEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpJoinEventInfo_CallAppInfo;
    guint32   i_TpJoinEventInfo_CallAppInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet4_loop_TpJoinEventInfo_CallAppInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpJoinEventInfo_CallAppInfo = %u",u_octet4_loop_TpJoinEventInfo_CallAppInfo);
    }

    for (i_TpJoinEventInfo_CallAppInfo=0; i_TpJoinEventInfo_CallAppInfo < u_octet4_loop_TpJoinEventInfo_CallAppInfo; i_TpJoinEventInfo_CallAppInfo++) {

        /*  Begin union "org_csapi_cc_TpCallAppInfo"  */

        
        decode_org_csapi_cc_TpCallAppInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_cc_TpCallAppInfo"  */

    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpConfSearchCriteria:1.0 */

static void decode_org_csapi_cc_cccs_TpConfSearchCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpConfSearchCriteria_StartSearch (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpConfSearchCriteria_StopSearch (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpConfSearchCriteria_RequestedResources = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpConfSearchCriteria_RequestedDuration = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpConfSearchResult:1.0 */

static void decode_org_csapi_cc_cccs_TpConfSearchResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    guint32   u_octet4;
    gchar   *seq = NULL;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpConfSearchResult_MatchFound = %u",u_octet1);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpConfSearchResult_ActualStartTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpConfSearchResult_ActualResources = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpConfSearchResult_ActualDuration = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpMultiMediaConfPolicy:1.0 */

static void decode_org_csapi_cc_cccs_TpMultiMediaConfPolicy_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpMultiMediaConfPolicy_JoinAllowed = %u",u_octet1);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMultiMediaConfPolicy_MediaAllowed = %i",s_octet4);
    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpMultiMediaConfPolicy_Chaired = %u",u_octet1);
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_cccs_TpVideoHandlingType,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpResourceReservation:1.0 */

static void decode_org_csapi_cc_cccs_TpResourceReservation_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpResourceReservation_ReservationID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpConfCallIdentifier:1.0 */

static void decode_org_csapi_cc_cccs_TpConfCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpConfCallIdentifier_ConfCallSessionID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpSubConfCallIdentifier:1.0 */

static void decode_org_csapi_cc_cccs_TpSubConfCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpSubConfCallIdentifier_SubConfCallSessionID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/ui/TpUIIdentifier:1.0 */

static void decode_org_csapi_ui_TpUIIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUIIdentifier_UserInteractionSessionID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/ui/TpUICallIdentifier:1.0 */

static void decode_org_csapi_ui_TpUICallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUICallIdentifier_UserInteractionSessionID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/mm/TpLocationResponseTime:1.0 */

static void decode_org_csapi_mm_TpLocationResponseTime_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpLocationResponseIndicator,"Unknown Enum Value"));
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationResponseTime_TimerValue = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/mm/TpLocationTrigger:1.0 */

static void decode_org_csapi_mm_TpLocationTrigger_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gfloat    my_float;
    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationTrigger_Longitude = %.6e",my_float);
    }

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationTrigger_Latitude = %.6e",my_float);
    }

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationTrigger_AreaSemiMajor = %.6e",my_float);
    }

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationTrigger_AreaSemiMinor = %.6e",my_float);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationTrigger_AngleOfSemiMajor = %i",s_octet4);
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpLocationTriggerCriteria,"Unknown Enum Value"));
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationTrigger_ReportingInterval = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/mm/TpLocationRequest:1.0 */

static void decode_org_csapi_mm_TpLocationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gfloat    my_float;
    guint8    u_octet1;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationRequest_RequestedAccuracy = %.6e",my_float);
    }

    /*  Begin struct "org_csapi_mm_TpLocationResponseTime"  */

    

    decode_org_csapi_mm_TpLocationResponseTime_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_mm_TpLocationResponseTime"  */

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpLocationRequest_AltitudeRequested = %u",u_octet1);
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpLocationType,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpLocationPriority,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpLocationRequest_RequestedLocationMethod (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/mm/TpGeographicalPosition:1.0 */

static void decode_org_csapi_mm_TpGeographicalPosition_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gfloat    my_float;
    guint32   u_octet4;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_Longitude = %.6e",my_float);
    }

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_Latitude = %.6e",my_float);
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpLocationUncertaintyShape,"Unknown Enum Value"));
    }

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_UncertaintyInnerSemiMajor = %.6e",my_float);
    }

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_UncertaintyOuterSemiMajor = %.6e",my_float);
    }

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_UncertaintyInnerSemiMinor = %.6e",my_float);
    }

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_UncertaintyOuterSemiMinor = %.6e",my_float);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_AngleOfSemiMajor = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_SegmentStartAngle = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_SegmentEndAngle = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/mm/TpMobilityStopAssignmentData:1.0 */

static void decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    guint32   u_octet4_loop_TpMobilityStopAssignmentData_Users;
    guint32   i_TpMobilityStopAssignmentData_Users;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMobilityStopAssignmentData_AssignmentId = %i",s_octet4);
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityStopScope,"Unknown Enum Value"));
    }

    u_octet4_loop_TpMobilityStopAssignmentData_Users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMobilityStopAssignmentData_Users = %u",u_octet4_loop_TpMobilityStopAssignmentData_Users);
    }

    for (i_TpMobilityStopAssignmentData_Users=0; i_TpMobilityStopAssignmentData_Users < u_octet4_loop_TpMobilityStopAssignmentData_Users; i_TpMobilityStopAssignmentData_Users++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

    }

}

/* Struct = IDL:org/csapi/mm/TpUlExtendedData:1.0 */

static void decode_org_csapi_mm_TpUlExtendedData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint8    u_octet1;
    gfloat    my_float;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_mm_TpGeographicalPosition"  */

    

    decode_org_csapi_mm_TpGeographicalPosition_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_mm_TpGeographicalPosition"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpTerminalType,"Unknown Enum Value"));
    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUlExtendedData_AltitudePresent = %u",u_octet1);
    }

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUlExtendedData_Altitude = %.6e",my_float);
    }

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUlExtendedData_UncertaintyAltitude = %.6e",my_float);
    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUlExtendedData_TimestampPresent = %u",u_octet1);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUlExtendedData_Timestamp (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUlExtendedData_UsedLocationMethod (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/mm/TpUserLocation:1.0 */

static void decode_org_csapi_mm_TpUserLocation_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_mm_TpGeographicalPosition"  */

    

    decode_org_csapi_mm_TpGeographicalPosition_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_mm_TpGeographicalPosition"  */

}

/* Struct = IDL:org/csapi/mm/TpUserLocationExtended:1.0 */

static void decode_org_csapi_mm_TpUserLocationExtended_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_TpUserLocationExtended_Locations;
    guint32   i_TpUserLocationExtended_Locations;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
    }

    u_octet4_loop_TpUserLocationExtended_Locations = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpUserLocationExtended_Locations = %u",u_octet4_loop_TpUserLocationExtended_Locations);
    }

    for (i_TpUserLocationExtended_Locations=0; i_TpUserLocationExtended_Locations < u_octet4_loop_TpUserLocationExtended_Locations; i_TpUserLocationExtended_Locations++) {

        /*  Begin struct "org_csapi_mm_TpUlExtendedData"  */

        

        decode_org_csapi_mm_TpUlExtendedData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpUlExtendedData"  */

    }

}

/* Struct = IDL:org/csapi/mm/TpLocationTriggerCamel:1.0 */

static void decode_org_csapi_mm_TpLocationTriggerCamel_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpLocationTriggerCamel_UpdateInsideVlr = %u",u_octet1);
    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpLocationTriggerCamel_UpdateOutsideVlr = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/mm/TpUserLocationCamel:1.0 */

static void decode_org_csapi_mm_TpUserLocationCamel_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint8    u_octet1;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationCamel_GeographicalPositionPresent = %u",u_octet1);
    }

    /*  Begin struct "org_csapi_mm_TpGeographicalPosition"  */

    

    decode_org_csapi_mm_TpGeographicalPosition_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_mm_TpGeographicalPosition"  */

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationCamel_TimestampPresent = %u",u_octet1);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserLocationCamel_Timestamp (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationCamel_VlrNumberPresent = %u",u_octet1);
    }

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationCamel_LocationNumberPresent = %u",u_octet1);
    }

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationCamel_CellIdOrLaiPresent = %u",u_octet1);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserLocationCamel_CellIdOrLai (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/mm/TpUserLocationEmergencyRequest:1.0 */

static void decode_org_csapi_mm_TpUserLocationEmergencyRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergencyRequest_UserAddressPresent = %u",u_octet1);
    }

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergencyRequest_NaEsrdPresent = %u",u_octet1);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserLocationEmergencyRequest_NaEsrd (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergencyRequest_NaEsrkPresent = %u",u_octet1);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserLocationEmergencyRequest_NaEsrk (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergencyRequest_ImeiPresent = %u",u_octet1);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserLocationEmergencyRequest_Imei (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin struct "org_csapi_mm_TpLocationRequest"  */

    

    decode_org_csapi_mm_TpLocationRequest_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_mm_TpLocationRequest"  */

}

/* Struct = IDL:org/csapi/mm/TpUserLocationEmergency:1.0 */

static void decode_org_csapi_mm_TpUserLocationEmergency_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint8    u_octet1;
    gchar   *seq = NULL;
    gfloat    my_float;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergency_UserIdPresent = %u",u_octet1);
    }

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergency_NaEsrdPresent = %u",u_octet1);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserLocationEmergency_NaEsrd (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergency_NaEsrkPresent = %u",u_octet1);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserLocationEmergency_NaEsrk (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergency_ImeiPresent = %u",u_octet1);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserLocationEmergency_Imei (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpUserLocationEmergencyTrigger,"Unknown Enum Value"));
    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergency_GeographicalPositionPresent = %u",u_octet1);
    }

    /*  Begin struct "org_csapi_mm_TpGeographicalPosition"  */

    

    decode_org_csapi_mm_TpGeographicalPosition_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_mm_TpGeographicalPosition"  */

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergency_AltitudePresent = %u",u_octet1);
    }

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserLocationEmergency_Altitude = %.6e",my_float);
    }

    my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserLocationEmergency_UncertaintyAltitude = %.6e",my_float);
    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergency_TimestampPresent = %u",u_octet1);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserLocationEmergency_Timestamp (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserLocationEmergency_UsedLocationMethod (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/mm/TpUserStatus:1.0 */

static void decode_org_csapi_mm_TpUserStatus_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpUserStatusIndicator,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpTerminalType,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/mm/TpTriggeredStatusRequest:1.0 */

static void decode_org_csapi_mm_TpTriggeredStatusRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpTriggeredStatusRequest_Users;
    guint32   i_TpTriggeredStatusRequest_Users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpTriggeredStatusRequest_Users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpTriggeredStatusRequest_Users = %u",u_octet4_loop_TpTriggeredStatusRequest_Users);
    }

    for (i_TpTriggeredStatusRequest_Users=0; i_TpTriggeredStatusRequest_Users < u_octet4_loop_TpTriggeredStatusRequest_Users; i_TpTriggeredStatusRequest_Users++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpTriggeredStatusRequest_AssignmentID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/mm/TpTriggeredStatusRequestSetEntry:1.0 */

static void decode_org_csapi_mm_TpTriggeredStatusRequestSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpTriggeredStatusRequestSetEntry_Requests;
    guint32   i_TpTriggeredStatusRequestSetEntry_Requests;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpTriggeredStatusRequestSetEntry_Requests = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpTriggeredStatusRequestSetEntry_Requests = %u",u_octet4_loop_TpTriggeredStatusRequestSetEntry_Requests);
    }

    for (i_TpTriggeredStatusRequestSetEntry_Requests=0; i_TpTriggeredStatusRequestSetEntry_Requests < u_octet4_loop_TpTriggeredStatusRequestSetEntry_Requests; i_TpTriggeredStatusRequestSetEntry_Requests++) {

        /*  Begin struct "org_csapi_mm_TpTriggeredStatusRequest"  */

        

        decode_org_csapi_mm_TpTriggeredStatusRequest_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpTriggeredStatusRequest"  */

    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpTriggeredStatusRequestSetEntry_Final = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/mm/TpPeriodicLocationRequest:1.0 */

static void decode_org_csapi_mm_TpPeriodicLocationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPeriodicLocationRequest_Users;
    guint32   i_TpPeriodicLocationRequest_Users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPeriodicLocationRequest_Users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPeriodicLocationRequest_Users = %u",u_octet4_loop_TpPeriodicLocationRequest_Users);
    }

    for (i_TpPeriodicLocationRequest_Users=0; i_TpPeriodicLocationRequest_Users < u_octet4_loop_TpPeriodicLocationRequest_Users; i_TpPeriodicLocationRequest_Users++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

    }

    /*  Begin struct "org_csapi_mm_TpLocationRequest"  */

    

    decode_org_csapi_mm_TpLocationRequest_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_mm_TpLocationRequest"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPeriodicLocationRequest_ReportingInterval = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPeriodicLocationRequest_AssignmentID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/mm/TpPeriodicLocationRequestSetEntry:1.0 */

static void decode_org_csapi_mm_TpPeriodicLocationRequestSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPeriodicLocationRequestSetEntry_Requests;
    guint32   i_TpPeriodicLocationRequestSetEntry_Requests;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPeriodicLocationRequestSetEntry_Requests = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPeriodicLocationRequestSetEntry_Requests = %u",u_octet4_loop_TpPeriodicLocationRequestSetEntry_Requests);
    }

    for (i_TpPeriodicLocationRequestSetEntry_Requests=0; i_TpPeriodicLocationRequestSetEntry_Requests < u_octet4_loop_TpPeriodicLocationRequestSetEntry_Requests; i_TpPeriodicLocationRequestSetEntry_Requests++) {

        /*  Begin struct "org_csapi_mm_TpPeriodicLocationRequest"  */

        

        decode_org_csapi_mm_TpPeriodicLocationRequest_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpPeriodicLocationRequest"  */

    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpPeriodicLocationRequestSetEntry_Final = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/mm/TpTriggeredLocationRequest:1.0 */

static void decode_org_csapi_mm_TpTriggeredLocationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpTriggeredLocationRequest_Users;
    guint32   i_TpTriggeredLocationRequest_Users;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpTriggeredLocationRequest_Users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpTriggeredLocationRequest_Users = %u",u_octet4_loop_TpTriggeredLocationRequest_Users);
    }

    for (i_TpTriggeredLocationRequest_Users=0; i_TpTriggeredLocationRequest_Users < u_octet4_loop_TpTriggeredLocationRequest_Users; i_TpTriggeredLocationRequest_Users++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

    }

    /*  Begin struct "org_csapi_mm_TpLocationRequest"  */

    

    decode_org_csapi_mm_TpLocationRequest_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_mm_TpLocationRequest"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpTriggeredLocationRequest_AssignmentID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/mm/TpTriggeredLocationRequestSetEntry:1.0 */

static void decode_org_csapi_mm_TpTriggeredLocationRequestSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpTriggeredLocationRequestSetEntry_Requests;
    guint32   i_TpTriggeredLocationRequestSetEntry_Requests;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpTriggeredLocationRequestSetEntry_Requests = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpTriggeredLocationRequestSetEntry_Requests = %u",u_octet4_loop_TpTriggeredLocationRequestSetEntry_Requests);
    }

    for (i_TpTriggeredLocationRequestSetEntry_Requests=0; i_TpTriggeredLocationRequestSetEntry_Requests < u_octet4_loop_TpTriggeredLocationRequestSetEntry_Requests; i_TpTriggeredLocationRequestSetEntry_Requests++) {

        /*  Begin struct "org_csapi_mm_TpTriggeredLocationRequest"  */

        

        decode_org_csapi_mm_TpTriggeredLocationRequest_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mm_TpTriggeredLocationRequest"  */

    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpTriggeredLocationRequestSetEntry_Final = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/mm/TpUserStatusIndicatorExtended:1.0 */

static void decode_org_csapi_mm_TpUserStatusIndicatorExtended_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpUserStatusIndicator,"Unknown Enum Value"));
    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserStatusIndicatorExtended_PDPContextActive = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/mm/TpUserInfo:1.0 */

static void decode_org_csapi_mm_TpUserInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserInfo_UserName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserInfo_Password (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/mm/TpNetworkStatusIndicator:1.0 */

static void decode_org_csapi_mm_TpNetworkStatusIndicator_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNetworkStatusIndicator_CountryCode (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNetworkStatusIndicator_MobileNetworkCode (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpAccessTechnology,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpRoamingStatus,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/mm/TpUserStatusExtended:1.0 */

static void decode_org_csapi_mm_TpUserStatusExtended_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserStatusExtended_UserID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_mm_TpUserStatusIndicatorExtended"  */

    

    decode_org_csapi_mm_TpUserStatusIndicatorExtended_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_mm_TpUserStatusIndicatorExtended"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpTerminalType,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpAuthStatusIndicator,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_mm_TpNetworkStatusIndicator"  */

    

    decode_org_csapi_mm_TpNetworkStatusIndicator_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_mm_TpNetworkStatusIndicator"  */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserStatusExtended_UserIPAddress (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserStatusExtended_UserMSISDN (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin struct "org_csapi_mm_TpUserInfo"  */

    

    decode_org_csapi_mm_TpUserInfo_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_mm_TpUserInfo"  */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserStatusExtended_UserConnectionID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpUserStatusExtended_AccessPointName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/mm/TpBindingNotificationCriteria:1.0 */

static void decode_org_csapi_mm_TpBindingNotificationCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4_loop_TpBindingNotificationCriteria_ContactAddressSet;
    guint32   i_TpBindingNotificationCriteria_ContactAddressSet;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBindingNotificationCriteria_NotificationCriteriaType = %i",s_octet4);
    }

    u_octet4_loop_TpBindingNotificationCriteria_ContactAddressSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpBindingNotificationCriteria_ContactAddressSet = %u",u_octet4_loop_TpBindingNotificationCriteria_ContactAddressSet);
    }

    for (i_TpBindingNotificationCriteria_ContactAddressSet=0; i_TpBindingNotificationCriteria_ContactAddressSet < u_octet4_loop_TpBindingNotificationCriteria_ContactAddressSet; i_TpBindingNotificationCriteria_ContactAddressSet++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

    }

}

/* Struct = IDL:org/csapi/termcap/TpTerminalCapabilities:1.0 */

static void decode_org_csapi_termcap_TpTerminalCapabilities_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpTerminalCapabilities_TerminalCapabilities (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpTerminalCapabilities_StatusCode = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/termcap/TpTerminalCapabilityScope:1.0 */

static void decode_org_csapi_termcap_TpTerminalCapabilityScope_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_termcap_TpTerminalCapabilityScopeType,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpTerminalCapabilityScope_Scope (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/dsc/TpChargePerVolume:1.0 */

static void decode_org_csapi_dsc_TpChargePerVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargePerVolume_InitialCharge = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargePerVolume_CurrentChargePerKilobyte = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargePerVolume_NextChargePerKilobyte = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionChargePlan:1.0 */

static void decode_org_csapi_dsc_TpDataSessionChargePlan_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin union "org_csapi_dsc_TpDataSessionChargeOrder"  */

    
    decode_org_csapi_dsc_TpDataSessionChargeOrder_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_dsc_TpDataSessionChargeOrder"  */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpDataSessionChargePlan_Currency (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpDataSessionChargePlan_AdditionalInfo (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionError:1.0 */

static void decode_org_csapi_dsc_TpDataSessionError_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpDataSessionError_ErrorTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionErrorType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_dsc_TpDataSessionAdditionalErrorInfo"  */

    
    decode_org_csapi_dsc_TpDataSessionAdditionalErrorInfo_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_dsc_TpDataSessionAdditionalErrorInfo"  */

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionEventCriteria:1.0 */

static void decode_org_csapi_dsc_TpDataSessionEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddressRange"  */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddressRange"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionEventCriteria_DataSessionEventName = %i",s_octet4);
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionMonitorMode,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionEventInfo:1.0 */

static void decode_org_csapi_dsc_TpDataSessionEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionEventInfo_DataSessionEventName = %i",s_octet4);
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionMonitorMode,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpDataSessionQosClass,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionReleaseCause:1.0 */

static void decode_org_csapi_dsc_TpDataSessionReleaseCause_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionReleaseCause_Value = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionReleaseCause_Location = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionReport:1.0 */

static void decode_org_csapi_dsc_TpDataSessionReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionMonitorMode,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpDataSessionReport_DataSessionEventTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionReportType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_dsc_TpDataSessionAdditionalReportInfo"  */

    
    decode_org_csapi_dsc_TpDataSessionAdditionalReportInfo_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_dsc_TpDataSessionAdditionalReportInfo"  */

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionReportRequest:1.0 */

static void decode_org_csapi_dsc_TpDataSessionReportRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionMonitorMode,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionReportType,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionSuperviseVolume:1.0 */

static void decode_org_csapi_dsc_TpDataSessionSuperviseVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionSuperviseVolume_VolumeQuantity = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionSuperviseVolume_VolumeUnit = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionEventCriteriaResult:1.0 */

static void decode_org_csapi_dsc_TpDataSessionEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

    

    decode_org_csapi_dsc_TpDataSessionEventCriteria_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionEventCriteriaResult_AssignmentID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionIdentifier:1.0 */

static void decode_org_csapi_dsc_TpDataSessionIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionIdentifier_DataSessionID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/gms/TpGMSNewMessageArrivedInfo:1.0 */

static void decode_org_csapi_gms_TpGMSNewMessageArrivedInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpGMSNewMessageArrivedInfo_FolderID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpGMSNewMessageArrivedInfo_MessageID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGMSNewMessageArrivedInfo_NumberOfProperties = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/gms/TpGMSNewMessageArrivedCriteria:1.0 */

static void decode_org_csapi_gms_TpGMSNewMessageArrivedCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpGMSNewMessageArrivedCriteria_AuthenticationInfo (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/gms/TpMailboxIdentifier:1.0 */

static void decode_org_csapi_gms_TpMailboxIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMailboxIdentifier_SessionID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/gms/TpMailboxFolderIdentifier:1.0 */

static void decode_org_csapi_gms_TpMailboxFolderIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMailboxFolderIdentifier_SessionID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagTimePeriod:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagTimePeriod_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagTimePeriod_duration = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagTimeOfDay:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagTimeOfDay_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagTimeOfDay_name (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagTimeOfDay_description (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagTimeOfDay_value (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagString:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagString_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagString_name (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagString_description (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagString_value (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagMonth:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagMonth_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagMonth_name (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagMonth_description (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagMonth_value = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagInt:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagInt_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagInt_name (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagInt_description (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagInt_value = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagDir:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagDir_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagDir_name (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagDir_description (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTrafficDirection,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagDayOfWeek:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagDayOfWeek_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagDayOfWeek_name (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagDayOfWeek_description (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagDayOfWeek_value = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagDateTime:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagDateTime_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagDateTime_name (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagDateTime_description (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagDateTime_value (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/cm/TpLossDescriptor:1.0 */

static void decode_org_csapi_cm_TpLossDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagString"  */

    

    decode_org_csapi_cm_TpNameDescrpTagString_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagString"  */

}

/* Struct = IDL:org/csapi/cm/TpLoadDescriptor:1.0 */

static void decode_org_csapi_cm_TpLoadDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagString"  */

    

    decode_org_csapi_cm_TpNameDescrpTagString_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagString"  */

}

/* Struct = IDL:org/csapi/cm/TpJitterDescriptor:1.0 */

static void decode_org_csapi_cm_TpJitterDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagString"  */

    

    decode_org_csapi_cm_TpNameDescrpTagString_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagString"  */

}

/* Struct = IDL:org/csapi/cm/TpEndpoint:1.0 */

static void decode_org_csapi_cm_TpEndpoint_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpSiteOrSap,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpEndpoint_id (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/cm/TpDelayDescriptor:1.0 */

static void decode_org_csapi_cm_TpDelayDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagString"  */

    

    decode_org_csapi_cm_TpNameDescrpTagString_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagString"  */

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagExcessLoadAction:1.0 */

static void decode_org_csapi_cm_TpNameDescrpTagExcessLoadAction_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagExcessLoadAction_name (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNameDescrpTagExcessLoadAction_description (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpAction,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cm/TpValidityInfo:1.0 */

static void decode_org_csapi_cm_TpValidityInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagDateTime"  */

    

    decode_org_csapi_cm_TpNameDescrpTagDateTime_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagDateTime"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagTimePeriod"  */

    

    decode_org_csapi_cm_TpNameDescrpTagTimePeriod_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagTimePeriod"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagTimeOfDay"  */

    

    decode_org_csapi_cm_TpNameDescrpTagTimeOfDay_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagTimeOfDay"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagTimePeriod"  */

    

    decode_org_csapi_cm_TpNameDescrpTagTimePeriod_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagTimePeriod"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagDayOfWeek"  */

    

    decode_org_csapi_cm_TpNameDescrpTagDayOfWeek_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagDayOfWeek"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagMonth"  */

    

    decode_org_csapi_cm_TpNameDescrpTagMonth_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagMonth"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagString"  */

    

    decode_org_csapi_cm_TpNameDescrpTagString_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagString"  */

}

/* Struct = IDL:org/csapi/cm/TpProvisionedQoSInfo:1.0 */

static void decode_org_csapi_cm_TpProvisionedQoSInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cm_TpDelayDescriptor"  */

    

    decode_org_csapi_cm_TpDelayDescriptor_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpDelayDescriptor"  */

    /*  Begin struct "org_csapi_cm_TpLossDescriptor"  */

    

    decode_org_csapi_cm_TpLossDescriptor_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpLossDescriptor"  */

    /*  Begin struct "org_csapi_cm_TpJitterDescriptor"  */

    

    decode_org_csapi_cm_TpJitterDescriptor_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpJitterDescriptor"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagExcessLoadAction"  */

    

    decode_org_csapi_cm_TpNameDescrpTagExcessLoadAction_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagExcessLoadAction"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagString"  */

    

    decode_org_csapi_cm_TpNameDescrpTagString_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagString"  */

}

/* Struct = IDL:org/csapi/cm/TpPipeQoSInfo:1.0 */

static void decode_org_csapi_cm_TpPipeQoSInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagDir"  */

    

    decode_org_csapi_cm_TpNameDescrpTagDir_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagDir"  */

    /*  Begin struct "org_csapi_cm_TpEndpoint"  */

    

    decode_org_csapi_cm_TpEndpoint_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpEndpoint"  */

    /*  Begin struct "org_csapi_cm_TpEndpoint"  */

    

    decode_org_csapi_cm_TpEndpoint_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpEndpoint"  */

    /*  Begin struct "org_csapi_cm_TpLoadDescriptor"  */

    

    decode_org_csapi_cm_TpLoadDescriptor_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpLoadDescriptor"  */

    /*  Begin struct "org_csapi_cm_TpLoadDescriptor"  */

    

    decode_org_csapi_cm_TpLoadDescriptor_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpLoadDescriptor"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagString"  */

    

    decode_org_csapi_cm_TpNameDescrpTagString_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cm_TpNameDescrpTagString"  */

}

/* Struct = IDL:org/csapi/cm/TpDsCodepoint:1.0 */

static void decode_org_csapi_cm_TpDsCodepoint_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpDsCodepoint_match (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpDsCodepoint_mask (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/cm/TpIPSubnet:1.0 */

static void decode_org_csapi_cm_TpIPSubnet_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpIPSubnet_subnetNumber (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpIPSubnet_subnetMask (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpIPv4AddType,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpIPVersion,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/am/TpBalanceInfo:1.0 */

static void decode_org_csapi_am_TpBalanceInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpBalanceInfo_Currency (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBalanceInfo_ValuePartA = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBalanceInfo_ValuePartB = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBalanceInfo_Exponent = %i",s_octet4);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpBalanceInfo_AdditionalInfo (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/am/TpChargingEventInfo:1.0 */

static void decode_org_csapi_am_TpChargingEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpChargingEventName,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_am_TpBalanceInfo"  */

    

    decode_org_csapi_am_TpBalanceInfo_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_am_TpBalanceInfo"  */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpChargingEventInfo_ChargingEventTime (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/am/TpBalance:1.0 */

static void decode_org_csapi_am_TpBalance_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpBalanceQueryError,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_am_TpBalanceInfo"  */

    

    decode_org_csapi_am_TpBalanceInfo_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_am_TpBalanceInfo"  */

}

/* Struct = IDL:org/csapi/am/TpTransactionHistory:1.0 */

static void decode_org_csapi_am_TpTransactionHistory_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpTransactionHistory_TransactionID = %i",s_octet4);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpTransactionHistory_TimeStamp (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpTransactionHistory_AdditionalInfo (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/am/TpChargingEventCriteria:1.0 */

static void decode_org_csapi_am_TpChargingEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpChargingEventCriteria_ChargingEvents;
    guint32   i_TpChargingEventCriteria_ChargingEvents;
    guint32   u_octet4;
    guint32   u_octet4_loop_TpChargingEventCriteria_Users;
    guint32   i_TpChargingEventCriteria_Users;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpChargingEventCriteria_ChargingEvents = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpChargingEventCriteria_ChargingEvents = %u",u_octet4_loop_TpChargingEventCriteria_ChargingEvents);
    }

    for (i_TpChargingEventCriteria_ChargingEvents=0; i_TpChargingEventCriteria_ChargingEvents < u_octet4_loop_TpChargingEventCriteria_ChargingEvents; i_TpChargingEventCriteria_ChargingEvents++) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpChargingEventName,"Unknown Enum Value"));
        }

    }

    u_octet4_loop_TpChargingEventCriteria_Users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpChargingEventCriteria_Users = %u",u_octet4_loop_TpChargingEventCriteria_Users);
    }

    for (i_TpChargingEventCriteria_Users=0; i_TpChargingEventCriteria_Users < u_octet4_loop_TpChargingEventCriteria_Users; i_TpChargingEventCriteria_Users++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

    }

}

/* Struct = IDL:org/csapi/am/TpChargingEventCriteriaResult:1.0 */

static void decode_org_csapi_am_TpChargingEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_am_TpChargingEventCriteria"  */

    

    decode_org_csapi_am_TpChargingEventCriteria_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_am_TpChargingEventCriteria"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargingEventCriteriaResult_AssignmentID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/am/TpBalanceExpiryDate:1.0 */

static void decode_org_csapi_am_TpBalanceExpiryDate_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpBalanceQueryError,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpBalanceExpiryDate_ExpiryDate (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/am/TpVoucher:1.0 */

static void decode_org_csapi_am_TpVoucher_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpVoucher_VoucherID = %i",s_octet4);
    }

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_am_TpBalanceInfo"  */

    

    decode_org_csapi_am_TpBalanceInfo_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_am_TpBalanceInfo"  */

}

/* Struct = IDL:org/csapi/cs/TpMerchantAccountID:1.0 */

static void decode_org_csapi_cs_TpMerchantAccountID_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpMerchantAccountID_MerchantID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMerchantAccountID_AccountID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cs/TpCorrelationID:1.0 */

static void decode_org_csapi_cs_TpCorrelationID_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCorrelationID_CorrelationID = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCorrelationID_CorrelationType = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cs/TpAmount:1.0 */

static void decode_org_csapi_cs_TpAmount_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpAmount_Number = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpAmount_Exponent = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cs/TpChargingPrice:1.0 */

static void decode_org_csapi_cs_TpChargingPrice_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpChargingPrice_Currency (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin struct "org_csapi_cs_TpAmount"  */

    

    decode_org_csapi_cs_TpAmount_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cs_TpAmount"  */

}

/* Struct = IDL:org/csapi/cs/TpVolume:1.0 */

static void decode_org_csapi_cs_TpVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cs_TpAmount"  */

    

    decode_org_csapi_cs_TpAmount_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cs_TpAmount"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpVolume_Unit = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cs/TpChargingSessionID:1.0 */

static void decode_org_csapi_cs_TpChargingSessionID_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargingSessionID_ChargingSessionID = %i",s_octet4);
    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargingSessionID_RequestNumberFirstRequest = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/cs/TpPriceVolume:1.0 */

static void decode_org_csapi_cs_TpPriceVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

    

    decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cs_TpChargingPrice"  */

    /*  Begin struct "org_csapi_cs_TpVolume"  */

    

    decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_cs_TpVolume"  */

}

/* Struct = IDL:org/csapi/cs/TpApplicationDescription:1.0 */

static void decode_org_csapi_cs_TpApplicationDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpApplicationDescription_AppInformation;
    guint32   i_TpApplicationDescription_AppInformation;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpApplicationDescription_Text (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpApplicationDescription_AppInformation = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpApplicationDescription_AppInformation = %u",u_octet4_loop_TpApplicationDescription_AppInformation);
    }

    for (i_TpApplicationDescription_AppInformation=0; i_TpApplicationDescription_AppInformation < u_octet4_loop_TpApplicationDescription_AppInformation; i_TpApplicationDescription_AppInformation++) {

        /*  Begin union "org_csapi_cs_TpAppInformation"  */

        
        decode_org_csapi_cs_TpAppInformation_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_cs_TpAppInformation"  */

    }

}

/* Struct = IDL:org/csapi/cs/TpChargingParameter:1.0 */

static void decode_org_csapi_cs_TpChargingParameter_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargingParameter_ParameterID = %i",s_octet4);
    }

    /*  Begin union "org_csapi_cs_TpChargingParameterValue"  */

    
    decode_org_csapi_cs_TpChargingParameterValue_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_cs_TpChargingParameterValue"  */

}

/* Struct = IDL:org/csapi/policy/TpPolicyEvent:1.0 */

static void decode_org_csapi_policy_TpPolicyEvent_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPolicyEvent_Attributes;
    guint32   i_TpPolicyEvent_Attributes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPolicyEvent_EventID = %i",s_octet4);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPolicyEvent_TimeGenerated (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpPolicyEvent_Attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyEvent_Attributes = %u",u_octet4_loop_TpPolicyEvent_Attributes);
    }

    for (i_TpPolicyEvent_Attributes=0; i_TpPolicyEvent_Attributes < u_octet4_loop_TpPolicyEvent_Attributes; i_TpPolicyEvent_Attributes++) {

        /*  Begin struct "org_csapi_TpAttribute"  */

        

        decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAttribute"  */

    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPolicyEvent_EventDefinitionName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPolicyEvent_EventDomainName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/policy/TpPolicyNameValue:1.0 */

static void decode_org_csapi_policy_TpPolicyNameValue_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPolicyNameValue_Name (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    get_CDR_any(tvb,tree,offset,stream_is_big_endian, boundary, header);

}

/* Struct = IDL:org/csapi/policy/TpPolicyType/TpPolicyRecordType:1.0 */

static void decode_org_csapi_policy_TpPolicyType_TpPolicyRecordType_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPolicyRecordType_Names;
    guint32   i_TpPolicyRecordType_Names;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPolicyRecordType_Types;
    guint32   i_TpPolicyRecordType_Types;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPolicyRecordType_Names = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyRecordType_Names = %u",u_octet4_loop_TpPolicyRecordType_Names);
    }

    for (i_TpPolicyRecordType_Names=0; i_TpPolicyRecordType_Names < u_octet4_loop_TpPolicyRecordType_Names; i_TpPolicyRecordType_Names++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPolicyRecordType_Names (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPolicyRecordType_Types = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyRecordType_Types = %u",u_octet4_loop_TpPolicyRecordType_Types);
    }

    for (i_TpPolicyRecordType_Types=0; i_TpPolicyRecordType_Types < u_octet4_loop_TpPolicyRecordType_Types; i_TpPolicyRecordType_Types++) {

        /*  Begin union "org_csapi_policy_TpPolicyType"  */

        
        decode_org_csapi_policy_TpPolicyType_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_policy_TpPolicyType"  */

    }

}

/* Struct = IDL:org/csapi/policy/TpPolicyType/TpPolicyListType:1.0 */

static void decode_org_csapi_policy_TpPolicyType_TpPolicyListType_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPolicyListType_ElementType;
    guint32   i_TpPolicyListType_ElementType;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPolicyListType_ElementType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyListType_ElementType = %u",u_octet4_loop_TpPolicyListType_ElementType);
    }

    for (i_TpPolicyListType_ElementType=0; i_TpPolicyListType_ElementType < u_octet4_loop_TpPolicyListType_ElementType; i_TpPolicyListType_ElementType++) {

        /*  Begin union "org_csapi_policy_TpPolicyType"  */

        
        decode_org_csapi_policy_TpPolicyType_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_policy_TpPolicyType"  */

    }

}

/* Struct = IDL:org/csapi/policy/TpPolicyVar:1.0 */

static void decode_org_csapi_policy_TpPolicyVar_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPolicyVar_VarName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin union "org_csapi_policy_TpPolicyType"  */

    
    decode_org_csapi_policy_TpPolicyType_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_policy_TpPolicyType"  */

    get_CDR_any(tvb,tree,offset,stream_is_big_endian, boundary, header);

}

/* Struct = IDL:org/csapi/policy/TpPolicyConditionListElement:1.0 */

static void decode_org_csapi_policy_TpPolicyConditionListElement_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPolicyConditionListElement_GroupNumber = %i",s_octet4);
    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpPolicyConditionListElement_Negated = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/policy/TpPolicyActionListElement:1.0 */

static void decode_org_csapi_policy_TpPolicyActionListElement_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPolicyActionListElement_SequenceNumber = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAttributeDef:1.0 */

static void decode_org_csapi_pam_TpPAMAttributeDef_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAttributeDef_Name (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAttributeDef_Type (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpPAMAttributeDef_IsStatic = %u",u_octet1);
    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpPAMAttributeDef_IsRevertOnExpiration = %u",u_octet1);
    }

    get_CDR_any(tvb,tree,offset,stream_is_big_endian, boundary, header);

}

/* Struct = IDL:org/csapi/pam/TpPAMAttribute:1.0 */

static void decode_org_csapi_pam_TpPAMAttribute_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    gint64    s_octet8;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAttribute_AttributeName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin union "org_csapi_TpAttributeValue"  */

    
    decode_org_csapi_TpAttributeValue_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_TpAttributeValue"  */

    s_octet8 = get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-8,8,"TpPAMAttribute_ExpiresIn = PRIo64",s_octet8);
    }

}

/* Struct = IDL:org/csapi/pam/TpPAMPresenceData:1.0 */

static void decode_org_csapi_pam_TpPAMPresenceData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMPresenceData_Name (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMPresenceData_subscriberStatus (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMPresenceData_networkStatus (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMPresenceData_communicationMeans (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMPresenceData_subscriberProvidedLocation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMPresenceData_networkProvidedLocation (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMPresenceData_Priority = %i",s_octet4);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMPresenceData_otherInfo (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/pam/TpPAMAvailabilityProfile:1.0 */

static void decode_org_csapi_pam_TpPAMAvailabilityProfile_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAvailabilityProfile_PrivacyCode (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin struct "org_csapi_pam_TpPAMPresenceData"  */

    

    decode_org_csapi_pam_TpPAMPresenceData_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_pam_TpPAMPresenceData"  */

}

/* Struct = IDL:org/csapi/pam/TpPAMCommunicationContext:1.0 */

static void decode_org_csapi_pam_TpPAMCommunicationContext_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMCommunicationContext_CommunicationCapability (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/pam/TpPAMContext:1.0 */

static void decode_org_csapi_pam_TpPAMContext_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMContext_AskerData;
    guint32   i_TpPAMContext_AskerData;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin union "org_csapi_pam_TpPAMContextData"  */

    
    decode_org_csapi_pam_TpPAMContextData_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_pam_TpPAMContextData"  */

    u_octet4_loop_TpPAMContext_AskerData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMContext_AskerData = %u",u_octet4_loop_TpPAMContext_AskerData);
    }

    for (i_TpPAMContext_AskerData=0; i_TpPAMContext_AskerData < u_octet4_loop_TpPAMContext_AskerData; i_TpPAMContext_AskerData++) {

        /*  Begin struct "org_csapi_TpAttribute"  */

        

        decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAttribute"  */

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAccessControlData:1.0 */

static void decode_org_csapi_pam_TpPAMAccessControlData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_TpPAMAccessControlData_AllowList;
    guint32   i_TpPAMAccessControlData_AllowList;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMAccessControlData_DenyList;
    guint32   i_TpPAMAccessControlData_DenyList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMACLDefault,"Unknown Enum Value"));
    }

    u_octet4_loop_TpPAMAccessControlData_AllowList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAccessControlData_AllowList = %u",u_octet4_loop_TpPAMAccessControlData_AllowList);
    }

    for (i_TpPAMAccessControlData_AllowList=0; i_TpPAMAccessControlData_AllowList < u_octet4_loop_TpPAMAccessControlData_AllowList; i_TpPAMAccessControlData_AllowList++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAccessControlData_AllowList (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMAccessControlData_DenyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAccessControlData_DenyList = %u",u_octet4_loop_TpPAMAccessControlData_DenyList);
    }

    for (i_TpPAMAccessControlData_DenyList=0; i_TpPAMAccessControlData_DenyList < u_octet4_loop_TpPAMAccessControlData_DenyList; i_TpPAMAccessControlData_DenyList++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAccessControlData_DenyList (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMICEventData:1.0 */

static void decode_org_csapi_pam_TpPAMICEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMICEventData_IdentityType;
    guint32   i_TpPAMICEventData_IdentityType;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMICEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMICEventData_IdentityType = %u",u_octet4_loop_TpPAMICEventData_IdentityType);
    }

    for (i_TpPAMICEventData_IdentityType=0; i_TpPAMICEventData_IdentityType < u_octet4_loop_TpPAMICEventData_IdentityType; i_TpPAMICEventData_IdentityType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMICEventData_IdentityType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMICNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMICNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMICNotificationData_Identities;
    guint32   i_TpPAMICNotificationData_Identities;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMICNotificationData_Identities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMICNotificationData_Identities = %u",u_octet4_loop_TpPAMICNotificationData_Identities);
    }

    for (i_TpPAMICNotificationData_Identities=0; i_TpPAMICNotificationData_Identities < u_octet4_loop_TpPAMICNotificationData_Identities; i_TpPAMICNotificationData_Identities++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMICNotificationData_Identities (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMIDEventData:1.0 */

static void decode_org_csapi_pam_TpPAMIDEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMIDEventData_IdentityName;
    guint32   i_TpPAMIDEventData_IdentityName;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMIDEventData_IdentityType;
    guint32   i_TpPAMIDEventData_IdentityType;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMIDEventData_IdentityName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMIDEventData_IdentityName = %u",u_octet4_loop_TpPAMIDEventData_IdentityName);
    }

    for (i_TpPAMIDEventData_IdentityName=0; i_TpPAMIDEventData_IdentityName < u_octet4_loop_TpPAMIDEventData_IdentityName; i_TpPAMIDEventData_IdentityName++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMIDEventData_IdentityName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMIDEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMIDEventData_IdentityType = %u",u_octet4_loop_TpPAMIDEventData_IdentityType);
    }

    for (i_TpPAMIDEventData_IdentityType=0; i_TpPAMIDEventData_IdentityType < u_octet4_loop_TpPAMIDEventData_IdentityType; i_TpPAMIDEventData_IdentityType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMIDEventData_IdentityType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMIDNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMIDNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMIDNotificationData_Identities;
    guint32   i_TpPAMIDNotificationData_Identities;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMIDNotificationData_Identities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMIDNotificationData_Identities = %u",u_octet4_loop_TpPAMIDNotificationData_Identities);
    }

    for (i_TpPAMIDNotificationData_Identities=0; i_TpPAMIDNotificationData_Identities < u_octet4_loop_TpPAMIDNotificationData_Identities; i_TpPAMIDNotificationData_Identities++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMIDNotificationData_Identities (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMGMCEventData:1.0 */

static void decode_org_csapi_pam_TpPAMGMCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMGMCEventData_GroupName;
    guint32   i_TpPAMGMCEventData_GroupName;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMGMCEventData_GroupType;
    guint32   i_TpPAMGMCEventData_GroupType;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMGMCEventData_GroupName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMGMCEventData_GroupName = %u",u_octet4_loop_TpPAMGMCEventData_GroupName);
    }

    for (i_TpPAMGMCEventData_GroupName=0; i_TpPAMGMCEventData_GroupName < u_octet4_loop_TpPAMGMCEventData_GroupName; i_TpPAMGMCEventData_GroupName++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMGMCEventData_GroupName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMGMCEventData_GroupType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMGMCEventData_GroupType = %u",u_octet4_loop_TpPAMGMCEventData_GroupType);
    }

    for (i_TpPAMGMCEventData_GroupType=0; i_TpPAMGMCEventData_GroupType < u_octet4_loop_TpPAMGMCEventData_GroupType; i_TpPAMGMCEventData_GroupType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMGMCEventData_GroupType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMGMCNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMGMCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMGMCNotificationData_Groups;
    guint32   i_TpPAMGMCNotificationData_Groups;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMGMCNotificationData_Groups = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMGMCNotificationData_Groups = %u",u_octet4_loop_TpPAMGMCNotificationData_Groups);
    }

    for (i_TpPAMGMCNotificationData_Groups=0; i_TpPAMGMCNotificationData_Groups < u_octet4_loop_TpPAMGMCNotificationData_Groups; i_TpPAMGMCNotificationData_Groups++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMGMCNotificationData_Groups (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMACEventData:1.0 */

static void decode_org_csapi_pam_TpPAMACEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMACEventData_AgentType;
    guint32   i_TpPAMACEventData_AgentType;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMACEventData_AgentType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMACEventData_AgentType = %u",u_octet4_loop_TpPAMACEventData_AgentType);
    }

    for (i_TpPAMACEventData_AgentType=0; i_TpPAMACEventData_AgentType < u_octet4_loop_TpPAMACEventData_AgentType; i_TpPAMACEventData_AgentType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMACEventData_AgentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMACNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMACNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMACNotificationData_Agents;
    guint32   i_TpPAMACNotificationData_Agents;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMACNotificationData_Agents = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMACNotificationData_Agents = %u",u_octet4_loop_TpPAMACNotificationData_Agents);
    }

    for (i_TpPAMACNotificationData_Agents=0; i_TpPAMACNotificationData_Agents < u_octet4_loop_TpPAMACNotificationData_Agents; i_TpPAMACNotificationData_Agents++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMACNotificationData_Agents (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMADEventData:1.0 */

static void decode_org_csapi_pam_TpPAMADEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMADEventData_AgentName;
    guint32   i_TpPAMADEventData_AgentName;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMADEventData_AgentType;
    guint32   i_TpPAMADEventData_AgentType;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMADEventData_AgentName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMADEventData_AgentName = %u",u_octet4_loop_TpPAMADEventData_AgentName);
    }

    for (i_TpPAMADEventData_AgentName=0; i_TpPAMADEventData_AgentName < u_octet4_loop_TpPAMADEventData_AgentName; i_TpPAMADEventData_AgentName++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMADEventData_AgentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMADEventData_AgentType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMADEventData_AgentType = %u",u_octet4_loop_TpPAMADEventData_AgentType);
    }

    for (i_TpPAMADEventData_AgentType=0; i_TpPAMADEventData_AgentType < u_octet4_loop_TpPAMADEventData_AgentType; i_TpPAMADEventData_AgentType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMADEventData_AgentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMADNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMADNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMADNotificationData_Agents;
    guint32   i_TpPAMADNotificationData_Agents;
    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMADNotificationData_Agents = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMADNotificationData_Agents = %u",u_octet4_loop_TpPAMADNotificationData_Agents);
    }

    for (i_TpPAMADNotificationData_Agents=0; i_TpPAMADNotificationData_Agents < u_octet4_loop_TpPAMADNotificationData_Agents; i_TpPAMADNotificationData_Agents++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMADNotificationData_Agents (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAAEventData:1.0 */

static void decode_org_csapi_pam_TpPAMAAEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMAAEventData_IdentityName;
    guint32   i_TpPAMAAEventData_IdentityName;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMAAEventData_IdentityType;
    guint32   i_TpPAMAAEventData_IdentityType;
    guint32   u_octet4_loop_TpPAMAAEventData_AgentName;
    guint32   i_TpPAMAAEventData_AgentName;
    guint32   u_octet4_loop_TpPAMAAEventData_AgentType;
    guint32   i_TpPAMAAEventData_AgentType;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMAAEventData_IdentityName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAAEventData_IdentityName = %u",u_octet4_loop_TpPAMAAEventData_IdentityName);
    }

    for (i_TpPAMAAEventData_IdentityName=0; i_TpPAMAAEventData_IdentityName < u_octet4_loop_TpPAMAAEventData_IdentityName; i_TpPAMAAEventData_IdentityName++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAAEventData_IdentityName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMAAEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAAEventData_IdentityType = %u",u_octet4_loop_TpPAMAAEventData_IdentityType);
    }

    for (i_TpPAMAAEventData_IdentityType=0; i_TpPAMAAEventData_IdentityType < u_octet4_loop_TpPAMAAEventData_IdentityType; i_TpPAMAAEventData_IdentityType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAAEventData_IdentityType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMAAEventData_AgentName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAAEventData_AgentName = %u",u_octet4_loop_TpPAMAAEventData_AgentName);
    }

    for (i_TpPAMAAEventData_AgentName=0; i_TpPAMAAEventData_AgentName < u_octet4_loop_TpPAMAAEventData_AgentName; i_TpPAMAAEventData_AgentName++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAAEventData_AgentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMAAEventData_AgentType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAAEventData_AgentType = %u",u_octet4_loop_TpPAMAAEventData_AgentType);
    }

    for (i_TpPAMAAEventData_AgentType=0; i_TpPAMAAEventData_AgentType < u_octet4_loop_TpPAMAAEventData_AgentType; i_TpPAMAAEventData_AgentType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAAEventData_AgentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAANotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMAANotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAANotificationData_Identity (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAANotificationData_Agent (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/pam/TpPAMAUEventData:1.0 */

static void decode_org_csapi_pam_TpPAMAUEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMAUEventData_IdentityName;
    guint32   i_TpPAMAUEventData_IdentityName;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMAUEventData_IdentityType;
    guint32   i_TpPAMAUEventData_IdentityType;
    guint32   u_octet4_loop_TpPAMAUEventData_AgentName;
    guint32   i_TpPAMAUEventData_AgentName;
    guint32   u_octet4_loop_TpPAMAUEventData_AgentType;
    guint32   i_TpPAMAUEventData_AgentType;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMAUEventData_IdentityName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAUEventData_IdentityName = %u",u_octet4_loop_TpPAMAUEventData_IdentityName);
    }

    for (i_TpPAMAUEventData_IdentityName=0; i_TpPAMAUEventData_IdentityName < u_octet4_loop_TpPAMAUEventData_IdentityName; i_TpPAMAUEventData_IdentityName++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAUEventData_IdentityName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMAUEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAUEventData_IdentityType = %u",u_octet4_loop_TpPAMAUEventData_IdentityType);
    }

    for (i_TpPAMAUEventData_IdentityType=0; i_TpPAMAUEventData_IdentityType < u_octet4_loop_TpPAMAUEventData_IdentityType; i_TpPAMAUEventData_IdentityType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAUEventData_IdentityType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMAUEventData_AgentName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAUEventData_AgentName = %u",u_octet4_loop_TpPAMAUEventData_AgentName);
    }

    for (i_TpPAMAUEventData_AgentName=0; i_TpPAMAUEventData_AgentName < u_octet4_loop_TpPAMAUEventData_AgentName; i_TpPAMAUEventData_AgentName++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAUEventData_AgentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMAUEventData_AgentType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAUEventData_AgentType = %u",u_octet4_loop_TpPAMAUEventData_AgentType);
    }

    for (i_TpPAMAUEventData_AgentType=0; i_TpPAMAUEventData_AgentType < u_octet4_loop_TpPAMAUEventData_AgentType; i_TpPAMAUEventData_AgentType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAUEventData_AgentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAUNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMAUNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAUNotificationData_Identity (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAUNotificationData_Agent (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/pam/TpPAMCCEventData:1.0 */

static void decode_org_csapi_pam_TpPAMCCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMCCEventData_IdentityName;
    guint32   i_TpPAMCCEventData_IdentityName;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMCCEventData_IdentityType;
    guint32   i_TpPAMCCEventData_IdentityType;
    guint32   u_octet4_loop_TpPAMCCEventData_Capabilities;
    guint32   i_TpPAMCCEventData_Capabilities;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMCCEventData_IdentityName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCCEventData_IdentityName = %u",u_octet4_loop_TpPAMCCEventData_IdentityName);
    }

    for (i_TpPAMCCEventData_IdentityName=0; i_TpPAMCCEventData_IdentityName < u_octet4_loop_TpPAMCCEventData_IdentityName; i_TpPAMCCEventData_IdentityName++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMCCEventData_IdentityName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMCCEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCCEventData_IdentityType = %u",u_octet4_loop_TpPAMCCEventData_IdentityType);
    }

    for (i_TpPAMCCEventData_IdentityType=0; i_TpPAMCCEventData_IdentityType < u_octet4_loop_TpPAMCCEventData_IdentityType; i_TpPAMCCEventData_IdentityType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMCCEventData_IdentityType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMCCEventData_Capabilities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCCEventData_Capabilities = %u",u_octet4_loop_TpPAMCCEventData_Capabilities);
    }

    for (i_TpPAMCCEventData_Capabilities=0; i_TpPAMCCEventData_Capabilities < u_octet4_loop_TpPAMCCEventData_Capabilities; i_TpPAMCCEventData_Capabilities++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMCCEventData_Capabilities (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMCCNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMCCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMCCNotificationData_Capabilities;
    guint32   i_TpPAMCCNotificationData_Capabilities;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMCCNotificationData_Identity (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpPAMCCNotificationData_Capabilities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCCNotificationData_Capabilities = %u",u_octet4_loop_TpPAMCCNotificationData_Capabilities);
    }

    for (i_TpPAMCCNotificationData_Capabilities=0; i_TpPAMCCNotificationData_Capabilities < u_octet4_loop_TpPAMCCNotificationData_Capabilities; i_TpPAMCCNotificationData_Capabilities++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMCCNotificationData_Capabilities (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMACPSEventData:1.0 */

static void decode_org_csapi_pam_TpPAMACPSEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMACPSEventData_AgentName;
    guint32   i_TpPAMACPSEventData_AgentName;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMACPSEventData_AgentType;
    guint32   i_TpPAMACPSEventData_AgentType;
    guint32   u_octet4_loop_TpPAMACPSEventData_Capabilities;
    guint32   i_TpPAMACPSEventData_Capabilities;
    guint32   u_octet4_loop_TpPAMACPSEventData_AttributeNames;
    guint32   i_TpPAMACPSEventData_AttributeNames;
    gint64    s_octet8;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMACPSEventData_AgentName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMACPSEventData_AgentName = %u",u_octet4_loop_TpPAMACPSEventData_AgentName);
    }

    for (i_TpPAMACPSEventData_AgentName=0; i_TpPAMACPSEventData_AgentName < u_octet4_loop_TpPAMACPSEventData_AgentName; i_TpPAMACPSEventData_AgentName++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMACPSEventData_AgentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMACPSEventData_AgentType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMACPSEventData_AgentType = %u",u_octet4_loop_TpPAMACPSEventData_AgentType);
    }

    for (i_TpPAMACPSEventData_AgentType=0; i_TpPAMACPSEventData_AgentType < u_octet4_loop_TpPAMACPSEventData_AgentType; i_TpPAMACPSEventData_AgentType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMACPSEventData_AgentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMACPSEventData_Capabilities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMACPSEventData_Capabilities = %u",u_octet4_loop_TpPAMACPSEventData_Capabilities);
    }

    for (i_TpPAMACPSEventData_Capabilities=0; i_TpPAMACPSEventData_Capabilities < u_octet4_loop_TpPAMACPSEventData_Capabilities; i_TpPAMACPSEventData_Capabilities++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMACPSEventData_Capabilities (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMACPSEventData_AttributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMACPSEventData_AttributeNames = %u",u_octet4_loop_TpPAMACPSEventData_AttributeNames);
    }

    for (i_TpPAMACPSEventData_AttributeNames=0; i_TpPAMACPSEventData_AttributeNames < u_octet4_loop_TpPAMACPSEventData_AttributeNames; i_TpPAMACPSEventData_AttributeNames++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMACPSEventData_AttributeNames (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    s_octet8 = get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-8,8,"TpPAMACPSEventData_ReportingPeriod = PRIo64",s_octet8);
    }

}

/* Struct = IDL:org/csapi/pam/TpPAMACPSNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMACPSNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMACPSNotificationData_AttributeNames;
    guint32   i_TpPAMACPSNotificationData_AttributeNames;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMACPSNotificationData_Agent (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMACPSNotificationData_Capability (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpPAMACPSNotificationData_AttributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMACPSNotificationData_AttributeNames = %u",u_octet4_loop_TpPAMACPSNotificationData_AttributeNames);
    }

    for (i_TpPAMACPSNotificationData_AttributeNames=0; i_TpPAMACPSNotificationData_AttributeNames < u_octet4_loop_TpPAMACPSNotificationData_AttributeNames; i_TpPAMACPSNotificationData_AttributeNames++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMACPSNotificationData_AttributeNames (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAPSEventData:1.0 */

static void decode_org_csapi_pam_TpPAMAPSEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMAPSEventData_AgentName;
    guint32   i_TpPAMAPSEventData_AgentName;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMAPSEventData_AgentType;
    guint32   i_TpPAMAPSEventData_AgentType;
    guint32   u_octet4_loop_TpPAMAPSEventData_AttributeNames;
    guint32   i_TpPAMAPSEventData_AttributeNames;
    gint64    s_octet8;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMAPSEventData_AgentName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAPSEventData_AgentName = %u",u_octet4_loop_TpPAMAPSEventData_AgentName);
    }

    for (i_TpPAMAPSEventData_AgentName=0; i_TpPAMAPSEventData_AgentName < u_octet4_loop_TpPAMAPSEventData_AgentName; i_TpPAMAPSEventData_AgentName++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAPSEventData_AgentName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMAPSEventData_AgentType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAPSEventData_AgentType = %u",u_octet4_loop_TpPAMAPSEventData_AgentType);
    }

    for (i_TpPAMAPSEventData_AgentType=0; i_TpPAMAPSEventData_AgentType < u_octet4_loop_TpPAMAPSEventData_AgentType; i_TpPAMAPSEventData_AgentType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAPSEventData_AgentType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMAPSEventData_AttributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAPSEventData_AttributeNames = %u",u_octet4_loop_TpPAMAPSEventData_AttributeNames);
    }

    for (i_TpPAMAPSEventData_AttributeNames=0; i_TpPAMAPSEventData_AttributeNames < u_octet4_loop_TpPAMAPSEventData_AttributeNames; i_TpPAMAPSEventData_AttributeNames++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAPSEventData_AttributeNames (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    s_octet8 = get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-8,8,"TpPAMAPSEventData_ReportingPeriod = PRIo64",s_octet8);
    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAPSNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMAPSNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMAPSNotificationData_AttributeNames;
    guint32   i_TpPAMAPSNotificationData_AttributeNames;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAPSNotificationData_Agent (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpPAMAPSNotificationData_AttributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAPSNotificationData_AttributeNames = %u",u_octet4_loop_TpPAMAPSNotificationData_AttributeNames);
    }

    for (i_TpPAMAPSNotificationData_AttributeNames=0; i_TpPAMAPSNotificationData_AttributeNames < u_octet4_loop_TpPAMAPSNotificationData_AttributeNames; i_TpPAMAPSNotificationData_AttributeNames++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAPSNotificationData_AttributeNames (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMIPSEventData:1.0 */

static void decode_org_csapi_pam_TpPAMIPSEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMIPSEventData_IdentityName;
    guint32   i_TpPAMIPSEventData_IdentityName;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMIPSEventData_IdentityType;
    guint32   i_TpPAMIPSEventData_IdentityType;
    guint32   u_octet4_loop_TpPAMIPSEventData_AttributeNames;
    guint32   i_TpPAMIPSEventData_AttributeNames;
    gint64    s_octet8;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMIPSEventData_IdentityName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMIPSEventData_IdentityName = %u",u_octet4_loop_TpPAMIPSEventData_IdentityName);
    }

    for (i_TpPAMIPSEventData_IdentityName=0; i_TpPAMIPSEventData_IdentityName < u_octet4_loop_TpPAMIPSEventData_IdentityName; i_TpPAMIPSEventData_IdentityName++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMIPSEventData_IdentityName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMIPSEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMIPSEventData_IdentityType = %u",u_octet4_loop_TpPAMIPSEventData_IdentityType);
    }

    for (i_TpPAMIPSEventData_IdentityType=0; i_TpPAMIPSEventData_IdentityType < u_octet4_loop_TpPAMIPSEventData_IdentityType; i_TpPAMIPSEventData_IdentityType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMIPSEventData_IdentityType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMIPSEventData_AttributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMIPSEventData_AttributeNames = %u",u_octet4_loop_TpPAMIPSEventData_AttributeNames);
    }

    for (i_TpPAMIPSEventData_AttributeNames=0; i_TpPAMIPSEventData_AttributeNames < u_octet4_loop_TpPAMIPSEventData_AttributeNames; i_TpPAMIPSEventData_AttributeNames++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMIPSEventData_AttributeNames (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    s_octet8 = get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-8,8,"TpPAMIPSEventData_ReportingPeriod = PRIo64",s_octet8);
    }

}

/* Struct = IDL:org/csapi/pam/TpPAMIPSNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMIPSNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMIPSNotificationData_Attributes;
    guint32   i_TpPAMIPSNotificationData_Attributes;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMIPSNotificationData_Identity (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpPAMIPSNotificationData_Attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMIPSNotificationData_Attributes = %u",u_octet4_loop_TpPAMIPSNotificationData_Attributes);
    }

    for (i_TpPAMIPSNotificationData_Attributes=0; i_TpPAMIPSNotificationData_Attributes < u_octet4_loop_TpPAMIPSNotificationData_Attributes; i_TpPAMIPSNotificationData_Attributes++) {

        /*  Begin struct "org_csapi_pam_TpPAMPresenceData"  */

        

        decode_org_csapi_pam_TpPAMPresenceData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMPresenceData"  */

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAVCEventData:1.0 */

static void decode_org_csapi_pam_TpPAMAVCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMAVCEventData_IdentityName;
    guint32   i_TpPAMAVCEventData_IdentityName;
    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMAVCEventData_IdentityType;
    guint32   i_TpPAMAVCEventData_IdentityType;
    guint32   u_octet4_loop_TpPAMAVCEventData_PAMContext;
    guint32   i_TpPAMAVCEventData_PAMContext;
    guint32   u_octet4_loop_TpPAMAVCEventData_AttributeNames;
    guint32   i_TpPAMAVCEventData_AttributeNames;
    gint64    s_octet8;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMAVCEventData_IdentityName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAVCEventData_IdentityName = %u",u_octet4_loop_TpPAMAVCEventData_IdentityName);
    }

    for (i_TpPAMAVCEventData_IdentityName=0; i_TpPAMAVCEventData_IdentityName < u_octet4_loop_TpPAMAVCEventData_IdentityName; i_TpPAMAVCEventData_IdentityName++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAVCEventData_IdentityName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMAVCEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAVCEventData_IdentityType = %u",u_octet4_loop_TpPAMAVCEventData_IdentityType);
    }

    for (i_TpPAMAVCEventData_IdentityType=0; i_TpPAMAVCEventData_IdentityType < u_octet4_loop_TpPAMAVCEventData_IdentityType; i_TpPAMAVCEventData_IdentityType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAVCEventData_IdentityType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMAVCEventData_PAMContext = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAVCEventData_PAMContext = %u",u_octet4_loop_TpPAMAVCEventData_PAMContext);
    }

    for (i_TpPAMAVCEventData_PAMContext=0; i_TpPAMAVCEventData_PAMContext < u_octet4_loop_TpPAMAVCEventData_PAMContext; i_TpPAMAVCEventData_PAMContext++) {

        /*  Begin struct "org_csapi_pam_TpPAMContext"  */

        

        decode_org_csapi_pam_TpPAMContext_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMContext"  */

    }

    u_octet4_loop_TpPAMAVCEventData_AttributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAVCEventData_AttributeNames = %u",u_octet4_loop_TpPAMAVCEventData_AttributeNames);
    }

    for (i_TpPAMAVCEventData_AttributeNames=0; i_TpPAMAVCEventData_AttributeNames < u_octet4_loop_TpPAMAVCEventData_AttributeNames; i_TpPAMAVCEventData_AttributeNames++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAVCEventData_AttributeNames (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    s_octet8 = get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-8,8,"TpPAMAVCEventData_ReportingPeriod = PRIo64",s_octet8);
    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAVCNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMAVCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMAVCNotificationData_Availability;
    guint32   i_TpPAMAVCNotificationData_Availability;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMAVCNotificationData_Identity (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpPAMAVCNotificationData_Availability = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAVCNotificationData_Availability = %u",u_octet4_loop_TpPAMAVCNotificationData_Availability);
    }

    for (i_TpPAMAVCNotificationData_Availability=0; i_TpPAMAVCNotificationData_Availability < u_octet4_loop_TpPAMAVCNotificationData_Availability; i_TpPAMAVCNotificationData_Availability++) {

        /*  Begin struct "org_csapi_pam_TpPAMAvailabilityProfile"  */

        

        decode_org_csapi_pam_TpPAMAvailabilityProfile_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAvailabilityProfile"  */

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMWCEventData:1.0 */

static void decode_org_csapi_pam_TpPAMWCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMWCEventData_Events;
    guint32   i_TpPAMWCEventData_Events;
    guint32   u_octet4;
    guint32   u_octet4_loop_TpPAMWCEventData_IdentityName;
    guint32   i_TpPAMWCEventData_IdentityName;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMWCEventData_IdentityType;
    guint32   i_TpPAMWCEventData_IdentityType;
    gint64    s_octet8;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpPAMWCEventData_Events = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMWCEventData_Events = %u",u_octet4_loop_TpPAMWCEventData_Events);
    }

    for (i_TpPAMWCEventData_Events=0; i_TpPAMWCEventData_Events < u_octet4_loop_TpPAMWCEventData_Events; i_TpPAMWCEventData_Events++) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMEventName,"Unknown Enum Value"));
        }

    }

    u_octet4_loop_TpPAMWCEventData_IdentityName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMWCEventData_IdentityName = %u",u_octet4_loop_TpPAMWCEventData_IdentityName);
    }

    for (i_TpPAMWCEventData_IdentityName=0; i_TpPAMWCEventData_IdentityName < u_octet4_loop_TpPAMWCEventData_IdentityName; i_TpPAMWCEventData_IdentityName++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMWCEventData_IdentityName (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    u_octet4_loop_TpPAMWCEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMWCEventData_IdentityType = %u",u_octet4_loop_TpPAMWCEventData_IdentityType);
    }

    for (i_TpPAMWCEventData_IdentityType=0; i_TpPAMWCEventData_IdentityType < u_octet4_loop_TpPAMWCEventData_IdentityType; i_TpPAMWCEventData_IdentityType++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMWCEventData_IdentityType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

    s_octet8 = get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-8,8,"TpPAMWCEventData_ReportingPeriod = PRIo64",s_octet8);
    }

}

/* Struct = IDL:org/csapi/pam/TpPAMWCNotificationData:1.0 */

static void decode_org_csapi_pam_TpPAMWCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpPAMWCNotificationData_Watchers;
    guint32   i_TpPAMWCNotificationData_Watchers;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMEventName,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMwatcherChangeType,"Unknown Enum Value"));
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMWCNotificationData_Identity (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpPAMWCNotificationData_Watchers = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMWCNotificationData_Watchers = %u",u_octet4_loop_TpPAMWCNotificationData_Watchers);
    }

    for (i_TpPAMWCNotificationData_Watchers=0; i_TpPAMWCNotificationData_Watchers < u_octet4_loop_TpPAMWCNotificationData_Watchers; i_TpPAMWCNotificationData_Watchers++) {

        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpPAMWCNotificationData_Watchers (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMErrorInfo:1.0 */

static void decode_org_csapi_pam_TpPAMErrorInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMErrorCause,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_pam_TpPAMNotificationInfo"  */

    
    decode_org_csapi_pam_TpPAMNotificationInfo_un(tvb, pinfo, tree, offset, header, operation);

    /*  End union "org_csapi_pam_TpPAMNotificationInfo"  */

}

/* Struct = IDL:org/csapi/mmm/TpMailboxIdentifier:1.0 */

static void decode_org_csapi_mmm_TpMailboxIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMailboxIdentifier_SessionID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/mmm/TpMultiMediaMessagingIdentifier:1.0 */

static void decode_org_csapi_mmm_TpMultiMediaMessagingIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMultiMediaMessagingIdentifier_SessionID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/mmm/TpListMessagesCriteria:1.0 */

static void decode_org_csapi_mmm_TpListMessagesCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpListMessagesCriteria_OnlyUnreadMessages = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/mmm/TpMailboxFolderStatusInformation:1.0 */

static void decode_org_csapi_mmm_TpMailboxFolderStatusInformation_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMailboxFolderStatusInformation_TotalMessageCount = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/mmm/TpMessageDescription:1.0 */

static void decode_org_csapi_mmm_TpMessageDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpMessageDescription_To;
    guint32   i_TpMessageDescription_To;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpMessageDescription_MessageID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet4_loop_TpMessageDescription_To = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMessageDescription_To = %u",u_octet4_loop_TpMessageDescription_To);
    }

    for (i_TpMessageDescription_To=0; i_TpMessageDescription_To < u_octet4_loop_TpMessageDescription_To; i_TpMessageDescription_To++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpMessageDescription_Subject (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpMessageDescription_ReceivedDate (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMessageDescription_Size = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/mmm/TpBodyPartDescription:1.0 */

static void decode_org_csapi_mmm_TpBodyPartDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpBodyPartDescription_ContentDescription (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBodyPartDescription_ContentSize = %i",s_octet4);
    }

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpBodyPartDescription_ContentType (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpBodyPartDescription_ContentTransferEncoding (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpBodyPartDescription_ContentID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpBodyPartDescription_ContentDisposition (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpBodyPartDescription_PartID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBodyPartDescription_NestingLevel = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/mmm/TpBodyPart:1.0 */

static void decode_org_csapi_mmm_TpBodyPart_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpBodyPart_BodyPartContent;
    guint32   i_TpBodyPart_BodyPartContent;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_mmm_TpBodyPartDescription"  */

    

    decode_org_csapi_mmm_TpBodyPartDescription_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_mmm_TpBodyPartDescription"  */

    u_octet4_loop_TpBodyPart_BodyPartContent = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpBodyPart_BodyPartContent = %u",u_octet4_loop_TpBodyPart_BodyPartContent);
    }

    for (i_TpBodyPart_BodyPartContent=0; i_TpBodyPart_BodyPartContent < u_octet4_loop_TpBodyPart_BodyPartContent; i_TpBodyPart_BodyPartContent++) {

        u_octet1 = get_CDR_octet(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"TpBodyPart_BodyPartContent = %u",u_octet1);
        }

    }

}

/* Struct = IDL:org/csapi/mmm/TpGenericHeaderField:1.0 */

static void decode_org_csapi_mmm_TpGenericHeaderField_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpGenericHeaderField_FieldName (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpGenericHeaderField_FieldValue (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/mmm/TpMessageInfoPropertyError:1.0 */

static void decode_org_csapi_mmm_TpMessageInfoPropertyError_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessageInfoPropertyName,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpSetPropertyError,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/mmm/TpNewMailboxMessageArrivedCriteria:1.0 */

static void decode_org_csapi_mmm_TpNewMailboxMessageArrivedCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNewMailboxMessageArrivedCriteria_MailboxID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNewMailboxMessageArrivedCriteria_AuthenticationInfo (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

}

/* Struct = IDL:org/csapi/mmm/TpNewMailboxMessageArrivedInfo:1.0 */

static void decode_org_csapi_mmm_TpNewMailboxMessageArrivedInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_TpNewMailboxMessageArrivedInfo_MessageDescription;
    guint32   i_TpNewMailboxMessageArrivedInfo_MessageDescription;
    guint32   u_octet4_loop_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation;
    guint32   i_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNewMailboxMessageArrivedInfo_MailboxID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"TpNewMailboxMessageArrivedInfo_FolderID (%u) = %s",
          u_octet4, (u_octet4 > 0) ? seq : "");
    }

    g_free(seq);          /*  free buffer  */
    seq = NULL;

    u_octet4_loop_TpNewMailboxMessageArrivedInfo_MessageDescription = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNewMailboxMessageArrivedInfo_MessageDescription = %u",u_octet4_loop_TpNewMailboxMessageArrivedInfo_MessageDescription);
    }

    for (i_TpNewMailboxMessageArrivedInfo_MessageDescription=0; i_TpNewMailboxMessageArrivedInfo_MessageDescription < u_octet4_loop_TpNewMailboxMessageArrivedInfo_MessageDescription; i_TpNewMailboxMessageArrivedInfo_MessageDescription++) {

        /*  Begin struct "org_csapi_mmm_TpMessageDescription"  */

        

        decode_org_csapi_mmm_TpMessageDescription_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpMessageDescription"  */

    }

    u_octet4_loop_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation = %u",u_octet4_loop_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation);
    }

    for (i_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation=0; i_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation < u_octet4_loop_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation; i_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation++) {

        /*  Begin union "org_csapi_mmm_TpMessageHeaderField"  */

        
        decode_org_csapi_mmm_TpMessageHeaderField_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_mmm_TpMessageHeaderField"  */

    }

}

/* Struct = IDL:org/csapi/mmm/TpQueryStatusReport:1.0 */

static void decode_org_csapi_mmm_TpQueryStatusReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpQueryStatusReport_ReportedStatus = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/mmm/TpTerminatingAddressList:1.0 */

static void decode_org_csapi_mmm_TpTerminatingAddressList_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpTerminatingAddressList_ToAddressList;
    guint32   i_TpTerminatingAddressList_ToAddressList;
    guint32   u_octet4_loop_TpTerminatingAddressList_CcAddressList;
    guint32   i_TpTerminatingAddressList_CcAddressList;
    guint32   u_octet4_loop_TpTerminatingAddressList_BccAddressList;
    guint32   i_TpTerminatingAddressList_BccAddressList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpTerminatingAddressList_ToAddressList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpTerminatingAddressList_ToAddressList = %u",u_octet4_loop_TpTerminatingAddressList_ToAddressList);
    }

    for (i_TpTerminatingAddressList_ToAddressList=0; i_TpTerminatingAddressList_ToAddressList < u_octet4_loop_TpTerminatingAddressList_ToAddressList; i_TpTerminatingAddressList_ToAddressList++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

    }

    u_octet4_loop_TpTerminatingAddressList_CcAddressList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpTerminatingAddressList_CcAddressList = %u",u_octet4_loop_TpTerminatingAddressList_CcAddressList);
    }

    for (i_TpTerminatingAddressList_CcAddressList=0; i_TpTerminatingAddressList_CcAddressList < u_octet4_loop_TpTerminatingAddressList_CcAddressList; i_TpTerminatingAddressList_CcAddressList++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

    }

    u_octet4_loop_TpTerminatingAddressList_BccAddressList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpTerminatingAddressList_BccAddressList = %u",u_octet4_loop_TpTerminatingAddressList_BccAddressList);
    }

    for (i_TpTerminatingAddressList_BccAddressList=0; i_TpTerminatingAddressList_BccAddressList < u_octet4_loop_TpTerminatingAddressList_BccAddressList; i_TpTerminatingAddressList_BccAddressList++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

    }

}

/* Struct = IDL:org/csapi/mmm/TpNewMessageArrivedCriteria:1.0 */

static void decode_org_csapi_mmm_TpNewMessageArrivedCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddressRange"  */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddressRange"  */

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpNewMessageArrivedCriteria_CreateMultiMediaMessagingSession = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/mmm/TpMessagingNotificationRequested:1.0 */

static void decode_org_csapi_mmm_TpMessagingNotificationRequested_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpMessagingNotificationRequested_EventCriteria;
    guint32   i_TpMessagingNotificationRequested_EventCriteria;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpMessagingNotificationRequested_EventCriteria = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMessagingNotificationRequested_EventCriteria = %u",u_octet4_loop_TpMessagingNotificationRequested_EventCriteria);
    }

    for (i_TpMessagingNotificationRequested_EventCriteria=0; i_TpMessagingNotificationRequested_EventCriteria < u_octet4_loop_TpMessagingNotificationRequested_EventCriteria; i_TpMessagingNotificationRequested_EventCriteria++) {

        /*  Begin union "org_csapi_mmm_TpMessagingEventCriteria"  */

        
        decode_org_csapi_mmm_TpMessagingEventCriteria_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_mmm_TpMessagingEventCriteria"  */

    }

    s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMessagingNotificationRequested_AssignmentID = %i",s_octet4);
    }

}

/* Struct = IDL:org/csapi/mmm/TpMessagingNotificationRequestedSetEntry:1.0 */

static void decode_org_csapi_mmm_TpMessagingNotificationRequestedSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet;
    guint32   i_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet;
    guint8    u_octet1;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    u_octet4_loop_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet = %u",u_octet4_loop_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet);
    }

    for (i_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet=0; i_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet < u_octet4_loop_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet; i_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet++) {

        /*  Begin struct "org_csapi_mmm_TpMessagingNotificationRequested"  */

        

        decode_org_csapi_mmm_TpMessagingNotificationRequested_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpMessagingNotificationRequested"  */

    }

    u_octet1 = get_CDR_boolean(tvb,offset);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpMessagingNotificationRequestedSetEntry_Final = %u",u_octet1);
    }

}

/* Struct = IDL:org/csapi/mmm/TpNewMessageArrivedInfo:1.0 */

static void decode_org_csapi_mmm_TpNewMessageArrivedInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpNewMessageArrivedInfo_DestinationAddressSet;
    guint32   i_TpNewMessageArrivedInfo_DestinationAddressSet;
    guint32   u_octet4_loop_TpNewMessageArrivedInfo_Message;
    guint32   i_TpNewMessageArrivedInfo_Message;
    guint8    u_octet1;
    guint32   u_octet4_loop_TpNewMessageArrivedInfo_Headers;
    guint32   i_TpNewMessageArrivedInfo_Headers;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet4_loop_TpNewMessageArrivedInfo_DestinationAddressSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNewMessageArrivedInfo_DestinationAddressSet = %u",u_octet4_loop_TpNewMessageArrivedInfo_DestinationAddressSet);
    }

    for (i_TpNewMessageArrivedInfo_DestinationAddressSet=0; i_TpNewMessageArrivedInfo_DestinationAddressSet < u_octet4_loop_TpNewMessageArrivedInfo_DestinationAddressSet; i_TpNewMessageArrivedInfo_DestinationAddressSet++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

    }

    u_octet4_loop_TpNewMessageArrivedInfo_Message = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNewMessageArrivedInfo_Message = %u",u_octet4_loop_TpNewMessageArrivedInfo_Message);
    }

    for (i_TpNewMessageArrivedInfo_Message=0; i_TpNewMessageArrivedInfo_Message < u_octet4_loop_TpNewMessageArrivedInfo_Message; i_TpNewMessageArrivedInfo_Message++) {

        u_octet1 = get_CDR_octet(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"TpNewMessageArrivedInfo_Message = %u",u_octet1);
        }

    }

    u_octet4_loop_TpNewMessageArrivedInfo_Headers = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNewMessageArrivedInfo_Headers = %u",u_octet4_loop_TpNewMessageArrivedInfo_Headers);
    }

    for (i_TpNewMessageArrivedInfo_Headers=0; i_TpNewMessageArrivedInfo_Headers < u_octet4_loop_TpNewMessageArrivedInfo_Headers; i_TpNewMessageArrivedInfo_Headers++) {

        /*  Begin union "org_csapi_mmm_TpMessageHeaderField"  */

        
        decode_org_csapi_mmm_TpMessageHeaderField_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_mmm_TpMessageHeaderField"  */

    }

    /*  Begin struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

    

    decode_org_csapi_mmm_TpMultiMediaMessagingIdentifier_st(tvb, pinfo, tree, offset, header, operation);

    /*  End struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

}

/* Union = IDL:org/csapi/TpAoCOrder:1.0 */

static void decode_org_csapi_TpAoCOrder_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpAoCOrder;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/TpAoCOrder:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpCallAoCOrderCategory,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/TpCallAoCOrderCategory:1.0
     */
     
    disc_s_TpAoCOrder = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpAoCOrder == 0 ) {
     
        /*  Begin struct "org_csapi_TpChargeAdviceInfo"  */

        

        decode_org_csapi_TpChargeAdviceInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpChargeAdviceInfo"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpAoCOrder == 1 ) {
     
        /*  Begin struct "org_csapi_TpChargePerTime"  */

        

        decode_org_csapi_TpChargePerTime_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpChargePerTime"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpAoCOrder == 2 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"NetworkCharge (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/TpSimpleAttributeValue:1.0 */

static void decode_org_csapi_TpSimpleAttributeValue_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpSimpleAttributeValue;
    guint8    u_octet1;
    gint8     s_octet1;
    gchar   *seq = NULL;
    gint16    s_octet2;
    guint16   u_octet2;
    gint32    s_octet4;
    gint64    s_octet8;
    guint64   u_octet8;
    gfloat    my_float;
    gdouble   my_double;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/TpSimpleAttributeValue:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpSimpleAttributeTypeInfo,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/TpSimpleAttributeTypeInfo:1.0
     */
     
    disc_s_TpSimpleAttributeValue = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpSimpleAttributeValue == 0 ) {
     
        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"BooleanValue = %u",u_octet1);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpSimpleAttributeValue == 1 ) {
     
        u_octet1 = get_CDR_octet(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"OctetValue = %u",u_octet1);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpSimpleAttributeValue == 2 ) {
     
        u_octet1 = get_CDR_char(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"CharValue = %u",u_octet1);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpSimpleAttributeValue == 3 ) {
     
        s_octet1 = get_CDR_wchar(tvb, &seq, offset, header);
        if (tree) {
            if (s_octet1 > 0)
                proto_tree_add_text(tree,tvb,*offset-1-s_octet1,1,"length = %u",s_octet1);

            if (s_octet1 < 0)
                s_octet1 = -s_octet1;

            if (s_octet1 > 0)
                proto_tree_add_text(tree,tvb,*offset-s_octet1,s_octet1,"WCharValue = %s",seq);

        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpSimpleAttributeValue == 4 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"StringValue (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpSimpleAttributeValue == 5 ) {
     
        u_octet4 = get_CDR_wstring(tvb, &seq, offset, stream_is_big_endian, boundary, header);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"WStringValue (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpSimpleAttributeValue == 6 ) {
     
        s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-2,2,"Int16Value = %i",s_octet2);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpSimpleAttributeValue == 7 ) {
     
        u_octet2 = get_CDR_ushort(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-2,2,"UnsignedInt16Value = %u",u_octet2);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpSimpleAttributeValue == 8 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Int32Value = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpSimpleAttributeValue == 9 ) {
     
        u_octet4 = get_CDR_ulong(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"UnsignedInt32Value = %u",u_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpSimpleAttributeValue == 10 ) {
     
        s_octet8 = get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-8,8,"Int64Value = PRIo64",s_octet8);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpSimpleAttributeValue == 11 ) {
     
        u_octet8 = get_CDR_ulong_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-8,8,"UnsignedInt64Value = PRIu64",u_octet8);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpSimpleAttributeValue == 12 ) {
     
        my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"FloatValue = %.6e",my_float);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpSimpleAttributeValue == 13 ) {
     
        my_double = get_CDR_double(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-8,8,"DoubleValue = %.15e",my_double);
        }

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/TpAttributeValue:1.0 */

static void decode_org_csapi_TpAttributeValue_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpAttributeValue;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/TpAttributeValue:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpAttributeTagInfo,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/TpAttributeTagInfo:1.0
     */
     
    disc_s_TpAttributeValue = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpAttributeValue == 0 ) {
     
        /*  Begin union "org_csapi_TpSimpleAttributeValue"  */

        
        decode_org_csapi_TpSimpleAttributeValue_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_TpSimpleAttributeValue"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpAttributeValue == 1 ) {
     
        /*  Begin struct "org_csapi_TpStructuredAttributeValue"  */

        

        decode_org_csapi_TpStructuredAttributeValue_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpStructuredAttributeValue"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpAttributeValue == 2 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"XMLValue (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/fw/TpFwEventCriteria:1.0 */

static void decode_org_csapi_fw_TpFwEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpFwEventCriteria;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_ServiceTypeNameList;
    guint32   i_ServiceTypeNameList;
    guint32   u_octet4_loop_UnavailableServiceTypeNameList;
    guint32   i_UnavailableServiceTypeNameList;
    guint32   u_octet4_loop_CompatibleServiceTypeNameList;
    guint32   i_CompatibleServiceTypeNameList;
    guint32   u_octet4_loop_SessionCreatedList;
    guint32   i_SessionCreatedList;
    guint32   u_octet4_loop_SessionTerminatedList;
    guint32   i_SessionTerminatedList;
    guint32   u_octet4_loop_AgreementSignedList;
    guint32   i_AgreementSignedList;
    guint32   u_octet4_loop_AgreementEndedList;
    guint32   i_AgreementEndedList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/fw/TpFwEventCriteria:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFwEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/fw/TpFwEventName:1.0
     */
     
    disc_s_TpFwEventCriteria = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpFwEventCriteria == 0 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"EventNameUndefined (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFwEventCriteria == 1 ) {
     
        u_octet4_loop_ServiceTypeNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of ServiceTypeNameList = %u",u_octet4_loop_ServiceTypeNameList);
        }

        for (i_ServiceTypeNameList=0; i_ServiceTypeNameList < u_octet4_loop_ServiceTypeNameList; i_ServiceTypeNameList++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"ServiceTypeNameList (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFwEventCriteria == 2 ) {
     
        u_octet4_loop_UnavailableServiceTypeNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of UnavailableServiceTypeNameList = %u",u_octet4_loop_UnavailableServiceTypeNameList);
        }

        for (i_UnavailableServiceTypeNameList=0; i_UnavailableServiceTypeNameList < u_octet4_loop_UnavailableServiceTypeNameList; i_UnavailableServiceTypeNameList++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"UnavailableServiceTypeNameList (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFwEventCriteria == 3 ) {
     
        u_octet4_loop_CompatibleServiceTypeNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of CompatibleServiceTypeNameList = %u",u_octet4_loop_CompatibleServiceTypeNameList);
        }

        for (i_CompatibleServiceTypeNameList=0; i_CompatibleServiceTypeNameList < u_octet4_loop_CompatibleServiceTypeNameList; i_CompatibleServiceTypeNameList++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"CompatibleServiceTypeNameList (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFwEventCriteria == 4 ) {
     
        u_octet4_loop_SessionCreatedList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of SessionCreatedList = %u",u_octet4_loop_SessionCreatedList);
        }

        for (i_SessionCreatedList=0; i_SessionCreatedList < u_octet4_loop_SessionCreatedList; i_SessionCreatedList++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"SessionCreatedList (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFwEventCriteria == 5 ) {
     
        u_octet4_loop_SessionTerminatedList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of SessionTerminatedList = %u",u_octet4_loop_SessionTerminatedList);
        }

        for (i_SessionTerminatedList=0; i_SessionTerminatedList < u_octet4_loop_SessionTerminatedList; i_SessionTerminatedList++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"SessionTerminatedList (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFwEventCriteria == 6 ) {
     
        u_octet4_loop_AgreementSignedList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of AgreementSignedList = %u",u_octet4_loop_AgreementSignedList);
        }

        for (i_AgreementSignedList=0; i_AgreementSignedList < u_octet4_loop_AgreementSignedList; i_AgreementSignedList++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"AgreementSignedList (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFwEventCriteria == 7 ) {
     
        u_octet4_loop_AgreementEndedList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of AgreementEndedList = %u",u_octet4_loop_AgreementEndedList);
        }

        for (i_AgreementEndedList=0; i_AgreementEndedList < u_octet4_loop_AgreementEndedList; i_AgreementEndedList++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"AgreementEndedList (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/fw/TpLoadStatisticEntityID:1.0 */

static void decode_org_csapi_fw_TpLoadStatisticEntityID_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpLoadStatisticEntityID;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/fw/TpLoadStatisticEntityID:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticEntityType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/fw/TpLoadStatisticEntityType:1.0
     */
     
    disc_s_TpLoadStatisticEntityID = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpLoadStatisticEntityID == 0 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"FrameworkID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpLoadStatisticEntityID == 1 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"ServiceID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpLoadStatisticEntityID == 2 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"ClientAppID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/fw/TpLoadStatisticInfo:1.0 */

static void decode_org_csapi_fw_TpLoadStatisticInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpLoadStatisticInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/fw/TpLoadStatisticInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticInfoType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/fw/TpLoadStatisticInfoType:1.0
     */
     
    disc_s_TpLoadStatisticInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpLoadStatisticInfo == 0 ) {
     
        /*  Begin struct "org_csapi_fw_TpLoadStatisticData"  */

        

        decode_org_csapi_fw_TpLoadStatisticData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpLoadStatisticData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpLoadStatisticInfo == 1 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/fw/TpDomainID:1.0 */

static void decode_org_csapi_fw_TpDomainID_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpDomainID;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/fw/TpDomainID:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpDomainIDType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/fw/TpDomainIDType:1.0
     */
     
    disc_s_TpDomainID = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpDomainID == 0 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"FwID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpDomainID == 1 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"ClientAppID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpDomainID == 2 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"EntOpID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpDomainID == 3 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"ServiceID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpDomainID == 4 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"ServiceSupplierID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/fw/TpMigrationAdditionalInfo:1.0 */

static void decode_org_csapi_fw_TpMigrationAdditionalInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMigrationAdditionalInfo;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/fw/TpMigrationAdditionalInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpMigrationAdditionalInfoType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/fw/TpMigrationAdditionalInfoType:1.0
     */
     
    disc_s_TpMigrationAdditionalInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/fw/TpFwEventInfo:1.0 */

static void decode_org_csapi_fw_TpFwEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpFwEventInfo;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_ServiceIDList;
    guint32   i_ServiceIDList;
    guint32   u_octet4_loop_UnavailableServiceIDList;
    guint32   i_UnavailableServiceIDList;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/fw/TpFwEventInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFwEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/fw/TpFwEventName:1.0
     */
     
    disc_s_TpFwEventInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpFwEventInfo == 0 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"EventNameUndefined (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFwEventInfo == 1 ) {
     
        u_octet4_loop_ServiceIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of ServiceIDList = %u",u_octet4_loop_ServiceIDList);
        }

        for (i_ServiceIDList=0; i_ServiceIDList < u_octet4_loop_ServiceIDList; i_ServiceIDList++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"ServiceIDList (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFwEventInfo == 2 ) {
     
        u_octet4_loop_UnavailableServiceIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of UnavailableServiceIDList = %u",u_octet4_loop_UnavailableServiceIDList);
        }

        for (i_UnavailableServiceIDList=0; i_UnavailableServiceIDList < u_octet4_loop_UnavailableServiceIDList; i_UnavailableServiceIDList++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"UnavailableServiceIDList (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFwEventInfo == 3 ) {
     
        /*  Begin struct "org_csapi_fw_TpFwMigrationServiceAvailableInfo"  */

        

        decode_org_csapi_fw_TpFwMigrationServiceAvailableInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpFwMigrationServiceAvailableInfo"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFwEventInfo == 4 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"AppSessionCreated (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFwEventInfo == 5 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"AppSessionTerminated (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFwEventInfo == 6 ) {
     
        /*  Begin struct "org_csapi_fw_TpFwAgreementInfo"  */

        

        decode_org_csapi_fw_TpFwAgreementInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpFwAgreementInfo"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFwEventInfo == 7 ) {
     
        /*  Begin struct "org_csapi_fw_TpFwAgreementInfo"  */

        

        decode_org_csapi_fw_TpFwAgreementInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_fw_TpFwAgreementInfo"  */

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/ui/TpUIVariableInfo:1.0 */

static void decode_org_csapi_ui_TpUIVariableInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpUIVariableInfo;
    gint32    s_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/ui/TpUIVariableInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIVariablePartType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/ui/TpUIVariablePartType:1.0
     */
     
    disc_s_TpUIVariableInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpUIVariableInfo == 0 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"VariablePartInteger = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUIVariableInfo == 1 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"VariablePartAddress (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUIVariableInfo == 2 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"VariablePartTime (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUIVariableInfo == 3 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"VariablePartDate (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUIVariableInfo == 4 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"VariablePartPrice (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/ui/TpUIInfo:1.0 */

static void decode_org_csapi_ui_TpUIInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpUIInfo;
    gint32    s_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_InfoBinData;
    guint32   i_InfoBinData;
    guint8    u_octet1;
    guint32   u_octet4_loop_InfoMimeData;
    guint32   i_InfoMimeData;
    guint32   u_octet4_loop_InfoWaveData;
    guint32   i_InfoWaveData;
    guint32   u_octet4_loop_InfoAuData;
    guint32   i_InfoAuData;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/ui/TpUIInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIInfoType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/ui/TpUIInfoType:1.0
     */
     
    disc_s_TpUIInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpUIInfo == 0 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"InfoID = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUIInfo == 1 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"InfoData (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUIInfo == 2 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"InfoAddress (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUIInfo == 3 ) {
     
        u_octet4_loop_InfoBinData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of InfoBinData = %u",u_octet4_loop_InfoBinData);
        }

        for (i_InfoBinData=0; i_InfoBinData < u_octet4_loop_InfoBinData; i_InfoBinData++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"InfoBinData = %u",u_octet1);
            }

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUIInfo == 4 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"InfoUUEncData (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUIInfo == 5 ) {
     
        u_octet4_loop_InfoMimeData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of InfoMimeData = %u",u_octet4_loop_InfoMimeData);
        }

        for (i_InfoMimeData=0; i_InfoMimeData < u_octet4_loop_InfoMimeData; i_InfoMimeData++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"InfoMimeData = %u",u_octet1);
            }

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUIInfo == 6 ) {
     
        u_octet4_loop_InfoWaveData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of InfoWaveData = %u",u_octet4_loop_InfoWaveData);
        }

        for (i_InfoWaveData=0; i_InfoWaveData < u_octet4_loop_InfoWaveData; i_InfoWaveData++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"InfoWaveData = %u",u_octet1);
            }

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUIInfo == 7 ) {
     
        u_octet4_loop_InfoAuData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of InfoAuData = %u",u_octet4_loop_InfoAuData);
        }

        for (i_InfoAuData=0; i_InfoAuData < u_octet4_loop_InfoAuData; i_InfoAuData++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"InfoAuData = %u",u_octet1);
            }

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUIInfo == 8 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"InfoVXMLData (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUIInfo == 9 ) {
     
        /*  Begin struct "org_csapi_ui_TpUISynthesisInfoData"  */

        

        decode_org_csapi_ui_TpUISynthesisInfoData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_ui_TpUISynthesisInfoData"  */

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/cc/TpCallAdditionalErrorInfo:1.0 */

static void decode_org_csapi_cc_TpCallAdditionalErrorInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallAdditionalErrorInfo;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cc/TpCallAdditionalErrorInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallErrorType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/TpCallErrorType:1.0
     */
     
    disc_s_TpCallAdditionalErrorInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallAdditionalErrorInfo == 1 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpAddressError,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/cc/TpCallLoadControlMechanism:1.0 */

static void decode_org_csapi_cc_TpCallLoadControlMechanism_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallLoadControlMechanism;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cc/TpCallLoadControlMechanism:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallLoadControlMechanismType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/TpCallLoadControlMechanismType:1.0
     */
     
    disc_s_TpCallLoadControlMechanism = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallLoadControlMechanism == 0 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallLoadControlPerInterval = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/cc/TpCallAdditionalTreatmentInfo:1.0 */

static void decode_org_csapi_cc_TpCallAdditionalTreatmentInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallAdditionalTreatmentInfo;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cc/TpCallAdditionalTreatmentInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallTreatmentType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/TpCallTreatmentType:1.0
     */
     
    disc_s_TpCallAdditionalTreatmentInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallAdditionalTreatmentInfo == 2 ) {
     
        /*  Begin union "org_csapi_ui_TpUIInfo"  */

        
        decode_org_csapi_ui_TpUIInfo_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_ui_TpUIInfo"  */

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/cc/TpCallPartyToChargeAdditionalInfo:1.0 */

static void decode_org_csapi_cc_TpCallPartyToChargeAdditionalInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallPartyToChargeAdditionalInfo;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cc/TpCallPartyToChargeAdditionalInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallPartyToChargeType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/TpCallPartyToChargeType:1.0
     */
     
    disc_s_TpCallPartyToChargeAdditionalInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallPartyToChargeAdditionalInfo == 2 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/cc/gccs/TpCallAppInfo:1.0 */

static void decode_org_csapi_cc_gccs_TpCallAppInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallAppInfo;
    gint32    s_octet4;
    gchar   *seq = NULL;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cc/gccs/TpCallAppInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallAppInfoType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/gccs/TpCallAppInfoType:1.0
     */
     
    disc_s_TpCallAppInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallAppInfo == 1 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallAppAlertingMechanism = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 2 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallNetworkAccessType,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 3 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallTeleService,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 4 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallBearerService,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 5 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallPartyCategory,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 6 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 7 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"CallAppGenericInfo (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 8 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/cc/gccs/TpCallAdditionalReportInfo:1.0 */

static void decode_org_csapi_cc_gccs_TpCallAdditionalReportInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallAdditionalReportInfo;
    gchar   *seq = NULL;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cc/gccs/TpCallAdditionalReportInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallReportType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/gccs/TpCallReportType:1.0
     */
     
    disc_s_TpCallAdditionalReportInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallAdditionalReportInfo == 4 ) {
     
        /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        

        decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAdditionalReportInfo == 6 ) {
     
        /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        

        decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAdditionalReportInfo == 7 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAdditionalReportInfo == 8 ) {
     
        /*  Begin struct "org_csapi_cc_TpCallServiceCode"  */

        

        decode_org_csapi_cc_TpCallServiceCode_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallServiceCode"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAdditionalReportInfo == 9 ) {
     
        /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        

        decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAdditionalReportInfo == 10 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"QueueStatus (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAdditionalReportInfo == 11 ) {
     
        /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        

        decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/cc/gccs/TpCallAdditionalReportCriteria:1.0 */

static void decode_org_csapi_cc_gccs_TpCallAdditionalReportCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallAdditionalReportCriteria;
    gint32    s_octet4;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cc/gccs/TpCallAdditionalReportCriteria:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallReportType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/gccs/TpCallReportType:1.0
     */
     
    disc_s_TpCallAdditionalReportCriteria = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallAdditionalReportCriteria == 5 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"NoAnswerDuration = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAdditionalReportCriteria == 8 ) {
     
        /*  Begin struct "org_csapi_cc_TpCallServiceCode"  */

        

        decode_org_csapi_cc_TpCallServiceCode_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallServiceCode"  */

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/cc/TpCallAdditionalEventInfo:1.0 */

static void decode_org_csapi_cc_TpCallAdditionalEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallAdditionalEventInfo;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cc/TpCallAdditionalEventInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallEventType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/TpCallEventType:1.0
     */
     
    disc_s_TpCallAdditionalEventInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallAdditionalEventInfo == 3 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAdditionalEventInfo == 4 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAdditionalEventInfo == 5 ) {
     
        /*  Begin struct "org_csapi_cc_TpCallServiceCode"  */

        

        decode_org_csapi_cc_TpCallServiceCode_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallServiceCode"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAdditionalEventInfo == 6 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAdditionalEventInfo == 11 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAdditionalEventInfo == 12 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAdditionalEventInfo == 13 ) {
     
        /*  Begin struct "org_csapi_cc_TpCallServiceCode"  */

        

        decode_org_csapi_cc_TpCallServiceCode_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_TpCallServiceCode"  */

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/cc/TpAdditionalCallEventCriteria:1.0 */

static void decode_org_csapi_cc_TpAdditionalCallEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpAdditionalCallEventCriteria;
    gint32    s_octet4;
    guint32   u_octet4_loop_OriginatingServiceCode;
    guint32   i_OriginatingServiceCode;
    guint32   u_octet4_loop_OriginatingReleaseCauseSet;
    guint32   i_OriginatingReleaseCauseSet;
    guint32   u_octet4_loop_TerminatingReleaseCauseSet;
    guint32   i_TerminatingReleaseCauseSet;
    guint32   u_octet4_loop_TerminatingServiceCode;
    guint32   i_TerminatingServiceCode;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cc/TpAdditionalCallEventCriteria:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallEventType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/TpCallEventType:1.0
     */
     
    disc_s_TpAdditionalCallEventCriteria = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpAdditionalCallEventCriteria == 3 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"MinAddressLength = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpAdditionalCallEventCriteria == 5 ) {
     
        u_octet4_loop_OriginatingServiceCode = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of OriginatingServiceCode = %u",u_octet4_loop_OriginatingServiceCode);
        }

        for (i_OriginatingServiceCode=0; i_OriginatingServiceCode < u_octet4_loop_OriginatingServiceCode; i_OriginatingServiceCode++) {

            /*  Begin struct "org_csapi_cc_TpCallServiceCode"  */

            

            decode_org_csapi_cc_TpCallServiceCode_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_TpCallServiceCode"  */

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpAdditionalCallEventCriteria == 6 ) {
     
        u_octet4_loop_OriginatingReleaseCauseSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of OriginatingReleaseCauseSet = %u",u_octet4_loop_OriginatingReleaseCauseSet);
        }

        for (i_OriginatingReleaseCauseSet=0; i_OriginatingReleaseCauseSet < u_octet4_loop_OriginatingReleaseCauseSet; i_OriginatingReleaseCauseSet++) {

            
            u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
            }

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpAdditionalCallEventCriteria == 11 ) {
     
        u_octet4_loop_TerminatingReleaseCauseSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TerminatingReleaseCauseSet = %u",u_octet4_loop_TerminatingReleaseCauseSet);
        }

        for (i_TerminatingReleaseCauseSet=0; i_TerminatingReleaseCauseSet < u_octet4_loop_TerminatingReleaseCauseSet; i_TerminatingReleaseCauseSet++) {

            
            u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
            }

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpAdditionalCallEventCriteria == 13 ) {
     
        u_octet4_loop_TerminatingServiceCode = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TerminatingServiceCode = %u",u_octet4_loop_TerminatingServiceCode);
        }

        for (i_TerminatingServiceCode=0; i_TerminatingServiceCode < u_octet4_loop_TerminatingServiceCode; i_TerminatingServiceCode++) {

            /*  Begin struct "org_csapi_cc_TpCallServiceCode"  */

            

            decode_org_csapi_cc_TpCallServiceCode_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_TpCallServiceCode"  */

        }

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/cc/TpCallAppInfo:1.0 */

static void decode_org_csapi_cc_TpCallAppInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallAppInfo;
    gint32    s_octet4;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_CallAppCarrier;
    guint32   i_CallAppCarrier;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cc/TpCallAppInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallAppInfoType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/TpCallAppInfoType:1.0
     */
     
    disc_s_TpCallAppInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallAppInfo == 1 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallAppAlertingMechanism = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 2 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallNetworkAccessType,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 3 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallTeleService,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 4 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallBearerService,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 5 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallPartyCategory,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 6 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 7 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"CallAppGenericInfo (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 8 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 9 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 10 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 11 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallHighProbabilityCompletion = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpCallAppInfo == 12 ) {
     
        u_octet4_loop_CallAppCarrier = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of CallAppCarrier = %u",u_octet4_loop_CallAppCarrier);
        }

        for (i_CallAppCarrier=0; i_CallAppCarrier < u_octet4_loop_CallAppCarrier; i_CallAppCarrier++) {

            /*  Begin struct "org_csapi_cc_TpCarrier"  */

            

            decode_org_csapi_cc_TpCarrier_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_cc_TpCarrier"  */

        }

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/cc/mpccs/TpAppMultiPartyCallBack:1.0 */

static void decode_org_csapi_cc_mpccs_TpAppMultiPartyCallBack_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpAppMultiPartyCallBack;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cc/mpccs/TpAppMultiPartyCallBack:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mpccs_TpAppMultiPartyCallBackRefType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/mpccs/TpAppMultiPartyCallBackRefType:1.0
     */
     
    disc_s_TpAppMultiPartyCallBack = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpAppMultiPartyCallBack == 1 ) {
     
        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpAppMultiPartyCallBack == 2 ) {
     
        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpAppMultiPartyCallBack == 3 ) {
     
        /*  Begin struct "org_csapi_cc_mpccs_TpAppCallLegCallBack"  */

        

        decode_org_csapi_cc_mpccs_TpAppCallLegCallBack_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_mpccs_TpAppCallLegCallBack"  */

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/cc/mmccs/TpMediaStreamDataTypeRequest:1.0 */

static void decode_org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMediaStreamDataTypeRequest;
    gint32    s_octet4;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cc/mmccs/TpMediaStreamDataTypeRequest:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mmccs_TpMediaStreamDataTypeRequestType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/mmccs/TpMediaStreamDataTypeRequestType:1.0
     */
     
    disc_s_TpMediaStreamDataTypeRequest = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMediaStreamDataTypeRequest == 0 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Audio = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMediaStreamDataTypeRequest == 1 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Video = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMediaStreamDataTypeRequest == 2 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Data = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/cc/mmccs/TpAppMultiMediaCallBack:1.0 */

static void decode_org_csapi_cc_mmccs_TpAppMultiMediaCallBack_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpAppMultiMediaCallBack;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cc/mmccs/TpAppMultiMediaCallBack:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mmccs_TpAppMultiMediaCallBackRefType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/mmccs/TpAppMultiMediaCallBackRefType:1.0
     */
     
    disc_s_TpAppMultiMediaCallBack = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpAppMultiMediaCallBack == 1 ) {
     
        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpAppMultiMediaCallBack == 2 ) {
     
        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpAppMultiMediaCallBack == 3 ) {
     
        /*  Begin struct "org_csapi_cc_mmccs_TpAppMultiMediaCallLegCallBack"  */

        

        decode_org_csapi_cc_mmccs_TpAppMultiMediaCallLegCallBack_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_mmccs_TpAppMultiMediaCallLegCallBack"  */

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/cc/cccs/TpConfPolicy:1.0 */

static void decode_org_csapi_cc_cccs_TpConfPolicy_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpConfPolicy;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cc/cccs/TpConfPolicy:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_cccs_TpConfPolicyType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/cccs/TpConfPolicyType:1.0
     */
     
    disc_s_TpConfPolicy = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpConfPolicy == 1 ) {
     
        /*  Begin struct "org_csapi_cc_cccs_TpMonoMediaConfPolicy"  */

        

        decode_org_csapi_cc_cccs_TpMonoMediaConfPolicy_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_cccs_TpMonoMediaConfPolicy"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpConfPolicy == 2 ) {
     
        /*  Begin struct "org_csapi_cc_cccs_TpMultiMediaConfPolicy"  */

        

        decode_org_csapi_cc_cccs_TpMultiMediaConfPolicy_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_cccs_TpMultiMediaConfPolicy"  */

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/ui/TpUITargetObject:1.0 */

static void decode_org_csapi_ui_TpUITargetObject_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpUITargetObject;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/ui/TpUITargetObject:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUITargetObjectType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/ui/TpUITargetObjectType:1.0
     */
     
    disc_s_TpUITargetObject = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpUITargetObject == 0 ) {
     
        /*  Begin struct "org_csapi_cc_gccs_TpCallIdentifier"  */

        

        decode_org_csapi_cc_gccs_TpCallIdentifier_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_gccs_TpCallIdentifier"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUITargetObject == 1 ) {
     
        /*  Begin struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

        

        decode_org_csapi_cc_mpccs_TpMultiPartyCallIdentifier_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpUITargetObject == 2 ) {
     
        /*  Begin struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

        

        decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/mm/TpBindingEntry:1.0 */

static void decode_org_csapi_mm_TpBindingEntry_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpBindingEntry;
    gint32    s_octet4;
    gfloat    my_float;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/mm/TpBindingEntry:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpBindingEntryType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mm/TpBindingEntryType:1.0
     */
     
    disc_s_TpBindingEntry = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpBindingEntry == 1 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"UBExpires = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpBindingEntry == 2 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpBindingEntry == 3 ) {
     
        my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"UBPreference = %.6e",my_float);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/dsc/TpDataSessionChargeOrder:1.0 */

static void decode_org_csapi_dsc_TpDataSessionChargeOrder_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpDataSessionChargeOrder;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/dsc/TpDataSessionChargeOrder:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionChargeOrderCategory,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/dsc/TpDataSessionChargeOrderCategory:1.0
     */
     
    disc_s_TpDataSessionChargeOrder = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpDataSessionChargeOrder == 0 ) {
     
        /*  Begin struct "org_csapi_dsc_TpChargePerVolume"  */

        

        decode_org_csapi_dsc_TpChargePerVolume_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_dsc_TpChargePerVolume"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpDataSessionChargeOrder == 1 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"NetworkCharge (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/dsc/TpDataSessionAdditionalErrorInfo:1.0 */

static void decode_org_csapi_dsc_TpDataSessionAdditionalErrorInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpDataSessionAdditionalErrorInfo;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/dsc/TpDataSessionAdditionalErrorInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionErrorType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/dsc/TpDataSessionErrorType:1.0
     */
     
    disc_s_TpDataSessionAdditionalErrorInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpDataSessionAdditionalErrorInfo == 1 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpAddressError,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/dsc/TpDataSessionAdditionalReportInfo:1.0 */

static void decode_org_csapi_dsc_TpDataSessionAdditionalReportInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpDataSessionAdditionalReportInfo;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/dsc/TpDataSessionAdditionalReportInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionReportType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/dsc/TpDataSessionReportType:1.0
     */
     
    disc_s_TpDataSessionAdditionalReportInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpDataSessionAdditionalReportInfo == 2 ) {
     
        /*  Begin struct "org_csapi_dsc_TpDataSessionReleaseCause"  */

        

        decode_org_csapi_dsc_TpDataSessionReleaseCause_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_dsc_TpDataSessionReleaseCause"  */

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/gms/TpMessageInfoProperty:1.0 */

static void decode_org_csapi_gms_TpMessageInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessageInfoProperty;
    gchar   *seq = NULL;
    gint32    s_octet4;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/gms/TpMessageInfoProperty:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMessageInfoPropertyName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/gms/TpMessageInfoPropertyName:1.0
     */
     
    disc_s_TpMessageInfoProperty = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessageInfoProperty == 1 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingMessageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 2 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingMessageSubject (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 3 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingMessageDateSent (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 4 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingMessageDateReceived (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 5 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingMessageDateChanged (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 6 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 7 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 8 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 9 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 10 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"MessagingMessageSize = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 11 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMessagePriority,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 12 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMessageFormat,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 13 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingMessageFolder (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 14 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMessageStatus,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/gms/TpMailboxInfoProperty:1.0 */

static void decode_org_csapi_gms_TpMailboxInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMailboxInfoProperty;
    gchar   *seq = NULL;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/gms/TpMailboxInfoProperty:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMailboxInfoPropertyName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/gms/TpMailboxInfoPropertyName:1.0
     */
     
    disc_s_TpMailboxInfoProperty = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMailboxInfoProperty == 1 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMailboxInfoProperty == 2 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingMailboxOwner (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMailboxInfoProperty == 3 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingMailboxFolder (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMailboxInfoProperty == 4 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingMailboxDateCreated (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMailboxInfoProperty == 5 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingMailboxDateChanged (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/gms/TpMessagingEventInfo:1.0 */

static void decode_org_csapi_gms_TpMessagingEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessagingEventInfo;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/gms/TpMessagingEventInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMessagingEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/gms/TpMessagingEventName:1.0
     */
     
    disc_s_TpMessagingEventInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessagingEventInfo == 0 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"EventNameUndefined (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessagingEventInfo == 1 ) {
     
        /*  Begin struct "org_csapi_gms_TpGMSNewMessageArrivedInfo"  */

        

        decode_org_csapi_gms_TpGMSNewMessageArrivedInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_gms_TpGMSNewMessageArrivedInfo"  */

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/gms/TpMessagingEventCriteria:1.0 */

static void decode_org_csapi_gms_TpMessagingEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessagingEventCriteria;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/gms/TpMessagingEventCriteria:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMessagingEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/gms/TpMessagingEventName:1.0
     */
     
    disc_s_TpMessagingEventCriteria = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessagingEventCriteria == 1 ) {
     
        /*  Begin struct "org_csapi_gms_TpGMSNewMessageArrivedCriteria"  */

        

        decode_org_csapi_gms_TpGMSNewMessageArrivedCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_gms_TpGMSNewMessageArrivedCriteria"  */

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/gms/TpFolderInfoProperty:1.0 */

static void decode_org_csapi_gms_TpFolderInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpFolderInfoProperty;
    gchar   *seq = NULL;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/gms/TpFolderInfoProperty:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpFolderInfoPropertyName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/gms/TpFolderInfoPropertyName:1.0
     */
     
    disc_s_TpFolderInfoProperty = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpFolderInfoProperty == 1 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingFolderID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFolderInfoProperty == 2 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingFolderMessage (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFolderInfoProperty == 3 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingFolderSubfolder (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFolderInfoProperty == 4 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingFolderDateCreated (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFolderInfoProperty == 5 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessagingFolderDateChanged (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/cs/TpChargingParameterValue:1.0 */

static void decode_org_csapi_cs_TpChargingParameterValue_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpChargingParameterValue;
    gint32    s_octet4;
    gfloat    my_float;
    gchar   *seq = NULL;
    guint8    u_octet1;
    guint32   u_octet4_loop_OctetValue;
    guint32   i_OctetValue;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cs/TpChargingParameterValue:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingParameterValueType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cs/TpChargingParameterValueType:1.0
     */
     
    disc_s_TpChargingParameterValue = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpChargingParameterValue == 0 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"IntValue = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpChargingParameterValue == 1 ) {
     
        my_float = get_CDR_float(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"FloatValue = %.6e",my_float);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpChargingParameterValue == 2 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"StringValue (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpChargingParameterValue == 3 ) {
     
        u_octet1 = get_CDR_boolean(tvb,offset);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"BooleanValue = %u",u_octet1);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpChargingParameterValue == 4 ) {
     
        u_octet4_loop_OctetValue = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of OctetValue = %u",u_octet4_loop_OctetValue);
        }

        for (i_OctetValue=0; i_OctetValue < u_octet4_loop_OctetValue; i_OctetValue++) {

            u_octet1 = get_CDR_octet(tvb,offset);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"OctetValue = %u",u_octet1);
            }

        }

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/cs/TpAppInformation:1.0 */

static void decode_org_csapi_cs_TpAppInformation_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpAppInformation;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/cs/TpAppInformation:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpAppInformationType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cs/TpAppInformationType:1.0
     */
     
    disc_s_TpAppInformation = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpAppInformation == 0 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"Timestamp (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/policy/TpPolicyType:1.0 */

static void decode_org_csapi_policy_TpPolicyType_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpPolicyType;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/policy/TpPolicyType:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_policy_TpPolicyTypeInfo,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/policy/TpPolicyTypeInfo:1.0
     */
     
    disc_s_TpPolicyType = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpPolicyType == 0 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpSimpleAttributeTypeInfo,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPolicyType == 1 ) {
     
        /*  Begin struct "org_csapi_policy_TpPolicyType_TpPolicyRecordType"  */

        

        decode_org_csapi_policy_TpPolicyType_TpPolicyRecordType_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_policy_TpPolicyType_TpPolicyRecordType"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPolicyType == 2 ) {
     
        /*  Begin struct "org_csapi_policy_TpPolicyType_TpPolicyListType"  */

        

        decode_org_csapi_policy_TpPolicyType_TpPolicyListType_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_policy_TpPolicyType_TpPolicyListType"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPolicyType == 3 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"StructuredType (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPolicyType == 4 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"XMLString (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/pam/TpPAMContextData:1.0 */

static void decode_org_csapi_pam_TpPAMContextData_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpPAMContextData;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/pam/TpPAMContextData:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMContextName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/pam/TpPAMContextName:1.0
     */
     
    disc_s_TpPAMContextData = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpPAMContextData == 1 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMCommunicationContext"  */

        

        decode_org_csapi_pam_TpPAMCommunicationContext_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMCommunicationContext"  */

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/pam/TpPAMEventInfo:1.0 */

static void decode_org_csapi_pam_TpPAMEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpPAMEventInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/pam/TpPAMEventInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/pam/TpPAMEventName:1.0
     */
     
    disc_s_TpPAMEventInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpPAMEventInfo == 0 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMIPSEventData"  */

        

        decode_org_csapi_pam_TpPAMIPSEventData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMIPSEventData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMEventInfo == 1 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMAVCEventData"  */

        

        decode_org_csapi_pam_TpPAMAVCEventData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAVCEventData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMEventInfo == 2 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMWCEventData"  */

        

        decode_org_csapi_pam_TpPAMWCEventData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMWCEventData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMEventInfo == 3 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMICEventData"  */

        

        decode_org_csapi_pam_TpPAMICEventData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMICEventData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMEventInfo == 4 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMIDEventData"  */

        

        decode_org_csapi_pam_TpPAMIDEventData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMIDEventData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMEventInfo == 5 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMGMCEventData"  */

        

        decode_org_csapi_pam_TpPAMGMCEventData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMGMCEventData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMEventInfo == 6 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMACEventData"  */

        

        decode_org_csapi_pam_TpPAMACEventData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMACEventData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMEventInfo == 7 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMADEventData"  */

        

        decode_org_csapi_pam_TpPAMADEventData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMADEventData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMEventInfo == 8 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMAAEventData"  */

        

        decode_org_csapi_pam_TpPAMAAEventData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAAEventData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMEventInfo == 9 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMAUEventData"  */

        

        decode_org_csapi_pam_TpPAMAUEventData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAUEventData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMEventInfo == 10 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMCCEventData"  */

        

        decode_org_csapi_pam_TpPAMCCEventData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMCCEventData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMEventInfo == 11 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMACPSEventData"  */

        

        decode_org_csapi_pam_TpPAMACPSEventData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMACPSEventData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMEventInfo == 12 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMAPSEventData"  */

        

        decode_org_csapi_pam_TpPAMAPSEventData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAPSEventData"  */

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/pam/TpPAMNotificationInfo:1.0 */

static void decode_org_csapi_pam_TpPAMNotificationInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpPAMNotificationInfo;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/pam/TpPAMNotificationInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/pam/TpPAMEventName:1.0
     */
     
    disc_s_TpPAMNotificationInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpPAMNotificationInfo == 0 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMIPSNotificationData"  */

        

        decode_org_csapi_pam_TpPAMIPSNotificationData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMIPSNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMNotificationInfo == 1 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMAVCNotificationData"  */

        

        decode_org_csapi_pam_TpPAMAVCNotificationData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAVCNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMNotificationInfo == 2 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMWCNotificationData"  */

        

        decode_org_csapi_pam_TpPAMWCNotificationData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMWCNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMNotificationInfo == 3 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMICNotificationData"  */

        

        decode_org_csapi_pam_TpPAMICNotificationData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMICNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMNotificationInfo == 4 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMIDNotificationData"  */

        

        decode_org_csapi_pam_TpPAMIDNotificationData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMIDNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMNotificationInfo == 5 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMGMCNotificationData"  */

        

        decode_org_csapi_pam_TpPAMGMCNotificationData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMGMCNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMNotificationInfo == 6 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMACNotificationData"  */

        

        decode_org_csapi_pam_TpPAMACNotificationData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMACNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMNotificationInfo == 7 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMADNotificationData"  */

        

        decode_org_csapi_pam_TpPAMADNotificationData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMADNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMNotificationInfo == 8 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMAANotificationData"  */

        

        decode_org_csapi_pam_TpPAMAANotificationData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAANotificationData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMNotificationInfo == 9 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMAUNotificationData"  */

        

        decode_org_csapi_pam_TpPAMAUNotificationData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAUNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMNotificationInfo == 10 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMCCNotificationData"  */

        

        decode_org_csapi_pam_TpPAMCCNotificationData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMCCNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMNotificationInfo == 11 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMACPSNotificationData"  */

        

        decode_org_csapi_pam_TpPAMACPSNotificationData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMACPSNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpPAMNotificationInfo == 12 ) {
     
        /*  Begin struct "org_csapi_pam_TpPAMAPSNotificationData"  */

        

        decode_org_csapi_pam_TpPAMAPSNotificationData_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_pam_TpPAMAPSNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/pam/TpPAMPreferenceData:1.0 */

static void decode_org_csapi_pam_TpPAMPreferenceData_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpPAMPreferenceData;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/pam/TpPAMPreferenceData:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMPreferenceType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/pam/TpPAMPreferenceType:1.0
     */
     
    disc_s_TpPAMPreferenceData = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpPAMPreferenceData == 1 ) {
     
        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/mmm/TpFolderInfoProperty:1.0 */

static void decode_org_csapi_mmm_TpFolderInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpFolderInfoProperty;
    gchar   *seq = NULL;
    gint32    s_octet4;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpFolderInfoProperty:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpFolderInfoPropertyName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpFolderInfoPropertyName:1.0
     */
     
    disc_s_TpFolderInfoProperty = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpFolderInfoProperty == 1 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"FolderDateCreated (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFolderInfoProperty == 2 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"FolderDateChanged (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFolderInfoProperty == 3 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"FolderSize = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpFolderInfoProperty == 4 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"FolderNumberOfMessages = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/mmm/TpMailboxInfoProperty:1.0 */

static void decode_org_csapi_mmm_TpMailboxInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMailboxInfoProperty;
    gchar   *seq = NULL;
    gint32    s_octet4;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpMailboxInfoProperty:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMailboxInfoPropertyName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpMailboxInfoPropertyName:1.0
     */
     
    disc_s_TpMailboxInfoProperty = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMailboxInfoProperty == 1 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MailboxOwner (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMailboxInfoProperty == 2 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MailboxDateCreated (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMailboxInfoProperty == 3 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MailboxDateChanged (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMailboxInfoProperty == 4 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"MailboxSize = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/mmm/TpMessageInfoProperty:1.0 */

static void decode_org_csapi_mmm_TpMessageInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessageInfoProperty;
    gchar   *seq = NULL;
    gint32    s_octet4;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpMessageInfoProperty:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessageInfoPropertyName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpMessageInfoPropertyName:1.0
     */
     
    disc_s_TpMessageInfoProperty = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessageInfoProperty == 1 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessageDateCreated (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 2 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessageDateReceived (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 3 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MessageDateChanged (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 4 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"MessageSize = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageInfoProperty == 5 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMailboxMessageStatus,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/mmm/TpMessageHeaderField:1.0 */

static void decode_org_csapi_mmm_TpMessageHeaderField_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessageHeaderField;
    gchar   *seq = NULL;
    guint32   u_octet4_loop_From;
    guint32   i_From;
    guint32   u_octet4_loop_ReplyTo;
    guint32   i_ReplyTo;
    guint32   u_octet4_loop_To;
    guint32   i_To;
    guint32   u_octet4_loop_Cc;
    guint32   i_Cc;
    guint32   u_octet4_loop_Bcc;
    guint32   i_Bcc;
    guint32   u_octet4_loop_InReplyTo;
    guint32   i_InReplyTo;
    guint32   u_octet4_loop_References;
    guint32   i_References;
    guint32   u_octet4_loop_Keywords;
    guint32   i_Keywords;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpMessageHeaderField:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessageHeaderFieldType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpMessageHeaderFieldType:1.0
     */
     
    disc_s_TpMessageHeaderField = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessageHeaderField == 0 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"DateSent (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 1 ) {
     
        u_octet4_loop_From = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of From = %u",u_octet4_loop_From);
        }

        for (i_From=0; i_From < u_octet4_loop_From; i_From++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 2 ) {
     
        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 3 ) {
     
        u_octet4_loop_ReplyTo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of ReplyTo = %u",u_octet4_loop_ReplyTo);
        }

        for (i_ReplyTo=0; i_ReplyTo < u_octet4_loop_ReplyTo; i_ReplyTo++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 4 ) {
     
        u_octet4_loop_To = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of To = %u",u_octet4_loop_To);
        }

        for (i_To=0; i_To < u_octet4_loop_To; i_To++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 5 ) {
     
        u_octet4_loop_Cc = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of Cc = %u",u_octet4_loop_Cc);
        }

        for (i_Cc=0; i_Cc < u_octet4_loop_Cc; i_Cc++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 6 ) {
     
        u_octet4_loop_Bcc = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of Bcc = %u",u_octet4_loop_Bcc);
        }

        for (i_Bcc=0; i_Bcc < u_octet4_loop_Bcc; i_Bcc++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation);

            /*  End struct "org_csapi_TpAddress"  */

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 7 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"RFC822MessageID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 8 ) {
     
        u_octet4_loop_InReplyTo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of InReplyTo = %u",u_octet4_loop_InReplyTo);
        }

        for (i_InReplyTo=0; i_InReplyTo < u_octet4_loop_InReplyTo; i_InReplyTo++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"InReplyTo (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 9 ) {
     
        u_octet4_loop_References = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of References = %u",u_octet4_loop_References);
        }

        for (i_References=0; i_References < u_octet4_loop_References; i_References++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"References (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 10 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"Subject (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 11 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"Comments (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 12 ) {
     
        u_octet4_loop_Keywords = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of Keywords = %u",u_octet4_loop_Keywords);
        }

        for (i_Keywords=0; i_Keywords < u_octet4_loop_Keywords; i_Keywords++) {

            u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"Keywords (%u) = %s",
                  u_octet4, (u_octet4 > 0) ? seq : "");
            }

            g_free(seq);          /*  free buffer  */
            seq = NULL;

        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 13 ) {
     
        /*  Begin struct "org_csapi_mmm_TpGenericHeaderField"  */

        

        decode_org_csapi_mmm_TpGenericHeaderField_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpGenericHeaderField"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 14 ) {
     
        /*  Begin struct "org_csapi_mmm_TpGenericHeaderField"  */

        

        decode_org_csapi_mmm_TpGenericHeaderField_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpGenericHeaderField"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 15 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MimeVersion (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 16 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MimeContent (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 17 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MimeEncoding (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 18 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MimeID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 19 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MimeDescription (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 20 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"MimeDisposition (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 21 ) {
     
        /*  Begin struct "org_csapi_mmm_TpGenericHeaderField"  */

        

        decode_org_csapi_mmm_TpGenericHeaderField_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpGenericHeaderField"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 22 ) {
     
        /*  Begin struct "org_csapi_mmm_TpGenericHeaderField"  */

        

        decode_org_csapi_mmm_TpGenericHeaderField_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpGenericHeaderField"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageHeaderField == 23 ) {
     
        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagePriority,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/mmm/TpDeliveryTime:1.0 */

static void decode_org_csapi_mmm_TpDeliveryTime_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpDeliveryTime;
    gchar   *seq = NULL;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpDeliveryTime:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpDeliveryTimeType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpDeliveryTimeType:1.0
     */
     
    disc_s_TpDeliveryTime = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpDeliveryTime == 1 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"DeliveryTime (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/mmm/TpMessageTreatment:1.0 */

static void decode_org_csapi_mmm_TpMessageTreatment_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessageTreatment;
    gint32    s_octet4;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpMessageTreatment:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessageTreatmentType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpMessageTreatmentType:1.0
     */
     
    disc_s_TpMessageTreatment = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessageTreatment == 1 ) {
     
        s_octet4 = get_CDR_long(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"DeliveryReport = %i",s_octet4);
        }

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageTreatment == 2 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"BillingID (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageTreatment == 3 ) {
     
        /*  Begin union "org_csapi_mmm_TpDeliveryTime"  */

        
        decode_org_csapi_mmm_TpDeliveryTime_un(tvb, pinfo, tree, offset, header, operation);

        /*  End union "org_csapi_mmm_TpDeliveryTime"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessageTreatment == 4 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"ValidityTime (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
}

/* Union = IDL:org/csapi/mmm/TpMessagingEventCriteria:1.0 */

static void decode_org_csapi_mmm_TpMessagingEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessagingEventCriteria;
    gint16    s_octet2;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpMessagingEventCriteria:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpMessagingEventName:1.0
     */
     
    disc_s_TpMessagingEventCriteria = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessagingEventCriteria == 1 ) {
     
        /*  Begin struct "org_csapi_mmm_TpNewMailboxMessageArrivedCriteria"  */

        

        decode_org_csapi_mmm_TpNewMailboxMessageArrivedCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpNewMailboxMessageArrivedCriteria"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessagingEventCriteria == 2 ) {
     
        /*  Begin struct "org_csapi_mmm_TpNewMessageArrivedCriteria"  */

        

        decode_org_csapi_mmm_TpNewMessageArrivedCriteria_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpNewMessageArrivedCriteria"  */

        return;     /* End Compare for this discriminant type */
    }
     
    
    /* Default Union Case Start */

    s_octet2 = get_CDR_short(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",s_octet2);
    }

    /* Default Union Case End */
     
}

/* Union = IDL:org/csapi/mmm/TpMessagingEventInfo:1.0 */

static void decode_org_csapi_mmm_TpMessagingEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_) {

    gboolean stream_is_big_endian;          /* big endianess */

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessagingEventInfo;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    stream_is_big_endian = is_big_endian(header);  /* get stream endianess */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpMessagingEventInfo:1.0
     */
     
    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"Enum value = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpMessagingEventName:1.0
     */
     
    disc_s_TpMessagingEventInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessagingEventInfo == 0 ) {
     
        u_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"EventNameUndefined (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }

        g_free(seq);          /*  free buffer  */
        seq = NULL;

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessagingEventInfo == 1 ) {
     
        /*  Begin struct "org_csapi_mmm_TpNewMailboxMessageArrivedInfo"  */

        

        decode_org_csapi_mmm_TpNewMailboxMessageArrivedInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpNewMailboxMessageArrivedInfo"  */

        return;     /* End Compare for this discriminant type */
    }
     
    if (disc_s_TpMessagingEventInfo == 2 ) {
     
        /*  Begin struct "org_csapi_mmm_TpNewMessageArrivedInfo"  */

        

        decode_org_csapi_mmm_TpNewMessageArrivedInfo_st(tvb, pinfo, tree, offset, header, operation);

        /*  End struct "org_csapi_mmm_TpNewMessageArrivedInfo"  */

        return;     /* End Compare for this discriminant type */
    }
     
}

/*
 * Called once we accept the packet as being for us; it sets the
 * Protocol and Info columns and creates the top-level protocol
 * tree item.
 */
static proto_tree *start_dissecting(tvbuff_t *tvb, packet_info *pinfo, proto_tree *ptree, int *offset) {

    proto_item *ti = NULL;
    proto_tree *tree = NULL;            /* init later, inside if(tree) */

    if (check_col(pinfo->cinfo, COL_PROTOCOL))
        col_set_str(pinfo->cinfo, COL_PROTOCOL, "PARLAY");

    /*
     * Do not clear COL_INFO, as nothing is being written there by
     * this dissector yet. So leave it as is from the GIOP dissector.
     * TODO: add something useful to COL_INFO
     *  if (check_col(pinfo->cinfo, COL_INFO))
     *     col_clear(pinfo->cinfo, COL_INFO);
     */

    if (ptree) {
        ti = proto_tree_add_item(ptree, proto_parlay, tvb, *offset, -1, FALSE);
        tree = proto_item_add_subtree(ti, ett_parlay);
    }
    return tree;
}

static gboolean dissect_parlay(tvbuff_t *tvb, packet_info *pinfo, proto_tree *ptree, int *offset, MessageHeader *header, gchar *operation, gchar *idlname) {

    gboolean be;                        /* big endianess */
    proto_tree *tree _U_;

    be = is_big_endian(header);         /* get endianess - TODO use passed in stream_is_big_endian instead ? */

    /* If we have a USER Exception, then decode it and return */

    if ((header->message_type == Reply) && (header->rep_status == USER_EXCEPTION)) {

       return decode_user_exception(tvb, pinfo, ptree, offset, header, operation);

    }

    switch(header->message_type) {

    case Request:
    case Reply:

        if (strcmp(operation, org_csapi_IpService_setCallback_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/IpService") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_IpService_setCallback(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_IpService_setCallbackWithSessionID_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/IpService") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_IpService_setCallbackWithSessionID(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpInitial_initiateAuthentication_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpInitial") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpInitial_initiateAuthentication(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpInitial_initiateAuthenticationWithVersion_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpInitial") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpInitial_initiateAuthenticationWithVersion(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAuthentication_requestAccess_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAuthentication") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAuthentication_requestAccess(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpClientAccess_terminateAccess_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpClientAccess") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpClientAccess_terminateAccess(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAccess_obtainInterface_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_obtainInterface(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAccess_obtainInterfaceWithCallback_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_obtainInterfaceWithCallback(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAccess_endAccess_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_endAccess(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAccess_listInterfaces_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_listInterfaces(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAccess_releaseInterface_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_releaseInterface(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAccess_selectSigningAlgorithm_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_selectSigningAlgorithm(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAccess_terminateAccess_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_terminateAccess(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAccess_relinquishInterface_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_relinquishInterface(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_authenticate_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_authenticate(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_abortAuthentication_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_abortAuthentication(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_authenticationSucceeded_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_authenticationSucceeded(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_challenge_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_challenge(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_selectEncryptionMethod_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_selectEncryptionMethod(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_authenticate_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_authenticate(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_abortAuthentication_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_abortAuthentication(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_authenticationSucceeded_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_authenticationSucceeded(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_selectAuthenticationMechanism_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_selectAuthenticationMechanism(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_challenge_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_challenge(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_notification_IpAppEventNotification_reportNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/notification/IpAppEventNotification") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_notification_IpAppEventNotification_reportNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_notification_IpAppEventNotification_notificationTerminated_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/notification/IpAppEventNotification") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_notification_IpAppEventNotification_notificationTerminated(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_notification_IpEventNotification_createNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/notification/IpEventNotification") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_notification_IpEventNotification_createNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_notification_IpEventNotification_destroyNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/notification/IpEventNotification") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_notification_IpEventNotification_destroyNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_activityTestRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_activityTestRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_appActivityTestReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_appActivityTestReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwFaultReportInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwFaultReportInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwFaultRecoveryInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwFaultRecoveryInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_svcUnavailableInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_svcUnavailableInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwUnavailableInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwUnavailableInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_activityTestErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_activityTestErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_appUnavailableInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_appUnavailableInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_svcAvailStatusInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_svcAvailStatusInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwAvailStatusInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwAvailStatusInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryAppLoadReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryAppLoadReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppLoadManager_loadLevelNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_loadLevelNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppLoadManager_resumeNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_resumeNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppLoadManager_suspendNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_suspendNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppLoadManager_createLoadLevelNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_createLoadLevelNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppLoadManager_destroyLoadLevelNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_destroyLoadLevelNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryAppLoadStatsReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryAppLoadStatsReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadStatsRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadStatsRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadStatsErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadStatsErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpLoadManager_reportLoad_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_reportLoad(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpLoadManager_queryLoadReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryLoadReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpLoadManager_createLoadLevelNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_createLoadLevelNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpLoadManager_destroyLoadLevelNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_destroyLoadLevelNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpLoadManager_resumeNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_resumeNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpLoadManager_suspendNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_suspendNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpLoadManager_queryLoadStatsReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryLoadStatsReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadStatsRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadStatsRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadStatsErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadStatsErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppOAM_systemDateTimeQuery_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppOAM") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppOAM_systemDateTimeQuery(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpOAM_systemDateTimeQuery_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpOAM") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpOAM_systemDateTimeQuery(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpFaultManager_activityTestReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_activityTestReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpFaultManager_appActivityTestRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appActivityTestRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpFaultManager_svcUnavailableInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_svcUnavailableInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpFaultManager_appActivityTestErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appActivityTestErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpFaultManager_appUnavailableInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appUnavailableInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpFaultManager_appAvailStatusInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appAvailStatusInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_enableHeartBeat_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpHeartBeatMgmt") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_enableHeartBeat(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_disableHeartBeat_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpHeartBeatMgmt") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_disableHeartBeat(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_changeInterval_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpHeartBeatMgmt") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_changeInterval(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppHeartBeat_pulse_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppHeartBeat") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeat_pulse(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpHeartBeat_pulse_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpHeartBeat") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpHeartBeat_pulse(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_enableAppHeartBeat_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppHeartBeatMgmt") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_enableAppHeartBeat(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_disableAppHeartBeat_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppHeartBeatMgmt") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_disableAppHeartBeat(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_changeInterval_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppHeartBeatMgmt") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_changeInterval(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_discovery_IpServiceDiscovery_listServiceTypes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/discovery/IpServiceDiscovery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_listServiceTypes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_discovery_IpServiceDiscovery_describeServiceType_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/discovery/IpServiceDiscovery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_describeServiceType(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_discovery_IpServiceDiscovery_discoverService_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/discovery/IpServiceDiscovery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_discoverService(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_discovery_IpServiceDiscovery_listSubscribedServices_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/discovery/IpServiceDiscovery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_listSubscribedServices(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_service_agreement_IpAppServiceAgreementManagement_signServiceAgreement_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/service_agreement/IpAppServiceAgreementManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_service_agreement_IpAppServiceAgreementManagement_signServiceAgreement(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_service_agreement_IpAppServiceAgreementManagement_terminateServiceAgreement_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/service_agreement/IpAppServiceAgreementManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_service_agreement_IpAppServiceAgreementManagement_terminateServiceAgreement(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_signServiceAgreement_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_signServiceAgreement(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_terminateServiceAgreement_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_terminateServiceAgreement(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_selectService_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_selectService(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_initiateSignServiceAgreement_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_initiateSignServiceAgreement(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_createServiceProfile_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_createServiceProfile(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_modifyServiceProfile_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_modifyServiceProfile(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_deleteServiceProfile_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_deleteServiceProfile(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_assign_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_assign(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_deassign_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_deassign(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_requestConflictInfo_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_requestConflictInfo(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_listServiceProfiles_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileInfoQuery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_listServiceProfiles(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_describeServiceProfile_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileInfoQuery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_describeServiceProfile(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_listAssignedMembers_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileInfoQuery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_listAssignedMembers(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_createServiceContract_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_createServiceContract(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_modifyServiceContract_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_modifyServiceContract(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_deleteServiceContract_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_deleteServiceContract(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_describeServiceContract_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractInfoQuery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_describeServiceContract(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_listServiceContracts_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractInfoQuery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_listServiceContracts(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_listServiceProfiles_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractInfoQuery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_listServiceProfiles(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountManagement_modifyEntOpAccount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountManagement_modifyEntOpAccount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountManagement_deleteEntOpAccount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountManagement_deleteEntOpAccount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountInfoQuery_describeEntOpAccount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountInfoQuery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountInfoQuery_describeEntOpAccount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_createClientApp_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_createClientApp(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_modifyClientApp_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_modifyClientApp(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_deleteClientApp_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_deleteClientApp(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_createSAG_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_createSAG(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_modifySAG_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_modifySAG(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_deleteSAG_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_deleteSAG(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_addSAGMembers_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_addSAGMembers(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_removeSAGMembers_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_removeSAGMembers(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_requestConflictInfo_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_requestConflictInfo(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_describeClientApp_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_describeClientApp(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listClientApps_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listClientApps(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_describeSAG_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_describeSAG(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listSAGs_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listSAGs(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listSAGMembers_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listSAGMembers(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listClientAppMembership_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listClientAppMembership(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_notification_IpClientEventNotification_reportNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/notification/IpClientEventNotification") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_notification_IpClientEventNotification_reportNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_notification_IpClientEventNotification_notificationTerminated_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/notification/IpClientEventNotification") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_notification_IpClientEventNotification_notificationTerminated(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_notification_IpEventNotification_createNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/notification/IpEventNotification") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_notification_IpEventNotification_createNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_enterprise_operator_notification_IpEventNotification_destroyNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/notification/IpEventNotification") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_notification_IpEventNotification_destroyNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_listServiceTypes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_listServiceTypes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_describeServiceType_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_describeServiceType(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_discoverService_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_discoverService(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_listRegisteredServices_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_listRegisteredServices(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_service_lifecycle_IpServiceInstanceLifecycleManager_createServiceManager_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_lifecycle/IpServiceInstanceLifecycleManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_lifecycle_IpServiceInstanceLifecycleManager_createServiceManager(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_service_lifecycle_IpServiceInstanceLifecycleManager_destroyServiceManager_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_lifecycle/IpServiceInstanceLifecycleManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_lifecycle_IpServiceInstanceLifecycleManager_destroyServiceManager(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_registerService_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_registerService(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_announceServiceAvailability_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_announceServiceAvailability(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_unregisterService_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_unregisterService(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_describeService_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_describeService(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_unannounceService_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_unannounceService(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_registerServiceSubType_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_registerServiceSubType(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcLoadManager_querySvcLoadReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_querySvcLoadReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcLoadManager_loadLevelNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_loadLevelNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcLoadManager_suspendNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_suspendNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcLoadManager_resumeNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_resumeNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcLoadManager_createLoadLevelNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_createLoadLevelNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcLoadManager_destroyLoadLevelNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_destroyLoadLevelNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcLoadManager_querySvcLoadStatsReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_querySvcLoadStatsReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadStatsRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadStatsRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadStatsErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadStatsErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwLoadManager_reportLoad_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_reportLoad(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwLoadManager_queryLoadReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_queryLoadReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwLoadManager_createLoadLevelNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_createLoadLevelNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwLoadManager_destroyLoadLevelNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_destroyLoadLevelNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwLoadManager_suspendNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_suspendNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwLoadManager_resumeNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_resumeNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwLoadManager_queryLoadStatsReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_queryLoadStatsReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadStatsRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadStatsRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadStatsErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadStatsErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_activityTestRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_activityTestRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_svcActivityTestReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_svcActivityTestReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwFaultReportInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwFaultReportInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwFaultRecoveryInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwFaultRecoveryInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwUnavailableInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwUnavailableInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_svcUnavailableInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_svcUnavailableInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_appUnavailableInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_appUnavailableInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_activityTestErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_activityTestErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatsRecordReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatsRecordReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_appAvailStatusInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_appAvailStatusInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwAvailStatusInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwAvailStatusInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwFaultManager_activityTestReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_activityTestReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcActivityTestRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcActivityTestRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwFaultManager_appUnavailableInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_appUnavailableInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcUnavailableInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcUnavailableInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcActivityTestErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcActivityTestErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatsRecordRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatsRecordRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatsRecordErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatsRecordErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcAvailStatusInd_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcAvailStatusInd(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcOAM_systemDateTimeQuery_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcOAM") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcOAM_systemDateTimeQuery(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwOAM_systemDateTimeQuery_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwOAM") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwOAM_systemDateTimeQuery(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_enableHeartBeat_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwHeartBeatMgmt") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_enableHeartBeat(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_disableHeartBeat_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwHeartBeatMgmt") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_disableHeartBeat(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_changeInterval_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwHeartBeatMgmt") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_changeInterval(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcHeartBeat_pulse_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcHeartBeat") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeat_pulse(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpFwHeartBeat_pulse_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwHeartBeat") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeat_pulse(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_enableSvcHeartBeat_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcHeartBeatMgmt") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_enableSvcHeartBeat(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_disableSvcHeartBeat_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcHeartBeatMgmt") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_disableSvcHeartBeat(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_changeInterval_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcHeartBeatMgmt") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_changeInterval(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_notification_IpFwEventNotification_createNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/notification/IpFwEventNotification") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_notification_IpFwEventNotification_createNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_notification_IpFwEventNotification_destroyNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/notification/IpFwEventNotification") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_notification_IpFwEventNotification_destroyNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_notification_IpSvcEventNotification_reportNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/notification/IpSvcEventNotification") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_notification_IpSvcEventNotification_reportNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_fw_fw_service_notification_IpSvcEventNotification_notificationTerminated_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/notification/IpSvcEventNotification") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_notification_IpSvcEventNotification_notificationTerminated(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCall_routeRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_routeRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCall_routeErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_routeErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCall_getCallInfoRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_getCallInfoRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCall_getCallInfoErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_getCallInfoErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCall_superviseCallRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_superviseCallRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCall_superviseCallErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_superviseCallErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCall_callFaultDetected_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_callFaultDetected(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCall_getMoreDialledDigitsRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_getMoreDialledDigitsRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCall_getMoreDialledDigitsErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_getMoreDialledDigitsErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCall_callEnded_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_callEnded(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCall_routeReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_routeReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCall_release_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_release(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCall_deassignCall_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_deassignCall(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCall_getCallInfoReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_getCallInfoReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCall_setCallChargePlan_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_setCallChargePlan(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCall_setAdviceOfCharge_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_setAdviceOfCharge(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCall_getMoreDialledDigitsReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_getMoreDialledDigitsReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCall_superviseCallReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_superviseCallReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCall_continueProcessing_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_continueProcessing(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCallControlManager_callAborted_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCallControlManager_callAborted(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCallControlManager_callEventNotify_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCallControlManager_callEventNotify(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCallControlManager_callNotificationInterrupted_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCallControlManager_callNotificationInterrupted(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCallControlManager_callNotificationContinued_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCallControlManager_callNotificationContinued(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCallControlManager_callOverloadEncountered_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCallControlManager_callOverloadEncountered(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCallControlManager_callOverloadCeased_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCallControlManager_callOverloadCeased(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpAppCallControlManager_abortMultipleCalls_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCallControlManager_abortMultipleCalls(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCallControlManager_createCall_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCallControlManager_createCall(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCallControlManager_enableCallNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCallControlManager_enableCallNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCallControlManager_disableCallNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCallControlManager_disableCallNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCallControlManager_setCallLoadControl_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCallControlManager_setCallLoadControl(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCallControlManager_changeCallNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCallControlManager_changeCallNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_gccs_IpCallControlManager_getCriteria_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCallControlManager_getCriteria(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppCallLeg_eventReportRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_eventReportRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppCallLeg_eventReportErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_eventReportErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppCallLeg_attachMediaRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_attachMediaRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppCallLeg_attachMediaErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_attachMediaErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppCallLeg_detachMediaRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_detachMediaRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppCallLeg_detachMediaErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_detachMediaErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppCallLeg_getInfoRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_getInfoRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppCallLeg_getInfoErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_getInfoErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppCallLeg_routeErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_routeErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppCallLeg_superviseRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_superviseRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppCallLeg_superviseErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_superviseErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppCallLeg_callLegEnded_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_callLegEnded(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCallControlManager_createCall_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_createCall(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCallControlManager_createNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_createNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCallControlManager_destroyNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_destroyNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCallControlManager_changeNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_changeNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCallControlManager_getNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_getNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCallControlManager_setCallLoadControl_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_setCallLoadControl(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCallControlManager_enableNotifications_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_enableNotifications(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCallControlManager_disableNotifications_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_disableNotifications(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCallControlManager_getNextNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_getNextNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_routeReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_routeReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_eventReportReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_eventReportReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_release_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_release(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_getInfoReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_getInfoReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_getCall_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_getCall(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_attachMediaReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_attachMediaReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_detachMediaReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_detachMediaReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_getCurrentDestinationAddress_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_getCurrentDestinationAddress(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_continueProcessing_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_continueProcessing(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_setChargePlan_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_setChargePlan(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_setAdviceOfCharge_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_setAdviceOfCharge(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_superviseReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_superviseReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_deassign_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_deassign(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_getProperties_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_getProperties(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpCallLeg_setProperties_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_setProperties(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppMultiPartyCall_getInfoRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_getInfoRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppMultiPartyCall_getInfoErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_getInfoErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppMultiPartyCall_superviseRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_superviseRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppMultiPartyCall_superviseErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_superviseErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppMultiPartyCall_callEnded_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_callEnded(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppMultiPartyCall_createAndRouteCallLegErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_createAndRouteCallLegErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCall_getCallLegs_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_getCallLegs(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCall_createCallLeg_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_createCallLeg(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCall_createAndRouteCallLegReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_createAndRouteCallLegReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCall_release_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_release(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCall_deassignCall_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_deassignCall(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCall_getInfoReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_getInfoReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCall_setChargePlan_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_setChargePlan(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCall_setAdviceOfCharge_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_setAdviceOfCharge(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpMultiPartyCall_superviseReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_superviseReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_reportNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_reportNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callAborted_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callAborted(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_managerInterrupted_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_managerInterrupted(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_managerResumed_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_managerResumed(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callOverloadEncountered_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callOverloadEncountered(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callOverloadCeased_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callOverloadCeased(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_abortMultipleCalls_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_abortMultipleCalls(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mmccs_IpAppMultiMediaCall_superviseVolumeRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpAppMultiMediaCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpAppMultiMediaCall_superviseVolumeRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mmccs_IpAppMultiMediaCall_superviseVolumeErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpAppMultiMediaCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpAppMultiMediaCall_superviseVolumeErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mmccs_IpAppMultiMediaCallLeg_mediaStreamMonitorRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpAppMultiMediaCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpAppMultiMediaCallLeg_mediaStreamMonitorRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mmccs_IpMultiMediaStream_subtract_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaStream") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaStream_subtract(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mmccs_IpMultiMediaCallLeg_mediaStreamAllow_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCallLeg_mediaStreamAllow(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mmccs_IpMultiMediaCallLeg_mediaStreamMonitorReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCallLeg_mediaStreamMonitorReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mmccs_IpMultiMediaCallLeg_getMediaStreams_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCallLeg") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCallLeg_getMediaStreams(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mmccs_IpMultiMediaCall_superviseVolumeReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCall_superviseVolumeReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mmccs_IpAppMultiMediaCallControlManager_reportMediaNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpAppMultiMediaCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpAppMultiMediaCallControlManager_reportMediaNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mmccs_IpMultiMediaCallControlManager_createMediaNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_createMediaNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mmccs_IpMultiMediaCallControlManager_destroyMediaNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_destroyMediaNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mmccs_IpMultiMediaCallControlManager_changeMediaNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_changeMediaNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_mmccs_IpMultiMediaCallControlManager_getMediaNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_getMediaNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpAppSubConfCall_chairSelection_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpAppSubConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpAppSubConfCall_chairSelection(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpAppSubConfCall_floorRequest_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpAppSubConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpAppSubConfCall_floorRequest(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpAppConfCall_partyJoined_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpAppConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpAppConfCall_partyJoined(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpAppConfCall_leaveMonitorRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpAppConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpAppConfCall_leaveMonitorRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpConfCallControlManager_createConference_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCallControlManager_createConference(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpConfCallControlManager_checkResources_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCallControlManager_checkResources(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpConfCallControlManager_reserveResources_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCallControlManager_reserveResources(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpConfCallControlManager_freeResources_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCallControlManager_freeResources(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpAppConfCallControlManager_conferenceCreated_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpAppConfCallControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpAppConfCallControlManager_conferenceCreated(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpSubConfCall_splitSubConference_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_splitSubConference(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpSubConfCall_mergeSubConference_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_mergeSubConference(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpSubConfCall_moveCallLeg_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_moveCallLeg(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpSubConfCall_inspectVideo_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_inspectVideo(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpSubConfCall_inspectVideoCancel_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_inspectVideoCancel(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpSubConfCall_appointSpeaker_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_appointSpeaker(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpSubConfCall_chairSelection_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_chairSelection(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpSubConfCall_changeConferencePolicy_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_changeConferencePolicy(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpConfCall_getSubConferences_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCall_getSubConferences(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpConfCall_createSubConference_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCall_createSubConference(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpConfCall_leaveMonitorReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCall_leaveMonitorReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cc_cccs_IpConfCall_getConferenceAddress_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCall_getConferenceAddress(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUI_sendInfoRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUI") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUI_sendInfoRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUI_sendInfoErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUI") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUI_sendInfoErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUI_sendInfoAndCollectRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUI") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUI_sendInfoAndCollectRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUI_sendInfoAndCollectErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUI") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUI_sendInfoAndCollectErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUI_userInteractionFaultDetected_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUI") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUI_userInteractionFaultDetected(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUICall_recordMessageRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_recordMessageRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUICall_recordMessageErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_recordMessageErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUICall_deleteMessageRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_deleteMessageRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUICall_deleteMessageErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_deleteMessageErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUICall_abortActionRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_abortActionRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUICall_abortActionErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_abortActionErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUICall_getMessageRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_getMessageRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUICall_getMessageErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_getMessageErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUIManager_userInteractionAborted_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIManager_userInteractionAborted(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUIManager_userInteractionNotificationInterrupted_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIManager_userInteractionNotificationInterrupted(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUIManager_userInteractionNotificationContinued_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIManager_userInteractionNotificationContinued(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUIManager_reportEventNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIManager_reportEventNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUIManager_abortMultipleUserInteractions_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIManager_abortMultipleUserInteractions(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUI_sendInfoReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUI") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUI_sendInfoReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUI_sendInfoAndCollectReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUI") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUI_sendInfoAndCollectReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUI_release_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUI") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUI_release(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUI_setOriginatingAddress_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUI") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUI_setOriginatingAddress(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUI_getOriginatingAddress_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUI") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUI_getOriginatingAddress(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUICall_recordMessageReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUICall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUICall_recordMessageReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUICall_deleteMessageReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUICall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUICall_deleteMessageReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUICall_abortActionReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUICall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUICall_abortActionReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUICall_getMessageReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUICall") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUICall_getMessageReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUIManager_createUI_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_createUI(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUIManager_createUICall_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_createUICall(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUIManager_createNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_createNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUIManager_destroyNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_destroyNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUIManager_changeNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_changeNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUIManager_getNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_getNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUIManager_enableNotifications_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_enableNotifications(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUIManager_disableNotifications_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_disableNotifications(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUIAdminManager_getMessageRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_getMessageRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUIAdminManager_getMessageErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_getMessageErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUIAdminManager_deleteMessageRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_deleteMessageRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUIAdminManager_deleteMessageErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_deleteMessageErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUIAdminManager_putMessageRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_putMessageRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUIAdminManager_putMessageErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_putMessageErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUIAdminManager_getMessageListRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_getMessageListRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpAppUIAdminManager_getMessageListErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_getMessageListErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUIAdminManager_getMessageReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIAdminManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIAdminManager_getMessageReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUIAdminManager_putMessageReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIAdminManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIAdminManager_putMessageReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUIAdminManager_deleteMessageReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIAdminManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIAdminManager_deleteMessageReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_ui_IpUIAdminManager_getMessageListReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIAdminManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIAdminManager_getMessageListReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpAppUserLocation_locationReportRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppUserLocation_locationReportRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpAppUserLocation_locationReportErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppUserLocation_locationReportErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpAppUserLocation_extendedLocationReportRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppUserLocation_extendedLocationReportRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpAppUserLocation_extendedLocationReportErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppUserLocation_extendedLocationReportErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpAppUserLocation_periodicLocationReport_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppUserLocation_periodicLocationReport(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpAppUserLocation_periodicLocationReportErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppUserLocation_periodicLocationReportErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpUserLocation_locationReportReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpUserLocation_locationReportReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpUserLocation_extendedLocationReportReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpUserLocation_extendedLocationReportReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpUserLocation_periodicLocationReportingStartReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpUserLocation_periodicLocationReportingStartReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpUserLocation_periodicLocationReportingStop_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpUserLocation_periodicLocationReportingStop(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpUserLocation_getNextPeriodicLocationRequest_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpUserLocation_getNextPeriodicLocationRequest(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpAppTriggeredUserLocation_triggeredLocationReport_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppTriggeredUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppTriggeredUserLocation_triggeredLocationReport(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpAppTriggeredUserLocation_triggeredLocationReportErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppTriggeredUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppTriggeredUserLocation_triggeredLocationReportErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpTriggeredUserLocation_triggeredLocationReportingStartReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpTriggeredUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpTriggeredUserLocation_triggeredLocationReportingStartReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpTriggeredUserLocation_triggeredLocationReportingStop_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpTriggeredUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpTriggeredUserLocation_triggeredLocationReportingStop(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ul_IpTriggeredUserLocation_getNextTriggeredLocationRequest_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpTriggeredUserLocation") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpTriggeredUserLocation_getNextTriggeredLocationRequest(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ulc_IpAppUserLocationCamel_locationReportRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpAppUserLocationCamel") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpAppUserLocationCamel_locationReportRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ulc_IpAppUserLocationCamel_locationReportErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpAppUserLocationCamel") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpAppUserLocationCamel_locationReportErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ulc_IpAppUserLocationCamel_periodicLocationReport_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpAppUserLocationCamel") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpAppUserLocationCamel_periodicLocationReport(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ulc_IpAppUserLocationCamel_periodicLocationReportErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpAppUserLocationCamel") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpAppUserLocationCamel_periodicLocationReportErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ulc_IpAppUserLocationCamel_triggeredLocationReport_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpAppUserLocationCamel") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpAppUserLocationCamel_triggeredLocationReport(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ulc_IpAppUserLocationCamel_triggeredLocationReportErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpAppUserLocationCamel") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpAppUserLocationCamel_triggeredLocationReportErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ulc_IpUserLocationCamel_locationReportReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpUserLocationCamel") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpUserLocationCamel_locationReportReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ulc_IpUserLocationCamel_periodicLocationReportingStartReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpUserLocationCamel") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpUserLocationCamel_periodicLocationReportingStartReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ulc_IpUserLocationCamel_periodicLocationReportingStop_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpUserLocationCamel") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpUserLocationCamel_periodicLocationReportingStop(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ulc_IpUserLocationCamel_triggeredLocationReportingStartReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpUserLocationCamel") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpUserLocationCamel_triggeredLocationReportingStartReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ulc_IpUserLocationCamel_triggeredLocationReportingStop_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpUserLocationCamel") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpUserLocationCamel_triggeredLocationReportingStop(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ulc_IpUserLocationCamel_getNextPeriodicLocationRequest_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpUserLocationCamel") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpUserLocationCamel_getNextPeriodicLocationRequest(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ulc_IpUserLocationCamel_getNextTriggeredLocationRequest_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpUserLocationCamel") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpUserLocationCamel_getNextTriggeredLocationRequest(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ule_IpAppUserLocationEmergency_emergencyLocationReport_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ule/IpAppUserLocationEmergency") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ule_IpAppUserLocationEmergency_emergencyLocationReport(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ule_IpAppUserLocationEmergency_emergencyLocationReportErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ule/IpAppUserLocationEmergency") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ule_IpAppUserLocationEmergency_emergencyLocationReportErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ule_IpUserLocationEmergency_emergencyLocationReportReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ule/IpUserLocationEmergency") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ule_IpUserLocationEmergency_emergencyLocationReportReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ule_IpUserLocationEmergency_subscribeEmergencyLocationReports_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ule/IpUserLocationEmergency") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ule_IpUserLocationEmergency_subscribeEmergencyLocationReports(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ule_IpUserLocationEmergency_unSubscribeEmergencyLocationReports_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ule/IpUserLocationEmergency") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ule_IpUserLocationEmergency_unSubscribeEmergencyLocationReports(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpAppUserStatus_statusReportRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_statusReportRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpAppUserStatus_statusReportErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_statusReportErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpAppUserStatus_triggeredStatusReport_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_triggeredStatusReport(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpAppUserStatus_triggeredStatusReportErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_triggeredStatusReportErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpAppUserStatus_extendedStatusReportRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_extendedStatusReportRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpAppUserStatus_extendedStatusReportErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_extendedStatusReportErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpAppUserStatus_extTriggeredStatusReport_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_extTriggeredStatusReport(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpAppUserStatus_extTriggeredStatusReportErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_extTriggeredStatusReportErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpUserStatus_statusReportReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpUserStatus_statusReportReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpUserStatus_triggeredStatusReportingStartReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpUserStatus_triggeredStatusReportingStartReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpUserStatus_triggeredStatusReportingStop_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpUserStatus_triggeredStatusReportingStop(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpUserStatus_getNextTriggeredStatusRequest_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpUserStatus_getNextTriggeredStatusRequest(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpUserStatus_extendedStatusReportReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpUserStatus_extendedStatusReportReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpUserStatus_extTriggeredStatusReportingStartReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpUserStatus_extTriggeredStatusReportingStartReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_us_IpUserStatus_extTriggeredStatusReportingStop_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpUserStatus") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpUserStatus_extTriggeredStatusReportingStop(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ub_IpAppUserBinding_triggeredBindingRequestNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ub/IpAppUserBinding") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ub_IpAppUserBinding_triggeredBindingRequestNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ub_IpAppUserBinding_triggeredBindingRequestNotificationStartErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ub/IpAppUserBinding") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ub_IpAppUserBinding_triggeredBindingRequestNotificationStartErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ub_IpUserBinding_triggeredBindingRequestNotificationStartReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ub/IpUserBinding") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ub_IpUserBinding_triggeredBindingRequestNotificationStartReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mm_ub_IpUserBinding_triggeredBindingRequestNotificationStop_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ub/IpUserBinding") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ub_IpUserBinding_triggeredBindingRequestNotificationStop(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_termcap_IpTerminalCapabilities_getTerminalCapabilities_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/termcap/IpTerminalCapabilities") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_termcap_IpTerminalCapabilities_getTerminalCapabilities(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_termcap_IpAppExtendedTerminalCapabilities_triggeredTerminalCapabilityReport_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/termcap/IpAppExtendedTerminalCapabilities") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_termcap_IpAppExtendedTerminalCapabilities_triggeredTerminalCapabilityReport(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_termcap_IpAppExtendedTerminalCapabilities_triggeredTerminalCapabilityReportErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/termcap/IpAppExtendedTerminalCapabilities") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_termcap_IpAppExtendedTerminalCapabilities_triggeredTerminalCapabilityReportErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_termcap_IpExtendedTerminalCapabilities_triggeredTerminalCapabilityStartReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/termcap/IpExtendedTerminalCapabilities") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_termcap_IpExtendedTerminalCapabilities_triggeredTerminalCapabilityStartReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_termcap_IpExtendedTerminalCapabilities_triggeredTerminalCapabilityStop_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/termcap/IpExtendedTerminalCapabilities") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_termcap_IpExtendedTerminalCapabilities_triggeredTerminalCapabilityStop(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpAppDataSession_connectRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSession_connectRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpAppDataSession_connectErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSession_connectErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpAppDataSession_superviseDataSessionRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSession_superviseDataSessionRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpAppDataSession_superviseDataSessionErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSession_superviseDataSessionErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpAppDataSession_dataSessionFaultDetected_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSession_dataSessionFaultDetected(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpAppDataSessionControlManager_dataSessionAborted_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSessionControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSessionControlManager_dataSessionAborted(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpAppDataSessionControlManager_reportNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSessionControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSessionControlManager_reportNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpAppDataSessionControlManager_dataSessionNotificationContinued_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSessionControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSessionControlManager_dataSessionNotificationContinued(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpAppDataSessionControlManager_dataSessionNotificationInterrupted_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSessionControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSessionControlManager_dataSessionNotificationInterrupted(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpAppDataSessionControlManager_abortMultipleDataSessions_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSessionControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSessionControlManager_abortMultipleDataSessions(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpDataSession_connectReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSession_connectReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpDataSession_release_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSession_release(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpDataSession_superviseDataSessionReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSession_superviseDataSessionReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpDataSession_setDataSessionChargePlan_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSession_setDataSessionChargePlan(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpDataSession_setAdviceOfCharge_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSession_setAdviceOfCharge(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpDataSession_deassignDataSession_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSession_deassignDataSession(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpDataSession_continueProcessing_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSession_continueProcessing(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpDataSessionControlManager_createNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSessionControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSessionControlManager_createNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpDataSessionControlManager_destroyNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSessionControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSessionControlManager_destroyNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpDataSessionControlManager_changeNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSessionControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSessionControlManager_changeNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpDataSessionControlManager_enableNotifications_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSessionControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSessionControlManager_enableNotifications(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpDataSessionControlManager_disableNotifications_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSessionControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSessionControlManager_disableNotifications(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpDataSessionControlManager_getNotifications_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSessionControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSessionControlManager_getNotifications(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_dsc_IpDataSessionControlManager_createNotifications_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSessionControlManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSessionControlManager_createNotifications(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMessagingManager_openMailbox_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessagingManager_openMailbox(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMessagingManager_enableMessagingNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessagingManager_enableMessagingNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMessagingManager_disableMessagingNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessagingManager_disableMessagingNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpAppMessagingManager_mailboxTerminated_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpAppMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpAppMessagingManager_mailboxTerminated(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpAppMessagingManager_mailboxFaultDetected_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpAppMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpAppMessagingManager_mailboxFaultDetected(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpAppMessagingManager_messagingEventNotify_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpAppMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpAppMessagingManager_messagingEventNotify(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpAppMessagingManager_messagingNotificationTerminated_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpAppMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpAppMessagingManager_messagingNotificationTerminated(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailbox_close_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_close(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailbox_lock_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_lock(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailbox_unlock_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_unlock(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailbox_getInfoAmount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_getInfoAmount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailbox_getInfoProperties_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_getInfoProperties(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailbox_setInfoProperties_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_setInfoProperties(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailbox_openFolder_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_openFolder(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailbox_createFolder_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_createFolder(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailbox_remove_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_remove(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMessage_getInfoAmount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessage") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessage_getInfoAmount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMessage_getInfoProperties_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessage") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessage_getInfoProperties(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMessage_setInfoProperties_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessage") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessage_setInfoProperties(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMessage_remove_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessage") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessage_remove(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMessage_getContent_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessage") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessage_getContent(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailboxFolder_getInfoAmount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailboxFolder") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailboxFolder_getInfoAmount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailboxFolder_getInfoProperties_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailboxFolder") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailboxFolder_getInfoProperties(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailboxFolder_setInfoProperties_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailboxFolder") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailboxFolder_setInfoProperties(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailboxFolder_putMessage_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailboxFolder") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailboxFolder_putMessage(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailboxFolder_getMessage_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailboxFolder") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailboxFolder_getMessage(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailboxFolder_close_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailboxFolder") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailboxFolder_close(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_gms_IpMailboxFolder_remove_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailboxFolder") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailboxFolder_remove(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpVPrP_getVPrPID_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrP") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrP_getVPrPID(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpVPrP_getSlaID_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrP") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrP_getSlaID(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpVPrP_getStatus_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrP") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrP_getStatus(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpVPrP_getProvisionedQoSInfo_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrP") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrP_getProvisionedQoSInfo(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpVPrP_getValidityInfo_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrP") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrP_getValidityInfo(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpVPrP_getPipeQoSInfo_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrP") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrP_getPipeQoSInfo(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpVPrP_getDsCodepoint_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrP") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrP_getDsCodepoint(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpVPrN_getVPrPList_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrN") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrN_getVPrPList(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpVPrN_getVPrP_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrN") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrN_getVPrP(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpVPrN_createVPrP_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrN") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrN_createVPrP(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpVPrN_deleteVPrP_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrN") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrN_deleteVPrP(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpQoSMenu_getTemplate_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSMenu") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSMenu_getTemplate(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpQoSMenu_getTemplateList_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSMenu") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSMenu_getTemplateList(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpConnectivityManager_getQoSMenu_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpConnectivityManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpConnectivityManager_getQoSMenu(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpConnectivityManager_getEnterpriseNetwork_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpConnectivityManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpConnectivityManager_getEnterpriseNetwork(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpQoSTemplate_getTemplateType_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_getTemplateType(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpQoSTemplate_getDescription_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_getDescription(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpQoSTemplate_setSlaID_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_setSlaID(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpQoSTemplate_getPipeQoSInfo_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_getPipeQoSInfo(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpQoSTemplate_setPipeQoSInfo_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_setPipeQoSInfo(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpQoSTemplate_getValidityInfo_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_getValidityInfo(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpQoSTemplate_setValidityInfo_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_setValidityInfo(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpQoSTemplate_setProvisionedQoSInfo_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_setProvisionedQoSInfo(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpQoSTemplate_getProvisionedQoSInfo_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_getProvisionedQoSInfo(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpQoSTemplate_getDsCodepoint_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_getDsCodepoint(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpEnterpriseNetwork_getSiteList_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetwork") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetwork_getSiteList(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpEnterpriseNetwork_getVPrN_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetwork") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetwork_getVPrN(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpEnterpriseNetwork_getSite_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetwork") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetwork_getSite(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpEnterpriseNetworkSite_getSAPList_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetworkSite") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetworkSite_getSAPList(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpEnterpriseNetworkSite_getSiteID_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetworkSite") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetworkSite_getSiteID(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpEnterpriseNetworkSite_getSiteLocation_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetworkSite") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetworkSite_getSiteLocation(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpEnterpriseNetworkSite_getSiteDescription_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetworkSite") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetworkSite_getSiteDescription(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpEnterpriseNetworkSite_getIPSubnet_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetworkSite") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetworkSite_getIPSubnet(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cm_IpEnterpriseNetworkSite_getSAPIPSubnet_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetworkSite") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetworkSite_getSAPIPSubnet(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_reportNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_reportNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_queryBalanceRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryBalanceRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_queryBalanceErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryBalanceErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_retrieveTransactionHistoryRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_retrieveTransactionHistoryRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_retrieveTransactionHistoryErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_retrieveTransactionHistoryErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_queryBalanceExpiryDateRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryBalanceExpiryDateRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_queryBalanceExpiryDateErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryBalanceExpiryDateErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_updateBalanceRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_updateBalanceRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_updateBalanceErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_updateBalanceErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_createVoucherRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_createVoucherRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_createVoucherErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_createVoucherErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_destroyVoucherRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_destroyVoucherRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_destroyVoucherErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_destroyVoucherErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_queryVoucherRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryVoucherRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_queryVoucherErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryVoucherErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_queryUserVouchersRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryUserVouchersRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAppAccountManager_queryUserVouchersErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryUserVouchersErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAccountManager_createNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_createNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAccountManager_destroyNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_destroyNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAccountManager_queryBalanceReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_queryBalanceReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAccountManager_changeNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_changeNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAccountManager_getNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_getNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAccountManager_retrieveTransactionHistoryReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_retrieveTransactionHistoryReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAccountManager_enableNotifications_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_enableNotifications(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAccountManager_disableNotifications_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_disableNotifications(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAccountManager_queryBalanceExpiryDateReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_queryBalanceExpiryDateReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAccountManager_updateBalanceReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_updateBalanceReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAccountManager_createVoucherReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_createVoucherReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAccountManager_destroyVoucherReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_destroyVoucherReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAccountManager_queryVoucherReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_queryVoucherReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_am_IpAccountManager_queryUserVouchersReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_queryUserVouchersReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_creditAmountErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_creditAmountErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_creditAmountRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_creditAmountRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_creditUnitErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_creditUnitErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_creditUnitRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_creditUnitRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_debitAmountErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_debitAmountErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_debitAmountRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_debitAmountRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_debitUnitErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_debitUnitErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_debitUnitRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_debitUnitRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_directCreditAmountErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directCreditAmountErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_directCreditAmountRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directCreditAmountRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_directCreditUnitErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directCreditUnitErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_directCreditUnitRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directCreditUnitRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_directDebitAmountErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directDebitAmountErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_directDebitAmountRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directDebitAmountRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_directDebitUnitErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directDebitUnitErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_directDebitUnitRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directDebitUnitRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_extendLifeTimeErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_extendLifeTimeErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_extendLifeTimeRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_extendLifeTimeRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_rateErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_rateErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_rateRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_rateRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_reserveAmountErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_reserveAmountErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_reserveAmountRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_reserveAmountRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_reserveUnitErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_reserveUnitErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_reserveUnitRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_reserveUnitRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingSession_sessionEnded_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_sessionEnded(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_creditAmountReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_creditAmountReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_creditUnitReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_creditUnitReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_debitAmountReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_debitAmountReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_debitUnitReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_debitUnitReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_directCreditAmountReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_directCreditAmountReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_directCreditUnitReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_directCreditUnitReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_directDebitAmountReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_directDebitAmountReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_directDebitUnitReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_directDebitUnitReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_extendLifeTimeReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_extendLifeTimeReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_getAmountLeft_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_getAmountLeft(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_getLifeTimeLeft_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_getLifeTimeLeft(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_getUnitLeft_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_getUnitLeft(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_rateReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_rateReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_release_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_release(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_reserveAmountReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_reserveAmountReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingSession_reserveUnitReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_reserveUnitReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingManager_sessionAborted_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingManager_sessionAborted(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpAppChargingManager_abortMultipleChargingSessions_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingManager_abortMultipleChargingSessions(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingManager_createChargingSession_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingManager_createChargingSession(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_cs_IpChargingManager_createSplitChargingSession_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingManager_createSplitChargingSession(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_evaluation_IpAppPolicyDomain_reportNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpAppPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpAppPolicyDomain_reportNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_evaluation_IpAppPolicyDomain_evalPolicyRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpAppPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpAppPolicyDomain_evalPolicyRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_evaluation_IpAppPolicyDomain_evalPolicyErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpAppPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpAppPolicyDomain_evalPolicyErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_evaluation_IpPolicyEvalManager_evalPolicy_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpPolicyEvalManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpPolicyEvalManager_evalPolicy(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_evaluation_IpPolicyEvalManager_evalPolicyReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpPolicyEvalManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpPolicyEvalManager_evalPolicyReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_evaluation_IpPolicyEvalManager_abortEvalPolicyReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpPolicyEvalManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpPolicyEvalManager_abortEvalPolicyReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_evaluation_IpPolicyEvalManager_generateEvent_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpPolicyEvalManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpPolicyEvalManager_generateEvent(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_evaluation_IpPolicyEvalManager_createNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpPolicyEvalManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpPolicyEvalManager_createNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_evaluation_IpPolicyEvalManager_destroyNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpPolicyEvalManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpPolicyEvalManager_destroyNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicy_getAttribute_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicy") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicy_getAttribute(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicy_setAttribute_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicy") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicy_setAttribute(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicy_getAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicy") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicy_getAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicy_setAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicy") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicy_setAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyIterator_getList_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyIterator") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyIterator_getList(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_getParentRepository_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getParentRepository(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_createRepository_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_createRepository(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_getRepository_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getRepository(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_removeRepository_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_removeRepository(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_getRepositoryCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getRepositoryCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_getRepositoryIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getRepositoryIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_createCondition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_createCondition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_getCondition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getCondition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_removeCondition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_removeCondition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_getConditionCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getConditionCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_getConditionIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getConditionIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_createAction_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_createAction(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_getAction_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getAction(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_removeAction_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_removeAction(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_getActionCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getActionCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRepository_getActionIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getActionIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_getParentGroup_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getParentGroup(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_getParentDomain_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getParentDomain(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_createCondition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_createCondition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_getCondition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getCondition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_removeCondition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_removeCondition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_getConditionCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getConditionCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_getConditionIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getConditionIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_createAction_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_createAction(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_getAction_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getAction(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_removeAction_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_removeAction(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_getActionCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getActionCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_getActionIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getActionIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_setValidityPeriodConditionByName_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_setValidityPeriodConditionByName(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_setValidityPeriodCondition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_setValidityPeriodCondition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_getValidityPeriodCondition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getValidityPeriodCondition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_unsetValidityPeriodCondition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_unsetValidityPeriodCondition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_setConditionList_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_setConditionList(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_getConditionList_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getConditionList(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_setActionList_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_setActionList(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyRule_getActionList_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getActionList(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyManager_createDomain_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_createDomain(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyManager_getDomain_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_getDomain(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyManager_removeDomain_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_removeDomain(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyManager_getDomainCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_getDomainCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyManager_getDomainIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_getDomainIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyManager_findMatchingDomains_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_findMatchingDomains(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyManager_createRepository_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_createRepository(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyManager_getRepository_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_getRepository(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyManager_removeRepository_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_removeRepository(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyManager_getRepositoryCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_getRepositoryCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyManager_getRepositoryIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_getRepositoryIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyManager_startTransaction_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_startTransaction(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyManager_commitTransaction_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_commitTransaction(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyManager_abortTransaction_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_abortTransaction(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyGroup_getParentDomain_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getParentDomain(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyGroup_getParentGroup_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getParentGroup(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyGroup_createGroup_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_createGroup(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyGroup_getGroup_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getGroup(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyGroup_removeGroup_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_removeGroup(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyGroup_getGroupCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getGroupCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyGroup_getGroupIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getGroupIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyGroup_createRule_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_createRule(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyGroup_getRule_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getRule(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyGroup_removeRule_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_removeRule(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyGroup_getRuleCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getRuleCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyGroup_getRuleIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getRuleIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyEventDefinition_setRequiredAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyEventDefinition") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_setRequiredAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyEventDefinition_setOptionalAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyEventDefinition") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_setOptionalAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyEventDefinition_getRequiredAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyEventDefinition") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_getRequiredAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyEventDefinition_getOptionalAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyEventDefinition") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_getOptionalAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyEventDefinition_getParentDomain_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyEventDefinition") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_getParentDomain(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyCondition_getParentRepository_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyCondition") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyCondition_getParentRepository(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyCondition_getParentRule_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyCondition") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyCondition_getParentRule(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyAction_getParentRepository_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyAction") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyAction_getParentRepository(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyAction_getParentRule_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyAction") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyAction_getParentRule(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicySignature_setInputVariables_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_setInputVariables(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicySignature_setOutputVariables_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_setOutputVariables(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicySignature_getInputVariables_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_getInputVariables(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicySignature_getOutputVariables_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_getOutputVariables(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicySignature_setGroupNames_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_setGroupNames(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicySignature_setPolicyRoles_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_setPolicyRoles(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicySignature_getGroupNames_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_getGroupNames(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicySignature_getPolicyRoles_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_getPolicyRoles(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicySignature_getParentDomain_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_getParentDomain(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getParentDomain_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getParentDomain(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_createDomain_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_createDomain(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getDomain_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getDomain(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_removeDomain_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_removeDomain(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getDomainCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getDomainCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getDomainIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getDomainIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_createGroup_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_createGroup(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getGroup_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getGroup(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_removeGroup_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_removeGroup(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getGroupCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getGroupCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getGroupIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getGroupIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_createRule_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_createRule(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getRule_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getRule(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_removeRule_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_removeRule(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getRuleCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getRuleCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getRuleIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getRuleIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_createEventDefinition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_createEventDefinition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_removeEventDefinition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_removeEventDefinition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinitionCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinitionCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinitionIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinitionIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_createVariableSet_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_createVariableSet(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getVariableSet_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableSet(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_removeVariableSet_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_removeVariableSet(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getVariableSetCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableSetCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getVariableSetIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableSetIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_createVariable_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_createVariable(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_setVariableValue_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_setVariableValue(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getVariableType_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableType(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getVariableValue_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableValue(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getVariable_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariable(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_removeVariable_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_removeVariable(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_createSignature_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_createSignature(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getSignature_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getSignature(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_removeSignature_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_removeSignature(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getSignatureCount_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getSignatureCount(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_policy_provisioning_IpPolicyDomain_getSignatureIterator_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getSignatureIterator(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_createIdentity_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_createIdentity(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_deleteIdentity_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_deleteIdentity(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_isIdentity_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_isIdentity(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_createGroupIdentity_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_createGroupIdentity(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_deleteGroupIdentity_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_deleteGroupIdentity(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_addToGroup_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_addToGroup(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_removeFromGroup_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_removeFromGroup(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_listMembers_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listMembers(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_isGroupIdentity_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_isGroupIdentity(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_listGroupMembership_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listGroupMembership(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_addAlias_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_addAlias(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_removeAliases_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_removeAliases(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_listAliases_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listAliases(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_lookupByAlias_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_lookupByAlias(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_associateTypes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_associateTypes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_disassociateTypes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_disassociateTypes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_listTypesOfIdentity_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listTypesOfIdentity(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_hasType_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_hasType(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_getIdentityAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_getIdentityAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityManagement_setIdentityAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_setIdentityAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentManagement_createAgent_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_createAgent(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentManagement_deleteAgent_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_deleteAgent(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentManagement_isAgent_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_isAgent(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentManagement_enableCapabilities_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_enableCapabilities(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentManagement_disableCapabilities_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_disableCapabilities(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentManagement_listEnabledCapabilities_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_listEnabledCapabilities(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentManagement_listAllCapabilities_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_listAllCapabilities(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentManagement_isCapableOf_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_isCapableOf(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentManagement_associateTypes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_associateTypes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentManagement_disassociateTypes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_disassociateTypes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentManagement_listTypesOfAgent_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_listTypesOfAgent(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentManagement_hasType_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_hasType(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentManagement_getAgentAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_getAgentAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentManagement_setAgentAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_setAgentAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentAssignment_assignAgent_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentAssignment") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_assignAgent(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentAssignment_unassignAgent_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentAssignment") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_unassignAgent(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssignedAgents_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentAssignment") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssignedAgents(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssociatedIdentitiesOfAgent_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentAssignment") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssociatedIdentitiesOfAgent(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssignedAgentsByCapability_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentAssignment") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssignedAgentsByCapability(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentAssignment_listCapabilitiesOfIdentity_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentAssignment") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listCapabilitiesOfIdentity(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentAssignment_isIdentityCapableOf_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentAssignment") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_isIdentityCapableOf(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_createIdentityAttribute_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_createIdentityAttribute(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_deleteIdentityAttribute_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_deleteIdentityAttribute(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_getIdentityAttributeDefinition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_getIdentityAttributeDefinition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listAllIdentityAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listAllIdentityAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_createIdentityType_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_createIdentityType(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_deleteIdentityType_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_deleteIdentityType(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listIdentityTypes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listIdentityTypes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_addIdentityTypeAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_addIdentityTypeAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_removeIdentityTypeAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_removeIdentityTypeAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listIdentityTypeAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listIdentityTypeAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentTypeManagement_createAgentAttribute_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_createAgentAttribute(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentTypeManagement_deleteAgentAttribute_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_deleteAgentAttribute(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentTypeManagement_getAgentAttributeDefinition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_getAgentAttributeDefinition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAllAgentAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAllAgentAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentTypeManagement_createAgentType_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_createAgentType(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentTypeManagement_deleteAgentType_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_deleteAgentType(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAgentTypes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAgentTypes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentTypeManagement_addAgentTypeAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_addAgentTypeAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentTypeManagement_removeAgentTypeAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_removeAgentTypeAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAgentTypeAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAgentTypeAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMCapabilityManagement_createCapabilityAttribute_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_createCapabilityAttribute(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMCapabilityManagement_deleteCapabilityAttribute_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_deleteCapabilityAttribute(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMCapabilityManagement_getCapabilityAttributeDefinition_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_getCapabilityAttributeDefinition(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMCapabilityManagement_listAllCapabilityAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listAllCapabilityAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMCapabilityManagement_createCapability_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_createCapability(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMCapabilityManagement_deleteCapability_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_deleteCapability(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilities_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilities(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMCapabilityManagement_addCapabilityAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_addCapabilityAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMCapabilityManagement_removeCapabilityAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_removeCapabilityAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilityAttributes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilityAttributes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMCapabilityManagement_assignCapabilitiesToType_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_assignCapabilitiesToType(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMCapabilityManagement_unassignCapabilitiesFromType_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_unassignCapabilitiesFromType(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilitiesOfType_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilitiesOfType(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMProvisioningManager_getAuthToken_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMProvisioningManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_getAuthToken(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMProvisioningManager_obtainInterface_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMProvisioningManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_obtainInterface(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMProvisioningManager_getAccessControl_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMProvisioningManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_getAccessControl(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_provisioning_IpPAMProvisioningManager_setAccessControl_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMProvisioningManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_setAccessControl(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMIdentityPresence_setIdentityPresence_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMIdentityPresence") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMIdentityPresence_setIdentityPresence(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMIdentityPresence_setIdentityPresenceExpiration_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMIdentityPresence") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMIdentityPresence_setIdentityPresenceExpiration(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMIdentityPresence_getIdentityPresence_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMIdentityPresence") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMIdentityPresence_getIdentityPresence(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMAgentPresence_setAgentPresence_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAgentPresence") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAgentPresence_setAgentPresence(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMAgentPresence_setCapabilityPresence_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAgentPresence") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAgentPresence_setCapabilityPresence(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMAgentPresence_setAgentPresenceExpiration_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAgentPresence") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAgentPresence_setAgentPresenceExpiration(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMAgentPresence_setCapabilityPresenceExpiration_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAgentPresence") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAgentPresence_setCapabilityPresenceExpiration(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMAgentPresence_getAgentPresence_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAgentPresence") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAgentPresence_getAgentPresence(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMAgentPresence_getCapabilityPresence_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAgentPresence") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAgentPresence_getCapabilityPresence(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpAppPAMPreferenceCheck_computeAvailability_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpAppPAMPreferenceCheck") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpAppPAMPreferenceCheck_computeAvailability(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMAvailability_getAvailability_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAvailability") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAvailability_getAvailability(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMAvailability_getPreference_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAvailability") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAvailability_getPreference(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMAvailability_setPreference_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAvailability") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAvailability_setPreference(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMPresenceAvailabilityManager_getAuthToken_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMPresenceAvailabilityManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_getAuthToken(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMPresenceAvailabilityManager_obtainInterface_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMPresenceAvailabilityManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_obtainInterface(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMPresenceAvailabilityManager_getAccessControl_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMPresenceAvailabilityManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_getAccessControl(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMPresenceAvailabilityManager_setAccessControl_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMPresenceAvailabilityManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_setAccessControl(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMPresenceAvailabilityManager_activateService_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMPresenceAvailabilityManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_activateService(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMPresenceAvailabilityManager_deactivateService_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMPresenceAvailabilityManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_deactivateService(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_access_IpPAMPresenceAvailabilityManager_isActiveIdentity_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMPresenceAvailabilityManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_isActiveIdentity(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_event_IpAppPAMEventHandler_eventNotify_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpAppPAMEventHandler") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpAppPAMEventHandler_eventNotify(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_event_IpAppPAMEventHandler_eventNotifyErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpAppPAMEventHandler") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpAppPAMEventHandler_eventNotifyErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_event_IpPAMEventHandler_isRegistered_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventHandler") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventHandler_isRegistered(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_event_IpPAMEventHandler_registerAppInterface_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventHandler") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventHandler_registerAppInterface(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_event_IpPAMEventHandler_registerForEvent_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventHandler") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventHandler_registerForEvent(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_event_IpPAMEventHandler_deregisterAppInterface_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventHandler") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventHandler_deregisterAppInterface(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_event_IpPAMEventHandler_deregisterFromEvent_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventHandler") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventHandler_deregisterFromEvent(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_event_IpPAMEventManager_getAuthToken_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventManager_getAuthToken(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_event_IpPAMEventManager_obtainInterface_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventManager_obtainInterface(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_event_IpPAMEventManager_getAccessControl_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventManager_getAccessControl(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_event_IpPAMEventManager_setAccessControl_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventManager_setAccessControl(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_event_IpPAMEventManager_activateService_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventManager_activateService(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_event_IpPAMEventManager_deactivateService_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventManager_deactivateService(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_pam_event_IpPAMEventManager_isActiveIdentity_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventManager_isActiveIdentity(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessagingManager_mailboxTerminated_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_mailboxTerminated(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessagingManager_reportNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_reportNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessagingManager_notificationsInterrupted_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_notificationsInterrupted(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessagingManager_notificationsResumed_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_notificationsResumed(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessagingManager_multiMediaMessagingTerminated_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_multiMediaMessagingTerminated(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessagingManager_terminateMultipleMailboxes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_terminateMultipleMailboxes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessagingManager_terminateMultipleMultiMediaMessagingSessions_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_terminateMultipleMultiMediaMessagingSessions(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMultiMediaMessagingManager_openMailbox_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_openMailbox(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMultiMediaMessagingManager_openMultiMediaMessaging_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_openMultiMediaMessaging(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMultiMediaMessagingManager_createNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_createNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMultiMediaMessagingManager_destroyNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_destroyNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMultiMediaMessagingManager_changeNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_changeNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMultiMediaMessagingManager_getNextNotification_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_getNextNotification(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMultiMediaMessagingManager_enableNotifications_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_enableNotifications(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMultiMediaMessagingManager_disableNotifications_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_disableNotifications(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_createFolderRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_createFolderRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_createFolderErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_createFolderErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getFoldersRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getFoldersRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getFoldersErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getFoldersErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_deleteFolderRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_deleteFolderRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_deleteFolderErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_deleteFolderErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_copyFolderRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_copyFolderRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_copyFolderErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_copyFolderErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_moveFolderRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_moveFolderRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_moveFolderErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_moveFolderErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_putMessageRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_putMessageRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_putMessageErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_putMessageErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_copyMessageRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_copyMessageRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_copyMessageErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_copyMessageErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_moveMessageRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_moveMessageRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_moveMessageErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_moveMessageErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_deleteMessageRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_deleteMessageRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_deleteMessageErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_deleteMessageErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_listMessagesRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_listMessagesRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_listMessagesErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_listMessagesErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_listMessageBodyPartsRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_listMessageBodyPartsRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_listMessageBodyPartsErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_listMessageBodyPartsErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getMessageBodyPartsRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageBodyPartsRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getMessageBodyPartsErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageBodyPartsErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getMessageHeadersRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageHeadersRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getMessageHeadersErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageHeadersErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getMessageContentRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageContentRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getMessageContentErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageContentErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getFullMessageRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getFullMessageRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getFullMessageErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getFullMessageErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getMailboxInfoPropertiesRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMailboxInfoPropertiesRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getFolderInfoPropertiesRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getFolderInfoPropertiesRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getMessageInfoPropertiesRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageInfoPropertiesRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_setMessageInfoPropertiesRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_setMessageInfoPropertiesRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_setMessageInfoPropertiesErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_setMessageInfoPropertiesErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getMailboxInfoPropertiesErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMailboxInfoPropertiesErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getFolderInfoPropertiesErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getFolderInfoPropertiesErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMailbox_getMessageInfoPropertiesErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageInfoPropertiesErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_close_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_close(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_createFolderReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_createFolderReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_getFoldersReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getFoldersReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_deleteFolderReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_deleteFolderReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_copyFolderReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_copyFolderReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_moveFolderReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_moveFolderReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_putMessageReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_putMessageReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_copyMessageReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_copyMessageReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_moveMessageReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_moveMessageReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_deleteMessageReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_deleteMessageReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_listMessagesReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_listMessagesReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_listMessageBodyPartsReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_listMessageBodyPartsReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_getMessageBodyPartsReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getMessageBodyPartsReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_getMessageHeadersReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getMessageHeadersReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_getMessageContentReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getMessageContentReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_getFullMessageReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getFullMessageReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_getMailboxInfoPropertiesReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getMailboxInfoPropertiesReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_getFolderInfoPropertiesReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getFolderInfoPropertiesReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_getMessageInfoPropertiesReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getMessageInfoPropertiesReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMailbox_setMessageInfoPropertiesReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_setMessageInfoPropertiesReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessaging_sendMessageRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_sendMessageRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessaging_sendMessageErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_sendMessageErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessaging_cancelMessageRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_cancelMessageRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessaging_cancelMessageErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_cancelMessageErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessaging_queryStatusRes_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_queryStatusRes(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessaging_queryStatusErr_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_queryStatusErr(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessaging_messageStatusReport_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_messageStatusReport(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpAppMultiMediaMessaging_messageReceived_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_messageReceived(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMultiMediaMessaging_sendMessageReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessaging") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessaging_sendMessageReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMultiMediaMessaging_cancelMessageReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessaging") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessaging_cancelMessageReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMultiMediaMessaging_queryStatusReq_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessaging") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessaging_queryStatusReq(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        if (strcmp(operation, org_csapi_mmm_IpMultiMediaMessaging_close_op) == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessaging") == 0)) {
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessaging_close(tvb, pinfo, tree, offset, header, operation);
           return TRUE;
        }

        
        break;

    case CancelRequest:
    case LocateRequest:
    case LocateReply:
    case CloseConnection:
    case MessageError:
    case Fragment:
       return FALSE;      /* not handled yet */

    default:
       return FALSE;      /* not handled yet */

    }   /* switch */


    return FALSE;

}  /* End of main dissector  */



/* Register the protocol with Ethereal */

void proto_register_giop_parlay(void) {

   /* setup list of header fields */

#if 0
   static hf_register_info hf[] = {

      /* no fields yet */

   };
#endif

   /* setup protocol subtree array */

   static gint *ett[] = {
      &ett_parlay,
   };

   /* Register the protocol name and description */

   proto_parlay = proto_register_protocol("Parlay Dissector Using GIOP API" , "PARLAY", "giop-parlay" );

#if 0
   proto_register_field_array(proto_parlay, hf, array_length(hf));
#endif
   proto_register_subtree_array(ett,array_length(ett));

}


/* register me as handler for these interfaces */

void proto_register_handoff_giop_parlay(void) {


    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/IpService", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/am/IpAccountManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/am/IpAppAccountManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/cccs/IpAppConfCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/cccs/IpAppConfCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/cccs/IpAppSubConfCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/cccs/IpConfCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/cccs/IpConfCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/cccs/IpSubConfCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/gccs/IpAppCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/gccs/IpAppCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/gccs/IpCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/gccs/IpCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mmccs/IpAppMultiMediaCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mmccs/IpAppMultiMediaCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mmccs/IpAppMultiMediaCallLeg", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mmccs/IpMultiMediaCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mmccs/IpMultiMediaCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mmccs/IpMultiMediaCallLeg", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mmccs/IpMultiMediaStream", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mpccs/IpAppCallLeg", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mpccs/IpAppMultiPartyCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mpccs/IpCallLeg", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mpccs/IpMultiPartyCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mpccs/IpMultiPartyCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cm/IpConnectivityManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cm/IpEnterpriseNetwork", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cm/IpEnterpriseNetworkSite", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cm/IpQoSMenu", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cm/IpQoSTemplate", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cm/IpVPrN", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cm/IpVPrP", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cs/IpAppChargingManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cs/IpAppChargingSession", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cs/IpChargingManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cs/IpChargingSession", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/dsc/IpAppDataSession", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/dsc/IpAppDataSessionControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/dsc/IpDataSession", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/dsc/IpDataSessionControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_access/trust_and_security/IpAccess", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_access/trust_and_security/IpAuthentication", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_access/trust_and_security/IpClientAccess", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_access/trust_and_security/IpInitial", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/discovery/IpServiceDiscovery", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpAppFaultManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpAppHeartBeat", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpAppHeartBeatMgmt", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpAppLoadManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpAppOAM", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpFaultManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpHeartBeat", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpHeartBeatMgmt", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpLoadManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpOAM", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/notification/IpAppEventNotification", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/notification/IpEventNotification", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/service_agreement/IpAppServiceAgreementManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/notification/IpClientEventNotification", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/notification/IpEventNotification", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountInfoQuery", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractInfoQuery", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileInfoQuery", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpFwFaultManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpFwHeartBeat", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpFwHeartBeatMgmt", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpFwLoadManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpFwOAM", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpSvcFaultManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpSvcHeartBeat", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpSvcHeartBeatMgmt", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpSvcLoadManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpSvcOAM", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/notification/IpFwEventNotification", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/notification/IpSvcEventNotification", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/service_lifecycle/IpServiceInstanceLifecycleManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/gms/IpAppMessagingManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/gms/IpMailbox", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/gms/IpMailboxFolder", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/gms/IpMessage", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/gms/IpMessagingManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ub/IpAppUserBinding", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ub/IpUserBinding", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ul/IpAppTriggeredUserLocation", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ul/IpAppUserLocation", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ul/IpTriggeredUserLocation", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ul/IpUserLocation", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ulc/IpAppUserLocationCamel", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ulc/IpUserLocationCamel", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ule/IpAppUserLocationEmergency", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ule/IpUserLocationEmergency", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/us/IpAppUserStatus", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/us/IpUserStatus", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mmm/IpAppMailbox", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mmm/IpAppMultiMediaMessaging", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mmm/IpAppMultiMediaMessagingManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mmm/IpMailbox", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mmm/IpMultiMediaMessaging", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mmm/IpMultiMediaMessagingManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/access/IpAppPAMPreferenceCheck", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/access/IpPAMAgentPresence", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/access/IpPAMAvailability", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/access/IpPAMIdentityPresence", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/access/IpPAMPresenceAvailabilityManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/event/IpAppPAMEventHandler", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/event/IpPAMEventHandler", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/event/IpPAMEventManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/provisioning/IpPAMAgentAssignment", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/provisioning/IpPAMAgentManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/provisioning/IpPAMAgentTypeManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/provisioning/IpPAMCapabilityManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/provisioning/IpPAMIdentityManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/provisioning/IpPAMProvisioningManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/evaluation/IpAppPolicyDomain", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/evaluation/IpPolicyEvalManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicy", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyAction", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyCondition", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyDomain", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyEventDefinition", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyGroup", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyIterator", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyRepository", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyRule", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicySignature", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/termcap/IpAppExtendedTerminalCapabilities", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/termcap/IpExtendedTerminalCapabilities", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/termcap/IpTerminalCapabilities", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpAppUI", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpAppUIAdminManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpAppUICall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpAppUIManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpUI", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpUIAdminManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpUICall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpUIManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Heuristic Dissection */

    register_giop_user(dissect_parlay, "PARLAY" ,proto_parlay);     /* heuristic dissector */


}


#ifndef ENABLE_STATIC

G_MODULE_EXPORT void
plugin_register(void)
{
   if (proto_parlay == -1) {
     proto_register_giop_parlay();
   }
}

G_MODULE_EXPORT void
plugin_reg_handoff(void){
   proto_register_handoff_giop_parlay();
}
#endif

