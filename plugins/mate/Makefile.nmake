# Makefile.nmake
# nmake file for mate plugin
#

include ..\..\config.nmake
include ..\..\Makefile.nmake.inc

include moduleinfo.nmake

include Makefile.common

LEMON=..\..\tools\lemon

# We use DIRTY_CFLAGS to get around flex's non-LLP64-compliant output
DIRTY_CFLAGS=\
	$(STANDARD_CFLAGS) \
	/I../.. $(GLIB_CFLAGS) /I$(LEMON) \
	/I$(PCAP_DIR)\include

CFLAGS=$(WARNINGS_ARE_ERRORS) $(DIRTY_CFLAGS)

.c.obj::
	$(CC) $(CFLAGS) -Fd.\ -c $<

LDFLAGS = $(PLUGIN_LDFLAGS)

!IFDEF ENABLE_LIBWIRESHARK
LINK_PLUGIN_WITH=..\..\epan\libwireshark.lib ..\..\wsutil\libwsutil.lib
CFLAGS=$(CFLAGS)

OBJECTS = $(C_FILES:.c=.obj) $(CPP_FILES:.cpp=.obj) plugin.obj

RESOURCE=$(PLUGIN_NAME).res

all: $(PLUGIN_NAME).dll

$(PLUGIN_NAME).rc : moduleinfo.nmake
	sed -e s/@PLUGIN_NAME@/$(PLUGIN_NAME)/ \
	-e s/@RC_MODULE_VERSION@/$(RC_MODULE_VERSION)/ \
	-e s/@RC_VERSION@/$(RC_VERSION)/ \
	-e s/@MODULE_VERSION@/$(MODULE_VERSION)/ \
	-e s/@PACKAGE@/$(PACKAGE)/ \
	-e s/@VERSION@/$(VERSION)/ \
	-e s/@MSVC_VARIANT@/$(MSVC_VARIANT)/ \
	< plugin.rc.in > $@

$(PLUGIN_NAME).dll $(PLUGIN_NAME).exp $(PLUGIN_NAME).lib : $(OBJECTS) $(LINK_PLUGIN_WITH) $(RESOURCE)
	link -dll /out:$(PLUGIN_NAME).dll $(LDFLAGS) $(OBJECTS) $(LINK_PLUGIN_WITH) \
	$(GLIB_LIBS) $(RESOURCE)

#
# Build plugin.c, which contains the plugin version[] string, a
# function plugin_register() that calls the register routines for all
# protocols, and a function plugin_reg_handoff() that calls the handoff
# registration routines for all protocols.
#
# We do this by scanning sources.  If that turns out to be too slow,
# maybe we could just require every .o file to have an register routine
# of a given name (packet-aarp.o -> proto_register_aarp, etc.).
#
# Formatting conventions:  The name of the proto_register_* routines an
# proto_reg_handoff_* routines must start in column zero, or must be
# preceded only by "void " starting in column zero, and must not be
# inside #if.
#
# REGISTER_SRC_FILES is assumed to have all the files that need to be scanned.
#
# For some unknown reason, having a big "for" loop in the Makefile
# to scan all the files doesn't work with some "make"s; they seem to
# pass only the first few names in the list to the shell, for some
# reason.
#
# Therefore, we have a script to generate the plugin.c file.
# The shell script runs slowly, as multiple greps and seds are run
# for each input file; this is especially slow on Windows.  Therefore,
# if Python is present (as indicated by PYTHON being defined), we run
# a faster Python script to do that work instead.
#
# The first argument is the directory in which the source files live.
# The second argument is "plugin", to indicate that we should build
# a plugin.c file for a plugin.
# All subsequent arguments are the files to scan.
#
!IFDEF PYTHON
plugin.c: $(REGISTER_SRC_FILES) moduleinfo.h Makefile.common ../../tools/make-dissector-reg.py
	@echo Making plugin.c (using python)
	@$(PYTHON) "../../tools/make-dissector-reg.py" . plugin $(REGISTER_SRC_FILES) $(NODIST_REGISTER_SRC_FILES)
!ELSE
plugin.c: $(REGISTER_SRC_FILES) moduleinfo.h Makefile.common ../../tools/make-dissector-reg
	@echo Making plugin.c (using sh)
	@$(SH) ../../tools/make-dissector-reg . plugin $(REGISTER_SRC_FILES) $(NODIST_REGISTER_SRC_FILES)
!ENDIF

!ENDIF

clean:
	rm -f $(OBJECTS) $(RESOURCE) plugin.c *.pdb *.sbr \
	    $(PLUGIN_NAME).dll $(PLUGIN_NAME).dll.manifest $(PLUGIN_NAME).lib \
	    $(PLUGIN_NAME).exp $(PLUGIN_NAME).rc

#
# We remove the Flex-generated files with "distclean" because files
# generated by Flex need different #includes for UN*X and Windows (UN*X
# versions of Flex make it include <unistd.h>, but that's a UN*X-only
# header), so if you're going to build from source, you need to re-generate
# the files from the distribution that were generated by Flex.
#
distclean: clean
	rm -f $(FLEX_GENERATED_SRC_FILES) \
		$(FLEX_GENERATED_HEADER_FILES) \
		$(NODIST_SRC_FILES) \
		$(NODIST_HEADER_FILES) \
		mate_grammar.out

maintainer-clean: distclean
	rm -f $(GENERATED_SRC_FILES) \
		$(GENERATED_HEADER_FILES)

RUNLEX = ..\..\tools\runlex.sh

#
# In order to generate mate_parser_lex.h, we need to run Flex on
# mate_parser.l; that's done by generating mate_parser.c.
#
mate_parser_lex.h : mate_parser.c

#
# We compile this specially because it's Flex-generated and thus
# "warnings are errors" will fail because there's a bunch of
# warnings we can't eliminate.
#
# It depends on mate_grammar.h to force mate_grammar.h to be
# built before we try to compile it, as mate_parser.c includes
# mate_grammar.h, and mate_grammar.h is not distributed with
# the source (it's generated with Lemon).  That means we can't
# use $?, as that would make it try to compile mate_grammar.h.
#
mate_parser.obj : mate_grammar.h
mate_parser.obj : mate_parser.c
	$(CC) $(DIRTY_CFLAGS) -Fd.\ -c mate_parser.c

mate_grammar.h : mate_grammar.c
mate_grammar.c : mate_grammar.lemon $(LEMON)\lemon.exe
	$(LEMON)\lemon.exe t=$(LEMON)\lempar.c mate_grammar.lemon

$(LEMON)\lemon.exe:
	cd ../../tools
	$(MAKE) /$(MAKEFLAGS) -f Makefile.nmake lemon
	cd ../plugins/mate

checkapi:
	$(PERL) ../../tools/checkAPIs.pl -g abort -g termoutput -build \
		$(CLEAN_SRC_FILES) $(CLEAN_HEADER_FILES)
